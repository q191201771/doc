<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Document Structure">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terms and Definitions">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Streams">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Stream Types and Identifiers">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Sending and Receiving Data">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Stream Prioritization">
<link href="#rfc.section.3" rel="Chapter" title="3 Stream States">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Sending Stream States">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Receiving Stream States">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Permitted Frame Types">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Bidirectional Stream States">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Solicited State Transitions">
<link href="#rfc.section.4" rel="Chapter" title="4 Flow Control">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Data Flow Control">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Flow Credit Increments">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Handling Stream Cancellation">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Stream Final Size">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Controlling Concurrency">
<link href="#rfc.section.5" rel="Chapter" title="5 Connections">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Connection ID">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Issuing Connection IDs">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Consuming and Retiring Connection IDs">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Matching Packets to Connections">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Client Packet Handling">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Server Packet Handling">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Life of a QUIC Connection">
<link href="#rfc.section.6" rel="Chapter" title="6 Version Negotiation">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Sending Version Negotiation Packets">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Handling Version Negotiation Packets">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Version Negotiation Between Draft Versions">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Using Reserved Versions">
<link href="#rfc.section.7" rel="Chapter" title="7 Cryptographic and Transport Handshake">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Example Handshake Flows">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Negotiating Connection IDs">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Transport Parameters">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Values of Transport Parameters for 0-RTT">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 New Transport Parameters">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Cryptographic Message Buffering">
<link href="#rfc.section.8" rel="Chapter" title="8 Address Validation">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Address Validation During Connection Establishment">
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 Address Validation using Retry Packets">
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 Address Validation for Future Connections">
<link href="#rfc.section.8.1.3" rel="Chapter" title="8.1.3 Address Validation Token Integrity">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Path Validation">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Initiating Path Validation">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Path Validation Responses">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Successful Path Validation">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 Failed Path Validation">
<link href="#rfc.section.9" rel="Chapter" title="9 Connection Migration">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Probing a New Path">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Initiating Connection Migration">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Responding to Connection Migration">
<link href="#rfc.section.9.3.1" rel="Chapter" title="9.3.1 Peer Address Spoofing">
<link href="#rfc.section.9.3.2" rel="Chapter" title="9.3.2 On-Path Address Spoofing">
<link href="#rfc.section.9.3.3" rel="Chapter" title="9.3.3 Off-Path Packet Forwarding">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Loss Detection and Congestion Control">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Privacy Implications of Connection Migration">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 Server&#8217;s Preferred Address">
<link href="#rfc.section.9.6.1" rel="Chapter" title="9.6.1 Communicating A Preferred Address">
<link href="#rfc.section.9.6.2" rel="Chapter" title="9.6.2 Responding to Connection Migration">
<link href="#rfc.section.9.6.3" rel="Chapter" title="9.6.3 Interaction of Client Migration and Preferred Address">
<link href="#rfc.section.9.7" rel="Chapter" title="9.7 Use of IPv6 Flow-Label and Migration">
<link href="#rfc.section.10" rel="Chapter" title="10 Connection Termination">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Closing and Draining Connection States">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Idle Timeout">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Immediate Close">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Stateless Reset">
<link href="#rfc.section.10.4.1" rel="Chapter" title="10.4.1 Detecting a Stateless Reset">
<link href="#rfc.section.10.4.2" rel="Chapter" title="10.4.2 Calculating a Stateless Reset Token">
<link href="#rfc.section.10.4.3" rel="Chapter" title="10.4.3 Looping">
<link href="#rfc.section.11" rel="Chapter" title="11 Error Handling">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Connection Errors">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Stream Errors">
<link href="#rfc.section.12" rel="Chapter" title="12 Packets and Frames">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Protected Packets">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Coalescing Packets">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Packet Numbers">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Frames and Frame Types">
<link href="#rfc.section.13" rel="Chapter" title="13 Packetization and Reliability">
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 Packet Processing and Acknowledgment">
<link href="#rfc.section.13.1.1" rel="Chapter" title="13.1.1 Sending ACK Frames">
<link href="#rfc.section.13.1.2" rel="Chapter" title="13.1.2 ACK Frames and Packet Protection">
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 Retransmission of Information">
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 Explicit Congestion Notification">
<link href="#rfc.section.13.3.1" rel="Chapter" title="13.3.1 ECN Counts">
<link href="#rfc.section.13.3.2" rel="Chapter" title="13.3.2 ECN Verification">
<link href="#rfc.section.14" rel="Chapter" title="14 Packet Size">
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 Path Maximum Transmission Unit (PMTU)">
<link href="#rfc.section.14.2" rel="Chapter" title="14.2 ICMP Packet Too Big Messages">
<link href="#rfc.section.14.3" rel="Chapter" title="14.3 Datagram Packetization Layer PMTU Discovery">
<link href="#rfc.section.15" rel="Chapter" title="15 Versions">
<link href="#rfc.section.16" rel="Chapter" title="16 Variable-Length Integer Encoding">
<link href="#rfc.section.17" rel="Chapter" title="17 Packet Formats">
<link href="#rfc.section.17.1" rel="Chapter" title="17.1 Packet Number Encoding and Decoding">
<link href="#rfc.section.17.2" rel="Chapter" title="17.2 Long Header Packets">
<link href="#rfc.section.17.2.1" rel="Chapter" title="17.2.1 Version Negotiation Packet">
<link href="#rfc.section.17.2.2" rel="Chapter" title="17.2.2 Initial Packet">
<link href="#rfc.section.17.2.3" rel="Chapter" title="17.2.3 0-RTT">
<link href="#rfc.section.17.2.4" rel="Chapter" title="17.2.4 Handshake Packet">
<link href="#rfc.section.17.2.5" rel="Chapter" title="17.2.5 Retry Packet">
<link href="#rfc.section.17.3" rel="Chapter" title="17.3 Short Header Packets">
<link href="#rfc.section.17.3.1" rel="Chapter" title="17.3.1 Latency Spin Bit">
<link href="#rfc.section.18" rel="Chapter" title="18 Transport Parameter Encoding">
<link href="#rfc.section.18.1" rel="Chapter" title="18.1 Transport Parameter Definitions">
<link href="#rfc.section.19" rel="Chapter" title="19 Frame Types and Formats">
<link href="#rfc.section.19.1" rel="Chapter" title="19.1 PADDING Frame">
<link href="#rfc.section.19.2" rel="Chapter" title="19.2 PING Frame">
<link href="#rfc.section.19.3" rel="Chapter" title="19.3 ACK Frames">
<link href="#rfc.section.19.3.1" rel="Chapter" title="19.3.1 ACK Ranges">
<link href="#rfc.section.19.3.2" rel="Chapter" title="19.3.2 ECN Counts">
<link href="#rfc.section.19.4" rel="Chapter" title="19.4 RESET_STREAM Frame">
<link href="#rfc.section.19.5" rel="Chapter" title="19.5 STOP_SENDING Frame">
<link href="#rfc.section.19.6" rel="Chapter" title="19.6 CRYPTO Frame">
<link href="#rfc.section.19.7" rel="Chapter" title="19.7 NEW_TOKEN Frame">
<link href="#rfc.section.19.8" rel="Chapter" title="19.8 STREAM Frames">
<link href="#rfc.section.19.9" rel="Chapter" title="19.9 MAX_DATA Frame">
<link href="#rfc.section.19.10" rel="Chapter" title="19.10 MAX_STREAM_DATA Frame">
<link href="#rfc.section.19.11" rel="Chapter" title="19.11 MAX_STREAMS Frames">
<link href="#rfc.section.19.12" rel="Chapter" title="19.12 DATA_BLOCKED Frame">
<link href="#rfc.section.19.13" rel="Chapter" title="19.13 STREAM_DATA_BLOCKED Frame">
<link href="#rfc.section.19.14" rel="Chapter" title="19.14 STREAMS_BLOCKED Frames">
<link href="#rfc.section.19.15" rel="Chapter" title="19.15 NEW_CONNECTION_ID Frame">
<link href="#rfc.section.19.16" rel="Chapter" title="19.16 RETIRE_CONNECTION_ID Frame">
<link href="#rfc.section.19.17" rel="Chapter" title="19.17 PATH_CHALLENGE Frame">
<link href="#rfc.section.19.18" rel="Chapter" title="19.18 PATH_RESPONSE Frame">
<link href="#rfc.section.19.19" rel="Chapter" title="19.19 CONNECTION_CLOSE Frames">
<link href="#rfc.section.19.20" rel="Chapter" title="19.20 Extension Frames">
<link href="#rfc.section.20" rel="Chapter" title="20 Transport Error Codes">
<link href="#rfc.section.20.1" rel="Chapter" title="20.1 Application Protocol Error Codes">
<link href="#rfc.section.21" rel="Chapter" title="21 Security Considerations">
<link href="#rfc.section.21.1" rel="Chapter" title="21.1 Handshake Denial of Service">
<link href="#rfc.section.21.2" rel="Chapter" title="21.2 Amplification Attack">
<link href="#rfc.section.21.3" rel="Chapter" title="21.3 Optimistic ACK Attack">
<link href="#rfc.section.21.4" rel="Chapter" title="21.4 Slowloris Attacks">
<link href="#rfc.section.21.5" rel="Chapter" title="21.5 Stream Fragmentation and Reassembly Attacks">
<link href="#rfc.section.21.6" rel="Chapter" title="21.6 Stream Commitment Attack">
<link href="#rfc.section.21.7" rel="Chapter" title="21.7 Explicit Congestion Notification Attacks">
<link href="#rfc.section.21.8" rel="Chapter" title="21.8 Stateless Reset Oracle">
<link href="#rfc.section.21.9" rel="Chapter" title="21.9 Version Downgrade">
<link href="#rfc.section.22" rel="Chapter" title="22 IANA Considerations">
<link href="#rfc.section.22.1" rel="Chapter" title="22.1 QUIC Transport Parameter Registry">
<link href="#rfc.section.22.2" rel="Chapter" title="22.2 QUIC Frame Type Registry">
<link href="#rfc.section.22.3" rel="Chapter" title="22.3 QUIC Transport Error Codes Registry">
<link href="#rfc.references" rel="Chapter" title="23 References">
<link href="#rfc.references.1" rel="Chapter" title="23.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="23.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Sample Packet Number Decoding Algorithm">
<link href="#rfc.appendix.B" rel="Chapter" title="B Change Log">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Since draft-ietf-quic-transport-19">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Since draft-ietf-quic-transport-18">
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Since draft-ietf-quic-transport-17">
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Since draft-ietf-quic-transport-16">
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 Since draft-ietf-quic-transport-15">
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 Since draft-ietf-quic-transport-14">
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 Since draft-ietf-quic-transport-13">
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 Since draft-ietf-quic-transport-12">
<link href="#rfc.appendix.B.9" rel="Chapter" title="B.9 Since draft-ietf-quic-transport-11">
<link href="#rfc.appendix.B.10" rel="Chapter" title="B.10 Since draft-ietf-quic-transport-10">
<link href="#rfc.appendix.B.11" rel="Chapter" title="B.11 Since draft-ietf-quic-transport-09">
<link href="#rfc.appendix.B.12" rel="Chapter" title="B.12 Since draft-ietf-quic-transport-08">
<link href="#rfc.appendix.B.13" rel="Chapter" title="B.13 Since draft-ietf-quic-transport-07">
<link href="#rfc.appendix.B.14" rel="Chapter" title="B.14 Since draft-ietf-quic-transport-06">
<link href="#rfc.appendix.B.15" rel="Chapter" title="B.15 Since draft-ietf-quic-transport-05">
<link href="#rfc.appendix.B.16" rel="Chapter" title="B.16 Since draft-ietf-quic-transport-04">
<link href="#rfc.appendix.B.17" rel="Chapter" title="B.17 Since draft-ietf-quic-transport-03">
<link href="#rfc.appendix.B.18" rel="Chapter" title="B.18 Since draft-ietf-quic-transport-02">
<link href="#rfc.appendix.B.19" rel="Chapter" title="B.19 Since draft-ietf-quic-transport-01">
<link href="#rfc.appendix.B.20" rel="Chapter" title="B.20 Since draft-ietf-quic-transport-00">
<link href="#rfc.appendix.B.21" rel="Chapter" title="B.21 Since draft-hamilton-quic-transport-protocol-01">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.contributors" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
<meta name="viewport" content="width=600;" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and M. Thomson, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-transport-20" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-04-23" />
  <meta name="dct.abstract" content="This document defines the core of the QUIC transport protocol.  Accompanying documents describe QUIC&#8217;s loss detection and congestion control and the use of TLS for key negotiation." />
  <meta name="description" content="This document defines the core of the QUIC transport protocol.  Accompanying documents describe QUIC&#8217;s loss detection and congestion control and the use of TLS for key negotiation." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Fastly</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. Thomson, Ed.</td>
</tr>
<tr>
<td class="left">Expires: October 25, 2019</td>
<td class="right">Mozilla</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">April 23, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC: A UDP-Based Multiplexed and Secure Transport<br />
  <span class="filename">draft-ietf-quic-transport-20</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines the core of the QUIC transport protocol.  Accompanying documents describe QUIC&#8217;s loss detection and congestion control and the use of TLS for key negotiation.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at &lt;https://mailarchive.ietf.org/arch/search/?email_list=quic&gt;.</p>
<p>Working Group information can be found at &lt;https://github.com/quicwg&gt;; source code and issues list for this draft can be found at &lt;https://github.com/quicwg/base-drafts/labels/-transport&gt;.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 25, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Document Structure</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terms and Definitions</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Notational Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Streams</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Stream Types and Identifiers</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Sending and Receiving Data</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Stream Prioritization</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Stream States</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Sending Stream States</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Receiving Stream States</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Permitted Frame Types</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Bidirectional Stream States</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Solicited State Transitions</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Flow Control</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Data Flow Control</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Flow Credit Increments</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Handling Stream Cancellation</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Stream Final Size</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Controlling Concurrency</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Connections</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Connection ID</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Issuing Connection IDs</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Consuming and Retiring Connection IDs</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Matching Packets to Connections</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Client Packet Handling</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Server Packet Handling</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Life of a QUIC Connection</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Version Negotiation</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Sending Version Negotiation Packets</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Handling Version Negotiation Packets</a>
</li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Version Negotiation Between Draft Versions</a>
</li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Using Reserved Versions</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Cryptographic and Transport Handshake</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Example Handshake Flows</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Negotiating Connection IDs</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Transport Parameters</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Values of Transport Parameters for 0-RTT</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">New Transport Parameters</a>
</li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Cryptographic Message Buffering</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Address Validation</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Address Validation During Connection Establishment</a>
</li>
<ul><li>8.1.1.   <a href="#rfc.section.8.1.1">Address Validation using Retry Packets</a>
</li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">Address Validation for Future Connections</a>
</li>
<li>8.1.3.   <a href="#rfc.section.8.1.3">Address Validation Token Integrity</a>
</li>
</ul><li>8.2.   <a href="#rfc.section.8.2">Path Validation</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Initiating Path Validation</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">Path Validation Responses</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">Successful Path Validation</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">Failed Path Validation</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Connection Migration</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Probing a New Path</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Initiating Connection Migration</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Responding to Connection Migration</a>
</li>
<ul><li>9.3.1.   <a href="#rfc.section.9.3.1">Peer Address Spoofing</a>
</li>
<li>9.3.2.   <a href="#rfc.section.9.3.2">On-Path Address Spoofing</a>
</li>
<li>9.3.3.   <a href="#rfc.section.9.3.3">Off-Path Packet Forwarding</a>
</li>
</ul><li>9.4.   <a href="#rfc.section.9.4">Loss Detection and Congestion Control</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Privacy Implications of Connection Migration</a>
</li>
<li>9.6.   <a href="#rfc.section.9.6">Server&#8217;s Preferred Address</a>
</li>
<ul><li>9.6.1.   <a href="#rfc.section.9.6.1">Communicating A Preferred Address</a>
</li>
<li>9.6.2.   <a href="#rfc.section.9.6.2">Responding to Connection Migration</a>
</li>
<li>9.6.3.   <a href="#rfc.section.9.6.3">Interaction of Client Migration and Preferred Address</a>
</li>
</ul><li>9.7.   <a href="#rfc.section.9.7">Use of IPv6 Flow-Label and Migration</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Connection Termination</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Closing and Draining Connection States</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Idle Timeout</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Immediate Close</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Stateless Reset</a>
</li>
<ul><li>10.4.1.   <a href="#rfc.section.10.4.1">Detecting a Stateless Reset</a>
</li>
<li>10.4.2.   <a href="#rfc.section.10.4.2">Calculating a Stateless Reset Token</a>
</li>
<li>10.4.3.   <a href="#rfc.section.10.4.3">Looping</a>
</li>
</ul></ul><li>11.   <a href="#rfc.section.11">Error Handling</a>
</li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Connection Errors</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">Stream Errors</a>
</li>
</ul><li>12.   <a href="#rfc.section.12">Packets and Frames</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Protected Packets</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Coalescing Packets</a>
</li>
<li>12.3.   <a href="#rfc.section.12.3">Packet Numbers</a>
</li>
<li>12.4.   <a href="#rfc.section.12.4">Frames and Frame Types</a>
</li>
</ul><li>13.   <a href="#rfc.section.13">Packetization and Reliability</a>
</li>
<ul><li>13.1.   <a href="#rfc.section.13.1">Packet Processing and Acknowledgment</a>
</li>
<ul><li>13.1.1.   <a href="#rfc.section.13.1.1">Sending ACK Frames</a>
</li>
<li>13.1.2.   <a href="#rfc.section.13.1.2">ACK Frames and Packet Protection</a>
</li>
</ul><li>13.2.   <a href="#rfc.section.13.2">Retransmission of Information</a>
</li>
<li>13.3.   <a href="#rfc.section.13.3">Explicit Congestion Notification</a>
</li>
<ul><li>13.3.1.   <a href="#rfc.section.13.3.1">ECN Counts</a>
</li>
<li>13.3.2.   <a href="#rfc.section.13.3.2">ECN Verification</a>
</li>
</ul></ul><li>14.   <a href="#rfc.section.14">Packet Size</a>
</li>
<ul><li>14.1.   <a href="#rfc.section.14.1">Path Maximum Transmission Unit (PMTU)</a>
</li>
<li>14.2.   <a href="#rfc.section.14.2">ICMP Packet Too Big Messages</a>
</li>
<li>14.3.   <a href="#rfc.section.14.3">Datagram Packetization Layer PMTU Discovery</a>
</li>
</ul><li>15.   <a href="#rfc.section.15">Versions</a>
</li>
<li>16.   <a href="#rfc.section.16">Variable-Length Integer Encoding</a>
</li>
<li>17.   <a href="#rfc.section.17">Packet Formats</a>
</li>
<ul><li>17.1.   <a href="#rfc.section.17.1">Packet Number Encoding and Decoding</a>
</li>
<li>17.2.   <a href="#rfc.section.17.2">Long Header Packets</a>
</li>
<ul><li>17.2.1.   <a href="#rfc.section.17.2.1">Version Negotiation Packet</a>
</li>
<li>17.2.2.   <a href="#rfc.section.17.2.2">Initial Packet</a>
</li>
<li>17.2.3.   <a href="#rfc.section.17.2.3">0-RTT</a>
</li>
<li>17.2.4.   <a href="#rfc.section.17.2.4">Handshake Packet</a>
</li>
<li>17.2.5.   <a href="#rfc.section.17.2.5">Retry Packet</a>
</li>
</ul><li>17.3.   <a href="#rfc.section.17.3">Short Header Packets</a>
</li>
<ul><li>17.3.1.   <a href="#rfc.section.17.3.1">Latency Spin Bit</a>
</li>
</ul></ul><li>18.   <a href="#rfc.section.18">Transport Parameter Encoding</a>
</li>
<ul><li>18.1.   <a href="#rfc.section.18.1">Transport Parameter Definitions</a>
</li>
</ul><li>19.   <a href="#rfc.section.19">Frame Types and Formats</a>
</li>
<ul><li>19.1.   <a href="#rfc.section.19.1">PADDING Frame</a>
</li>
<li>19.2.   <a href="#rfc.section.19.2">PING Frame</a>
</li>
<li>19.3.   <a href="#rfc.section.19.3">ACK Frames</a>
</li>
<ul><li>19.3.1.   <a href="#rfc.section.19.3.1">ACK Ranges</a>
</li>
<li>19.3.2.   <a href="#rfc.section.19.3.2">ECN Counts</a>
</li>
</ul><li>19.4.   <a href="#rfc.section.19.4">RESET_STREAM Frame</a>
</li>
<li>19.5.   <a href="#rfc.section.19.5">STOP_SENDING Frame</a>
</li>
<li>19.6.   <a href="#rfc.section.19.6">CRYPTO Frame</a>
</li>
<li>19.7.   <a href="#rfc.section.19.7">NEW_TOKEN Frame</a>
</li>
<li>19.8.   <a href="#rfc.section.19.8">STREAM Frames</a>
</li>
<li>19.9.   <a href="#rfc.section.19.9">MAX_DATA Frame</a>
</li>
<li>19.10.   <a href="#rfc.section.19.10">MAX_STREAM_DATA Frame</a>
</li>
<li>19.11.   <a href="#rfc.section.19.11">MAX_STREAMS Frames</a>
</li>
<li>19.12.   <a href="#rfc.section.19.12">DATA_BLOCKED Frame</a>
</li>
<li>19.13.   <a href="#rfc.section.19.13">STREAM_DATA_BLOCKED Frame</a>
</li>
<li>19.14.   <a href="#rfc.section.19.14">STREAMS_BLOCKED Frames</a>
</li>
<li>19.15.   <a href="#rfc.section.19.15">NEW_CONNECTION_ID Frame</a>
</li>
<li>19.16.   <a href="#rfc.section.19.16">RETIRE_CONNECTION_ID Frame</a>
</li>
<li>19.17.   <a href="#rfc.section.19.17">PATH_CHALLENGE Frame</a>
</li>
<li>19.18.   <a href="#rfc.section.19.18">PATH_RESPONSE Frame</a>
</li>
<li>19.19.   <a href="#rfc.section.19.19">CONNECTION_CLOSE Frames</a>
</li>
<li>19.20.   <a href="#rfc.section.19.20">Extension Frames</a>
</li>
</ul><li>20.   <a href="#rfc.section.20">Transport Error Codes</a>
</li>
<ul><li>20.1.   <a href="#rfc.section.20.1">Application Protocol Error Codes</a>
</li>
</ul><li>21.   <a href="#rfc.section.21">Security Considerations</a>
</li>
<ul><li>21.1.   <a href="#rfc.section.21.1">Handshake Denial of Service</a>
</li>
<li>21.2.   <a href="#rfc.section.21.2">Amplification Attack</a>
</li>
<li>21.3.   <a href="#rfc.section.21.3">Optimistic ACK Attack</a>
</li>
<li>21.4.   <a href="#rfc.section.21.4">Slowloris Attacks</a>
</li>
<li>21.5.   <a href="#rfc.section.21.5">Stream Fragmentation and Reassembly Attacks</a>
</li>
<li>21.6.   <a href="#rfc.section.21.6">Stream Commitment Attack</a>
</li>
<li>21.7.   <a href="#rfc.section.21.7">Explicit Congestion Notification Attacks</a>
</li>
<li>21.8.   <a href="#rfc.section.21.8">Stateless Reset Oracle</a>
</li>
<li>21.9.   <a href="#rfc.section.21.9">Version Downgrade</a>
</li>
</ul><li>22.   <a href="#rfc.section.22">IANA Considerations</a>
</li>
<ul><li>22.1.   <a href="#rfc.section.22.1">QUIC Transport Parameter Registry</a>
</li>
<li>22.2.   <a href="#rfc.section.22.2">QUIC Frame Type Registry</a>
</li>
<li>22.3.   <a href="#rfc.section.22.3">QUIC Transport Error Codes Registry</a>
</li>
</ul><li>23.   <a href="#rfc.references">References</a>
</li>
<ul><li>23.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>23.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Sample Packet Number Decoding Algorithm</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Change Log</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Since draft-ietf-quic-transport-19</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Since draft-ietf-quic-transport-18</a>
</li>
<li>B.3.   <a href="#rfc.appendix.B.3">Since draft-ietf-quic-transport-17</a>
</li>
<li>B.4.   <a href="#rfc.appendix.B.4">Since draft-ietf-quic-transport-16</a>
</li>
<li>B.5.   <a href="#rfc.appendix.B.5">Since draft-ietf-quic-transport-15</a>
</li>
<li>B.6.   <a href="#rfc.appendix.B.6">Since draft-ietf-quic-transport-14</a>
</li>
<li>B.7.   <a href="#rfc.appendix.B.7">Since draft-ietf-quic-transport-13</a>
</li>
<li>B.8.   <a href="#rfc.appendix.B.8">Since draft-ietf-quic-transport-12</a>
</li>
<li>B.9.   <a href="#rfc.appendix.B.9">Since draft-ietf-quic-transport-11</a>
</li>
<li>B.10.   <a href="#rfc.appendix.B.10">Since draft-ietf-quic-transport-10</a>
</li>
<li>B.11.   <a href="#rfc.appendix.B.11">Since draft-ietf-quic-transport-09</a>
</li>
<li>B.12.   <a href="#rfc.appendix.B.12">Since draft-ietf-quic-transport-08</a>
</li>
<li>B.13.   <a href="#rfc.appendix.B.13">Since draft-ietf-quic-transport-07</a>
</li>
<li>B.14.   <a href="#rfc.appendix.B.14">Since draft-ietf-quic-transport-06</a>
</li>
<li>B.15.   <a href="#rfc.appendix.B.15">Since draft-ietf-quic-transport-05</a>
</li>
<li>B.16.   <a href="#rfc.appendix.B.16">Since draft-ietf-quic-transport-04</a>
</li>
<li>B.17.   <a href="#rfc.appendix.B.17">Since draft-ietf-quic-transport-03</a>
</li>
<li>B.18.   <a href="#rfc.appendix.B.18">Since draft-ietf-quic-transport-02</a>
</li>
<li>B.19.   <a href="#rfc.appendix.B.19">Since draft-ietf-quic-transport-01</a>
</li>
<li>B.20.   <a href="#rfc.appendix.B.20">Since draft-ietf-quic-transport-00</a>
</li>
<li>B.21.   <a href="#rfc.appendix.B.21">Since draft-hamilton-quic-transport-protocol-01</a>
</li>
</ul><li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.contributors">Contributors</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">QUIC is a multiplexed and secure general-purpose transport protocol that provides:</p>
<p></p>

<ul>
<li>Stream multiplexing</li>
<li>Stream and connection-level flow control</li>
<li>Low-latency connection establishment</li>
<li>Connection migration and resilience to NAT rebinding</li>
<li>Authenticated and encrypted header and payload</li>
</ul>
<p id="rfc.section.1.p.3">QUIC uses UDP as a substrate to avoid requiring changes to legacy client operating systems and middleboxes.  QUIC authenticates all of its headers and encrypts most of the data it exchanges, including its signaling, to avoid incurring a dependency on middleboxes.</p>
<h2 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#document-structure" id="document-structure">Document Structure</a>
</h2>
<p id="rfc.section.1.1.p.1">This document describes the core QUIC protocol and is structured as follows.</p>
<p></p>

<ul>
<li>Streams are the basic service abstraction that QUIC provides.  <ul>
<li>
<a href="#streams" class="xref">Section 2</a> describes core concepts related to streams,</li>
<li>
<a href="#stream-states" class="xref">Section 3</a> provides a reference model for stream states, and</li>
<li>
<a href="#flow-control" class="xref">Section 4</a> outlines the operation of flow control.</li>
</ul>
</li>
<li>Connections are the context in which QUIC endpoints communicate.  <ul>
<li>
<a href="#connections" class="xref">Section 5</a> describes core concepts related to connections,</li>
<li>
<a href="#version-negotiation" class="xref">Section 6</a> describes version negotiation,</li>
<li>
<a href="#handshake" class="xref">Section 7</a> details the process for establishing connections,</li>
<li>
<a href="#address-validation" class="xref">Section 8</a> specifies critical denial of service mitigation mechanisms,</li>
<li>
<a href="#migration" class="xref">Section 9</a> describes how endpoints migrate a connection to a new network path,</li>
<li>
<a href="#termination" class="xref">Section 10</a> lists the options for terminating an open connection, and</li>
<li>
<a href="#error-handling" class="xref">Section 11</a> provides general guidance for error handling.</li>
</ul>
</li>
<li>Packets and frames are the basic unit used by QUIC to communicate.  <ul>
<li>
<a href="#packets-frames" class="xref">Section 12</a> describes concepts related to packets and frames,</li>
<li>
<a href="#packetization" class="xref">Section 13</a> defines models for the transmission, retransmission, and acknowledgement of data, and</li>
<li>
<a href="#packet-size" class="xref">Section 14</a> specifies rules for managing the size of packets.</li>
</ul>
</li>
<li>Finally, encoding details of QUIC protocol elements are described in: <ul>
<li>
<a href="#versions" class="xref">Section 15</a> (Versions),</li>
<li>
<a href="#integer-encoding" class="xref">Section 16</a> (Integer Encoding),</li>
<li>
<a href="#packet-formats" class="xref">Section 17</a> (Packet Headers),</li>
<li>
<a href="#transport-parameter-encoding" class="xref">Section 18</a> (Transport Parameters),</li>
<li>
<a href="#frame-formats" class="xref">Section 19</a> (Frames), and</li>
<li>
<a href="#error-codes" class="xref">Section 20</a> (Errors).</li>
</ul>
</li>
</ul>
<p id="rfc.section.1.1.p.3">Accompanying documents describe QUIC&#8217;s loss detection and congestion control <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>, and the use of TLS for key negotiation <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<p id="rfc.section.1.1.p.4">This document defines QUIC version 1, which conforms to the protocol invariants in <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a>.</p>
<h2 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terms-and-definitions" id="terms-and-definitions">Terms and Definitions</a>
</h2>
<p id="rfc.section.1.2.p.1">The keywords &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.2.p.2">Commonly used terms in the document are described below.</p>
<p></p>

<dl>
<dt>QUIC:</dt>
<dd style="margin-left: 8">The transport protocol described by this document. QUIC is a name, not an acronym.</dd>
<dt>QUIC packet:</dt>
<dd style="margin-left: 8">The smallest unit of QUIC that can be encapsulated in a UDP datagram. Multiple QUIC packets can be encapsulated in a single UDP datagram.</dd>
<dt>Endpoint:</dt>
<dd style="margin-left: 8">An entity that can participate in a QUIC connection by generating, receiving, and processing QUIC packets. There are only two types of endpoint in QUIC: client and server.</dd>
<dt>Client:</dt>
<dd style="margin-left: 8">The endpoint initiating a QUIC connection.</dd>
<dt>Server:</dt>
<dd style="margin-left: 8">The endpoint accepting incoming QUIC connections.</dd>
<dt>Connection ID:</dt>
<dd style="margin-left: 8">An opaque identifier that is used to identify a QUIC connection at an endpoint.  Each endpoint sets a value for its peer to include in packets sent towards the endpoint.</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">A unidirectional or bidirectional channel of ordered bytes within a QUIC connection. A QUIC connection can carry multiple simultaneous streams.</dd>
<dt>Application:</dt>
<dd style="margin-left: 8">An entity that uses QUIC to send and receive data.</dd>
</dl>
<h2 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h2>
<p id="rfc.section.1.3.p.1">Packet and frame diagrams in this document use the format described in Section 3.1 of <a href="#RFC2360" class="xref">[RFC2360]</a>, with the following additional conventions:</p>
<p></p>

<dl>
<dt>[x]:</dt>
<dd style="margin-left: 8">Indicates that x is optional</dd>
<dt>x (A):</dt>
<dd style="margin-left: 8">Indicates that x is A bits long</dd>
<dt>x (A/B/C) &#8230;:</dt>
<dd style="margin-left: 8">Indicates that x is one of A, B, or C bits long</dd>
<dt>x (i) &#8230;:</dt>
<dd style="margin-left: 8">Indicates that x uses the variable-length encoding in <a href="#integer-encoding" class="xref">Section 16</a>
</dd>
<dt>x (*) &#8230;:</dt>
<dd style="margin-left: 8">Indicates that x is variable-length</dd>
</dl>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#streams" id="streams">Streams</a>
</h1>
<p id="rfc.section.2.p.1">Streams in QUIC provide a lightweight, ordered byte-stream abstraction to an application. An alternative view of QUIC streams is as an elastic &#8220;message&#8221; abstraction.</p>
<p id="rfc.section.2.p.2">Streams can be created by sending data. Other processes associated with stream management - ending, cancelling, and managing flow control - are all designed to impose minimal overheads. For instance, a single STREAM frame (<a href="#frame-stream" class="xref">Section 19.8</a>) can open, carry data for, and close a stream. Streams can also be long-lived and can last the entire duration of a connection.</p>
<p id="rfc.section.2.p.3">Streams can be created by either endpoint, can concurrently send data interleaved with other streams, and can be cancelled. QUIC does not provide any means of ensuring ordering between bytes on different streams.</p>
<p id="rfc.section.2.p.4">QUIC allows for an arbitrary number of streams to operate concurrently and for an arbitrary amount of data to be sent on any stream, subject to flow control constraints (see <a href="#flow-control" class="xref">Section 4</a>) and stream limits.</p>
<h2 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#stream-id" id="stream-id">Stream Types and Identifiers</a>
</h2>
<p id="rfc.section.2.1.p.1">Streams can be unidirectional or bidirectional.  Unidirectional streams carry data in one direction: from the initiator of the stream to its peer.  Bidirectional streams allow for data to be sent in both directions.</p>
<p id="rfc.section.2.1.p.2">Streams are identified within a connection by a numeric value, referred to as the stream ID.  Stream IDs are unique to a stream. A QUIC endpoint MUST NOT reuse a stream ID within a connection.  Stream IDs are encoded as variable-length integers (see <a href="#integer-encoding" class="xref">Section 16</a>).</p>
<p id="rfc.section.2.1.p.3">The least significant bit (0x1) of the stream ID identifies the initiator of the stream.  Client-initiated streams have even-numbered stream IDs (with the bit set to 0), and server-initiated streams have odd-numbered stream IDs (with the bit set to 1).</p>
<p id="rfc.section.2.1.p.4">The second least significant bit (0x2) of the stream ID distinguishes between bidirectional streams (with the bit set to 0) and unidirectional streams (with the bit set to 1).</p>
<p id="rfc.section.2.1.p.5">The least significant two bits from a stream ID therefore identify a stream as one of four types, as summarized in <a href="#stream-id-types" class="xref">Table 1</a>.</p>
<div id="rfc.table.1"></div>
<div id="stream-id-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Stream ID Types</caption>
<thead><tr>
<th class="left">Bits</th>
<th class="left">Stream Type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x0</td>
<td class="left">Client-Initiated, Bidirectional</td>
</tr>
<tr>
<td class="left">0x1</td>
<td class="left">Server-Initiated, Bidirectional</td>
</tr>
<tr>
<td class="left">0x2</td>
<td class="left">Client-Initiated, Unidirectional</td>
</tr>
<tr>
<td class="left">0x3</td>
<td class="left">Server-Initiated, Unidirectional</td>
</tr>
</tbody>
</table>
<p id="rfc.section.2.1.p.6">Within each type, streams are created with numerically increasing stream IDs.  A stream ID that is used out of order results in all streams of that type with lower-numbered stream IDs also being opened.</p>
<p id="rfc.section.2.1.p.7">The first bidirectional stream opened by the client has a stream ID of 0.</p>
<h2 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#sending-and-receiving-data" id="sending-and-receiving-data">Sending and Receiving Data</a>
</h2>
<p id="rfc.section.2.2.p.1">STREAM frames (<a href="#frame-stream" class="xref">Section 19.8</a>) encapsulate data sent by an application. An endpoint uses the Stream ID and Offset fields in STREAM frames to place data in order.</p>
<p id="rfc.section.2.2.p.2">Endpoints MUST be able to deliver stream data to an application as an ordered byte-stream.  Delivering an ordered byte-stream requires that an endpoint buffer any data that is received out of order, up to the advertised flow control limit.</p>
<p id="rfc.section.2.2.p.3">QUIC makes no specific allowances for delivery of stream data out of order. However, implementations MAY choose to offer the ability to deliver data out of order to a receiving application.</p>
<p id="rfc.section.2.2.p.4">An endpoint could receive data for a stream at the same stream offset multiple times.  Data that has already been received can be discarded.  The data at a given offset MUST NOT change if it is sent multiple times; an endpoint MAY treat receipt of different data at the same offset within a stream as a connection error of type PROTOCOL_VIOLATION.</p>
<p id="rfc.section.2.2.p.5">Streams are an ordered byte-stream abstraction with no other structure that is visible to QUIC. STREAM frame boundaries are not expected to be preserved when data is transmitted, when data is retransmitted after packet loss, or when data is delivered to the application at a receiver.</p>
<p id="rfc.section.2.2.p.6">An endpoint MUST NOT send data on any stream without ensuring that it is within the flow control limits set by its peer.  Flow control is described in detail in <a href="#flow-control" class="xref">Section 4</a>.</p>
<h2 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#stream-prioritization" id="stream-prioritization">Stream Prioritization</a>
</h2>
<p id="rfc.section.2.3.p.1">Stream multiplexing can have a significant effect on application performance if resources allocated to streams are correctly prioritized.</p>
<p id="rfc.section.2.3.p.2">QUIC does not provide frames for exchanging prioritization information.  Instead it relies on receiving priority information from the application that uses QUIC.</p>
<p id="rfc.section.2.3.p.3">A QUIC implementation SHOULD provide ways in which an application can indicate the relative priority of streams.  When deciding which streams to dedicate resources to, the implementation SHOULD use the information provided by the application.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#stream-states" id="stream-states">Stream States</a>
</h1>
<p id="rfc.section.3.p.1">This section describes streams in terms of their send or receive components.  Two state machines are described: one for the streams on which an endpoint transmits data (<a href="#stream-send-states" class="xref">Section 3.1</a>), and another for streams on which an endpoint receives data (<a href="#stream-recv-states" class="xref">Section 3.2</a>).</p>
<p id="rfc.section.3.p.2">Unidirectional streams use the applicable state machine directly.  Bidirectional streams use both state machines.  For the most part, the use of these state machines is the same whether the stream is unidirectional or bidirectional.  The conditions for opening a stream are slightly more complex for a bidirectional stream because the opening of either send or receive sides causes the stream to open in both directions.</p>
<p id="rfc.section.3.p.3">An endpoint MUST open streams of the same type in increasing order of stream ID.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">These states are largely informative.  This document uses stream states to describe rules for when and how different types of frames can be sent and the reactions that are expected when different types of frames are received.  Though these state machines are intended to be useful in implementing QUIC, these states aren&#8217;t intended to constrain implementations.  An implementation can define a different state machine as long as its behavior is consistent with an implementation that implements these states.</dd>
</dl>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#stream-send-states" id="stream-send-states">Sending Stream States</a>
</h2>
<p><a href="#fig-stream-send-states" class="xref">Figure 1</a> shows the states for the part of a stream that sends data to a peer.</p>
<div id="rfc.figure.1"></div>
<div id="fig-stream-send-states"></div>
<pre>
       o
       | Create Stream (Sending)
       | Peer Creates Bidirectional Stream
       v
   +-------+
   | Ready | Send RESET_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Send STREAM /             |
       |      STREAM_DATA_BLOCKED  |
       |                           |
       | Peer Creates              |
       |      Bidirectional Stream |
       v                           |
   +-------+                       |
   | Send  | Send RESET_STREAM     |
   |       |----------------------&gt;|
   +-------+                       |
       |                           |
       | Send STREAM + FIN         |
       v                           v
   +-------+                   +-------+
   | Data  | Send RESET_STREAM | Reset |
   | Sent  |------------------&gt;| Sent  |
   +-------+                   +-------+
       |                           |
       | Recv All ACKs             | Recv ACK
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Recvd |                   | Recvd |
   +-------+                   +-------+
</pre>
<p class="figure">Figure 1: States for Sending Parts of Streams</p>
<p id="rfc.section.3.1.p.2">The sending part of stream that the endpoint initiates (types 0 and 2 for clients, 1 and 3 for servers) is opened by the application.  The &#8220;Ready&#8221; state represents a newly created stream that is able to accept data from the application.  Stream data might be buffered in this state in preparation for sending.</p>
<p id="rfc.section.3.1.p.3">Sending the first STREAM or STREAM_DATA_BLOCKED frame causes a sending part of a stream to enter the &#8220;Send&#8221; state.  An implementation might choose to defer allocating a stream ID to a stream until it sends the first frame and enters this state, which can allow for better stream prioritization.</p>
<p id="rfc.section.3.1.p.4">The sending part of a bidirectional stream initiated by a peer (type 0 for a server, type 1 for a client) enters the &#8220;Ready&#8221; state then immediately transitions to the &#8220;Send&#8221; state if the receiving part enters the &#8220;Recv&#8221; state (<a href="#stream-recv-states" class="xref">Section 3.2</a>).</p>
<p id="rfc.section.3.1.p.5">In the &#8220;Send&#8221; state, an endpoint transmits - and retransmits as necessary - stream data in STREAM frames.  The endpoint respects the flow control limits set by its peer, and continues to accept and process MAX_STREAM_DATA frames.  An endpoint in the &#8220;Send&#8221; state generates STREAM_DATA_BLOCKED frames if it is blocked from sending by stream or connection flow control limits <a href="#data-flow-control" class="xref">Section 4.1</a>.</p>
<p id="rfc.section.3.1.p.6">After the application indicates that all stream data has been sent and a STREAM frame containing the FIN bit is sent, the sending part of the stream enters the &#8220;Data Sent&#8221; state.  From this state, the endpoint only retransmits stream data as necessary.  The endpoint does not need to check flow control limits or send STREAM_DATA_BLOCKED frames for a stream in this state.  MAX_STREAM_DATA frames might be received until the peer receives the final stream offset. The endpoint can safely ignore any MAX_STREAM_DATA frames it receives from its peer for a stream in this state.</p>
<p id="rfc.section.3.1.p.7">Once all stream data has been successfully acknowledged, the sending part of the stream enters the &#8220;Data Recvd&#8221; state, which is a terminal state.</p>
<p id="rfc.section.3.1.p.8">From any of the &#8220;Ready&#8221;, &#8220;Send&#8221;, or &#8220;Data Sent&#8221; states, an application can signal that it wishes to abandon transmission of stream data. Alternatively, an endpoint might receive a STOP_SENDING frame from its peer.  In either case, the endpoint sends a RESET_STREAM frame, which causes the stream to enter the &#8220;Reset Sent&#8221; state.</p>
<p id="rfc.section.3.1.p.9">An endpoint MAY send a RESET_STREAM as the first frame that mentions a stream; this causes the sending part of that stream to open and then immediately transition to the &#8220;Reset Sent&#8221; state.</p>
<p id="rfc.section.3.1.p.10">Once a packet containing a RESET_STREAM has been acknowledged, the sending part of the stream enters the &#8220;Reset Recvd&#8221; state, which is a terminal state.</p>
<h2 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#stream-recv-states" id="stream-recv-states">Receiving Stream States</a>
</h2>
<p><a href="#fig-stream-recv-states" class="xref">Figure 2</a> shows the states for the part of a stream that receives data from a peer.  The states for a receiving part of a stream mirror only some of the states of the sending part of the stream at the peer.  The receiving part of a stream does not track states on the sending part that cannot be observed, such as the &#8220;Ready&#8221; state.  Instead, the receiving part of a stream tracks the delivery of data to the application, some of which cannot be observed by the sender.</p>
<div id="rfc.figure.2"></div>
<div id="fig-stream-recv-states"></div>
<pre>
       o
       | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
       | Create Bidirectional Stream (Sending)
       | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
       | Create Higher-Numbered Stream
       v
   +-------+
   | Recv  | Recv RESET_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Recv STREAM + FIN         |
       v                           |
   +-------+                       |
   | Size  | Recv RESET_STREAM     |
   | Known |----------------------&gt;|
   +-------+                       |
       |                           |
       | Recv All Data             |
       v                           v
   +-------+ Recv RESET_STREAM +-------+
   | Data  |--- (optional) ---&gt;| Reset |
   | Recvd |  Recv All Data    | Recvd |
   +-------+&lt;-- (optional) ----+-------+
       |                           |
       | App Read All Data         | App Read RST
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Read  |                   | Read  |
   +-------+                   +-------+
</pre>
<p class="figure">Figure 2: States for Receiving Parts of Streams</p>
<p id="rfc.section.3.2.p.2">The receiving part of a stream initiated by a peer (types 1 and 3 for a client, or 0 and 2 for a server) is created when the first STREAM, STREAM_DATA_BLOCKED, or RESET_STREAM is received for that stream.  For bidirectional streams initiated by a peer, receipt of a MAX_STREAM_DATA or STOP_SENDING frame for the sending part of the stream also creates the receiving part.  The initial state for the receiving part of stream is &#8220;Recv&#8221;.</p>
<p id="rfc.section.3.2.p.3">The receiving part of a stream enters the &#8220;Recv&#8221; state when the sending part of a bidirectional stream initiated by the endpoint (type 0 for a client, type 1 for a server) enters the &#8220;Ready&#8221; state.</p>
<p id="rfc.section.3.2.p.4">An endpoint opens a bidirectional stream when a MAX_STREAM_DATA or STOP_SENDING frame is received from the peer for that stream.  Receiving a MAX_STREAM_DATA frame for an unopened stream indicates that the remote peer has opened the stream and is providing flow control credit.  Receiving a STOP_SENDING frame for an unopened stream indicates that the remote peer no longer wishes to receive data on this stream.  Either frame might arrive before a STREAM or STREAM_DATA_BLOCKED frame if packets are lost or reordered.</p>
<p id="rfc.section.3.2.p.5">Before creating a stream, all streams of the same type with lower-numbered stream IDs MUST be created.  This ensures that the creation order for streams is consistent on both endpoints.</p>
<p id="rfc.section.3.2.p.6">In the &#8220;Recv&#8221; state, the endpoint receives STREAM and STREAM_DATA_BLOCKED frames.  Incoming data is buffered and can be reassembled into the correct order for delivery to the application.  As data is consumed by the application and buffer space becomes available, the endpoint sends MAX_STREAM_DATA frames to allow the peer to send more data.</p>
<p id="rfc.section.3.2.p.7">When a STREAM frame with a FIN bit is received, the final size of the stream is known (see <a href="#final-size" class="xref">Section 4.4</a>).  The receiving part of the stream then enters the &#8220;Size Known&#8221; state.  In this state, the endpoint no longer needs to send MAX_STREAM_DATA frames, it only receives any retransmissions of stream data.</p>
<p id="rfc.section.3.2.p.8">Once all data for the stream has been received, the receiving part enters the &#8220;Data Recvd&#8221; state.  This might happen as a result of receiving the same STREAM frame that causes the transition to &#8220;Size Known&#8221;.  In this state, the endpoint has all stream data.  Any STREAM or STREAM_DATA_BLOCKED frames it receives for the stream can be discarded.</p>
<p id="rfc.section.3.2.p.9">The &#8220;Data Recvd&#8221; state persists until stream data has been delivered to the application.  Once stream data has been delivered, the stream enters the &#8220;Data Read&#8221; state, which is a terminal state.</p>
<p id="rfc.section.3.2.p.10">Receiving a RESET_STREAM frame in the &#8220;Recv&#8221; or &#8220;Size Known&#8221; states causes the stream to enter the &#8220;Reset Recvd&#8221; state.  This might cause the delivery of stream data to the application to be interrupted.</p>
<p id="rfc.section.3.2.p.11">It is possible that all stream data is received when a RESET_STREAM is received (that is, from the &#8220;Data Recvd&#8221; state).  Similarly, it is possible for remaining stream data to arrive after receiving a RESET_STREAM frame (the &#8220;Reset Recvd&#8221; state).  An implementation is free to manage this situation as it chooses.</p>
<p id="rfc.section.3.2.p.12">Sending RESET_STREAM means that an endpoint cannot guarantee delivery of stream data; however there is no requirement that stream data not be delivered if a RESET_STREAM is received.  An implementation MAY interrupt delivery of stream data, discard any data that was not consumed, and signal the receipt of the RESET_STREAM.  A RESET_STREAM signal might be suppressed or withheld if stream data is completely received and is buffered to be read by the application.  If the RESET_STREAM is suppressed, the receiving part of the stream remains in &#8220;Data Recvd&#8221;.</p>
<p id="rfc.section.3.2.p.13">Once the application has been delivered the signal indicating that the stream was reset, the receiving part of the stream transitions to the &#8220;Reset Read&#8221; state, which is a terminal state.</p>
<h2 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#permitted-frame-types" id="permitted-frame-types">Permitted Frame Types</a>
</h2>
<p id="rfc.section.3.3.p.1">The sender of a stream sends just three frame types that affect the state of a stream at either sender or receiver: STREAM (<a href="#frame-stream" class="xref">Section 19.8</a>), STREAM_DATA_BLOCKED (<a href="#frame-stream-data-blocked" class="xref">Section 19.13</a>), and RESET_STREAM (<a href="#frame-reset-stream" class="xref">Section 19.4</a>).</p>
<p id="rfc.section.3.3.p.2">A sender MUST NOT send any of these frames from a terminal state (&#8220;Data Recvd&#8221; or &#8220;Reset Recvd&#8221;).  A sender MUST NOT send STREAM or STREAM_DATA_BLOCKED after sending a RESET_STREAM; that is, in the terminal states and in the &#8220;Reset Sent&#8221; state.  A receiver could receive any of these three frames in any state, due to the possibility of delayed delivery of packets carrying them.</p>
<p id="rfc.section.3.3.p.3">The receiver of a stream sends MAX_STREAM_DATA (<a href="#frame-max-stream-data" class="xref">Section 19.10</a>) and STOP_SENDING frames (<a href="#frame-stop-sending" class="xref">Section 19.5</a>).</p>
<p id="rfc.section.3.3.p.4">The receiver only sends MAX_STREAM_DATA in the &#8220;Recv&#8221; state.  A receiver can send STOP_SENDING in any state where it has not received a RESET_STREAM frame; that is states other than &#8220;Reset Recvd&#8221; or &#8220;Reset Read&#8221;.  However there is little value in sending a STOP_SENDING frame in the &#8220;Data Recvd&#8221; state, since all stream data has been received.  A sender could receive either of these two frames in any state as a result of delayed delivery of packets.</p>
<h2 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#stream-bidi-states" id="stream-bidi-states">Bidirectional Stream States</a>
</h2>
<p id="rfc.section.3.4.p.1">A bidirectional stream is composed of sending and receiving parts.  Implementations may represent states of the bidirectional stream as composites of sending and receiving stream states.  The simplest model presents the stream as &#8220;open&#8221; when either sending or receiving parts are in a non-terminal state and &#8220;closed&#8221; when both sending and receiving streams are in terminal states.</p>
<p><a href="#stream-bidi-mapping" class="xref">Table 2</a> shows a more complex mapping of bidirectional stream states that loosely correspond to the stream states in HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a>.  This shows that multiple states on sending or receiving parts of streams are mapped to the same composite state.  Note that this is just one possibility for such a mapping; this mapping requires that data is acknowledged before the transition to a &#8220;closed&#8221; or &#8220;half-closed&#8221; state.</p>
<div id="rfc.table.2"></div>
<div id="stream-bidi-mapping"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Possible Mapping of Stream States to HTTP/2</caption>
<thead><tr>
<th class="left">Sending Part</th>
<th class="left">Receiving Part</th>
<th class="left">Composite State</th>
</tr></thead>
<tbody>
<tr>
<td class="left">No Stream/Ready</td>
<td class="left">No Stream/Recv *1</td>
<td class="left">idle</td>
</tr>
<tr>
<td class="left">Ready/Send/Data Sent</td>
<td class="left">Recv/Size Known</td>
<td class="left">open</td>
</tr>
<tr>
<td class="left">Ready/Send/Data Sent</td>
<td class="left">Data Recvd/Data Read</td>
<td class="left">half-closed (remote)</td>
</tr>
<tr>
<td class="left">Ready/Send/Data Sent</td>
<td class="left">Reset Recvd/Reset Read</td>
<td class="left">half-closed (remote)</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Recv/Size Known</td>
<td class="left">half-closed (local)</td>
</tr>
<tr>
<td class="left">Reset Sent/Reset Recvd</td>
<td class="left">Recv/Size Known</td>
<td class="left">half-closed (local)</td>
</tr>
<tr>
<td class="left">Reset Sent/Reset Recvd</td>
<td class="left">Data Recvd/Data Read</td>
<td class="left">closed</td>
</tr>
<tr>
<td class="left">Reset Sent/Reset Recvd</td>
<td class="left">Reset Recvd/Reset Read</td>
<td class="left">closed</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Data Recvd/Data Read</td>
<td class="left">closed</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Reset Recvd/Reset Read</td>
<td class="left">closed</td>
</tr>
</tbody>
</table>
<p></p>

<dl>
<dt>Note (*1):</dt>
<dd style="margin-left: 8">A stream is considered &#8220;idle&#8221; if it has not yet been created, or if the receiving part of the stream is in the &#8220;Recv&#8221; state without yet having received any frames.</dd>
</dl>
<h2 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#solicited-state-transitions" id="solicited-state-transitions">Solicited State Transitions</a>
</h2>
<p id="rfc.section.3.5.p.1">If an endpoint is no longer interested in the data it is receiving on a stream, it MAY send a STOP_SENDING frame identifying that stream to prompt closure of the stream in the opposite direction.  This typically indicates that the receiving application is no longer reading data it receives from the stream, but it is not a guarantee that incoming data will be ignored.</p>
<p id="rfc.section.3.5.p.2">STREAM frames received after sending STOP_SENDING are still counted toward connection and stream flow control, even though these frames will be discarded upon receipt.</p>
<p id="rfc.section.3.5.p.3">A STOP_SENDING frame requests that the receiving endpoint send a RESET_STREAM frame.  An endpoint that receives a STOP_SENDING frame MUST send a RESET_STREAM frame if the stream is in the Ready or Send state. If the stream is in the Data Sent state and any outstanding data is declared lost, an endpoint SHOULD send a RESET_STREAM frame in lieu of a retransmission.</p>
<p id="rfc.section.3.5.p.4">An endpoint SHOULD copy the error code from the STOP_SENDING frame to the RESET_STREAM frame it sends, but MAY use any application error code.  The endpoint that sends a STOP_SENDING frame MAY ignore the error code carried in any RESET_STREAM frame it receives.</p>
<p id="rfc.section.3.5.p.5">If the STOP_SENDING frame is received on a stream that is already in the &#8220;Data Sent&#8221; state, an endpoint that wishes to cease retransmission of previously-sent STREAM frames on that stream MUST first send a RESET_STREAM frame.</p>
<p id="rfc.section.3.5.p.6">STOP_SENDING SHOULD only be sent for a stream that has not been reset by the peer. STOP_SENDING is most useful for streams in the &#8220;Recv&#8221; or &#8220;Size Known&#8221; states.</p>
<p id="rfc.section.3.5.p.7">An endpoint is expected to send another STOP_SENDING frame if a packet containing a previous STOP_SENDING is lost.  However, once either all stream data or a RESET_STREAM frame has been received for the stream - that is, the stream is in any state other than &#8220;Recv&#8221; or &#8220;Size Known&#8221; - sending a STOP_SENDING frame is unnecessary.</p>
<p id="rfc.section.3.5.p.8">An endpoint that wishes to terminate both directions of a bidirectional stream can terminate one direction by sending a RESET_STREAM, and it can encourage prompt termination in the opposite direction by sending a STOP_SENDING frame.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#flow-control" id="flow-control">Flow Control</a>
</h1>
<p id="rfc.section.4.p.1">It is necessary to limit the amount of data that a receiver could buffer, to prevent a fast sender from overwhelming a slow receiver, or to prevent a malicious sender from consuming a large amount of memory at a receiver.  To enable a receiver to limit memory commitment to a connection and to apply back pressure on the sender, streams are flow controlled both individually and as an aggregate.  A QUIC receiver controls the maximum amount of data the sender can send on a stream at any time, as described in <a href="#data-flow-control" class="xref">Section 4.1</a> and <a href="#fc-credit" class="xref">Section 4.2</a></p>
<p id="rfc.section.4.p.2">Similarly, to limit concurrency within a connection, a QUIC endpoint controls the maximum cumulative number of streams that its peer can initiate, as described in <a href="#controlling-concurrency" class="xref">Section 4.5</a>.</p>
<p id="rfc.section.4.p.3">Data sent in CRYPTO frames is not flow controlled in the same way as stream data.  QUIC relies on the cryptographic protocol implementation to avoid excessive buffering of data, see <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.  The implementation SHOULD provide an interface to QUIC to tell it about its buffering limits so that there is not excessive buffering at multiple layers.</p>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#data-flow-control" id="data-flow-control">Data Flow Control</a>
</h2>
<p id="rfc.section.4.1.p.1">QUIC employs a credit-based flow-control scheme similar to that in HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a>, where a receiver advertises the number of bytes it is prepared to receive on a given stream and for the entire connection.  This leads to two levels of data flow control in QUIC:</p>
<p></p>

<ul>
<li>Stream flow control, which prevents a single stream from consuming the entire receive buffer for a connection by limiting the amount of data that can be sent on any stream.</li>
<li>Connection flow control, which prevents senders from exceeding a receiver&#8217;s buffer capacity for the connection, by limiting the total bytes of stream data sent in STREAM frames on all streams.</li>
</ul>
<p id="rfc.section.4.1.p.3">A receiver sets initial credits for all streams by sending transport parameters during the handshake (<a href="#transport-parameters" class="xref">Section 7.3</a>).  A receiver sends MAX_STREAM_DATA (<a href="#frame-max-stream-data" class="xref">Section 19.10</a>) or MAX_DATA (<a href="#frame-max-data" class="xref">Section 19.9</a>) frames to the sender to advertise additional credit.</p>
<p id="rfc.section.4.1.p.4">A receiver advertises credit for a stream by sending a MAX_STREAM_DATA frame with the Stream ID field set appropriately.  A MAX_STREAM_DATA frame indicates the maximum absolute byte offset of a stream.  A receiver could use the current offset of data consumed to determine the flow control offset to be advertised.  A receiver MAY send MAX_STREAM_DATA frames in multiple packets in order to make sure that the sender receives an update before running out of flow control credit, even if one of the packets is lost.</p>
<p id="rfc.section.4.1.p.5">A receiver advertises credit for a connection by sending a MAX_DATA frame, which indicates the maximum of the sum of the absolute byte offsets of all streams.  A receiver maintains a cumulative sum of bytes received on all streams, which is used to check for flow control violations. A receiver might use a sum of bytes consumed on all streams to determine the maximum data limit to be advertised.</p>
<p id="rfc.section.4.1.p.6">A receiver can advertise a larger offset by sending MAX_STREAM_DATA or MAX_DATA frames at any time during the connection.  A receiver cannot renege on an advertisement however.  That is, once a receiver advertises an offset, it MAY advertise a smaller offset, but this has no effect.</p>
<p id="rfc.section.4.1.p.7">A receiver MUST close the connection with a FLOW_CONTROL_ERROR error (<a href="#error-handling" class="xref">Section 11</a>) if the sender violates the advertised connection or stream data limits.</p>
<p id="rfc.section.4.1.p.8">A sender MUST ignore any MAX_STREAM_DATA or MAX_DATA frames that do not increase flow control limits.</p>
<p id="rfc.section.4.1.p.9">If a sender runs out of flow control credit, it will be unable to send new data and is considered blocked.  A sender SHOULD send STREAM_DATA_BLOCKED or DATA_BLOCKED frames to indicate it has data to write but is blocked by flow control limits.  These frames are expected to be sent infrequently in common cases, but they are considered useful for debugging and monitoring purposes.</p>
<p id="rfc.section.4.1.p.10">A sender sends a single STREAM_DATA_BLOCKED or DATA_BLOCKED frame only once when it reaches a data limit.  A sender SHOULD NOT send multiple STREAM_DATA_BLOCKED or DATA_BLOCKED frames for the same data limit, unless the original frame is determined to be lost.  Another STREAM_DATA_BLOCKED or DATA_BLOCKED frame can be sent after the data limit is increased.</p>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#fc-credit" id="fc-credit">Flow Credit Increments</a>
</h2>
<p id="rfc.section.4.2.p.1">This document leaves when and how many bytes to advertise in a MAX_STREAM_DATA or MAX_DATA frame to implementations, but offers a few considerations.  These frames contribute to connection overhead.  Therefore frequently sending frames with small changes is undesirable.  At the same time, larger increments to limits are necessary to avoid blocking if updates are less frequent, requiring larger resource commitments at the receiver.  Thus there is a trade-off between resource commitment and overhead when determining how large a limit is advertised.</p>
<p id="rfc.section.4.2.p.2">A receiver can use an autotuning mechanism to tune the frequency and amount of advertised additional credit based on a round-trip time estimate and the rate at which the receiving application consumes data, similar to common TCP implementations.  As an optimization, sending frames related to flow control only when there are other frames to send or when a peer is blocked ensures that flow control doesn&#8217;t cause extra packets to be sent.</p>
<p id="rfc.section.4.2.p.3">If a sender runs out of flow control credit, it will be unable to send new data and is considered blocked.  It is generally considered best to not let the sender become blocked.  To avoid blocking a sender, and to reasonably account for the possibility of loss, a receiver should send a MAX_DATA or MAX_STREAM_DATA frame at least two round trips before it expects the sender to get blocked.</p>
<p id="rfc.section.4.2.p.4">A receiver MUST NOT wait for a STREAM_DATA_BLOCKED or DATA_BLOCKED frame before sending MAX_STREAM_DATA or MAX_DATA, since doing so will mean that a sender will be blocked for at least an entire round trip, and potentially for longer if the peer chooses to not send STREAM_DATA_BLOCKED or DATA_BLOCKED frames.</p>
<h2 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#stream-cancellation" id="stream-cancellation">Handling Stream Cancellation</a>
</h2>
<p id="rfc.section.4.3.p.1">Endpoints need to eventually agree on the amount of flow control credit that has been consumed, to avoid either exceeding flow control limits or deadlocking.</p>
<p id="rfc.section.4.3.p.2">On receipt of a RESET_STREAM frame, an endpoint will tear down state for the matching stream and ignore further data arriving on that stream.  If a RESET_STREAM frame is reordered with stream data for the same stream, the receiver&#8217;s estimate of the number of bytes received on that stream can be lower than the sender&#8217;s estimate of the number sent.  As a result, the two endpoints could disagree on the number of bytes that count towards connection flow control.</p>
<p id="rfc.section.4.3.p.3">To remedy this issue, a RESET_STREAM frame (<a href="#frame-reset-stream" class="xref">Section 19.4</a>) includes the final size of data sent on the stream.  On receiving a RESET_STREAM frame, a receiver definitively knows how many bytes were sent on that stream before the RESET_STREAM frame, and the receiver MUST use the final size of the stream to account for all bytes sent on the stream in its connection level flow controller.</p>
<p id="rfc.section.4.3.p.4">RESET_STREAM terminates one direction of a stream abruptly.  For a bidirectional stream, RESET_STREAM has no effect on data flow in the opposite direction.  Both endpoints MUST maintain flow control state for the stream in the unterminated direction until that direction enters a terminal state, or until one of the endpoints sends CONNECTION_CLOSE.</p>
<h2 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#final-size" id="final-size">Stream Final Size</a>
</h2>
<p id="rfc.section.4.4.p.1">The final size is the amount of flow control credit that is consumed by a stream.  Assuming that every contiguous byte on the stream was sent once, the final size is the number of bytes sent.  More generally, this is one higher than the offset of the byte with the largest offset sent on the stream, or zero if no bytes were sent.</p>
<p id="rfc.section.4.4.p.2">For a stream that is reset, the final size is carried explicitly in a RESET_STREAM frame.  Otherwise, the final size is the offset plus the length of a STREAM frame marked with a FIN flag, or 0 in the case of incoming unidirectional streams.</p>
<p id="rfc.section.4.4.p.3">An endpoint will know the final size for a stream when the receiving part of the stream enters the &#8220;Size Known&#8221; or &#8220;Reset Recvd&#8221; state (<a href="#stream-states" class="xref">Section 3</a>).</p>
<p id="rfc.section.4.4.p.4">An endpoint MUST NOT send data on a stream at or beyond the final size.</p>
<p id="rfc.section.4.4.p.5">Once a final size for a stream is known, it cannot change.  If a RESET_STREAM or STREAM frame is received indicating a change in the final size for the stream, an endpoint SHOULD respond with a FINAL_SIZE_ERROR error (see <a href="#error-handling" class="xref">Section 11</a>).  A receiver SHOULD treat receipt of data at or beyond the final size as a FINAL_SIZE_ERROR error, even after a stream is closed.  Generating these errors is not mandatory, but only because requiring that an endpoint generate these errors also means that the endpoint needs to maintain the final size state for closed streams, which could mean a significant state commitment.</p>
<h2 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#controlling-concurrency" id="controlling-concurrency">Controlling Concurrency</a>
</h2>
<p id="rfc.section.4.5.p.1">An endpoint limits the cumulative number of incoming streams a peer can open.  Only streams with a stream ID less than (max_stream * 4 + initial_stream_id_for_type) can be opened (see <a href="#long-packet-types" class="xref">Table 5</a>).  Initial limits are set in the transport parameters (see <a href="#transport-parameter-definitions" class="xref">Section 18.1</a>) and subsequently limits are advertised using MAX_STREAMS frames (<a href="#frame-max-streams" class="xref">Section 19.11</a>). Separate limits apply to unidirectional and bidirectional streams.</p>
<p id="rfc.section.4.5.p.2">If a max_streams transport parameter or MAX_STREAMS frame is received with a value greater than 2^60, this would allow a maximum stream ID that cannot be expressed as a variable-length integer (see <a href="#integer-encoding" class="xref">Section 16</a>).  If either is received, the connection MUST be closed immediately with a connection error of type STREAM_LIMIT_ERROR (see <a href="#immediate-close" class="xref">Section 10.3</a>).</p>
<p id="rfc.section.4.5.p.3">Endpoints MUST NOT exceed the limit set by their peer.  An endpoint that receives a STREAM frame with a stream ID exceeding the limit it has sent MUST treat this as a stream error of type STREAM_LIMIT_ERROR (<a href="#error-handling" class="xref">Section 11</a>).</p>
<p id="rfc.section.4.5.p.4">A receiver cannot renege on an advertisement. That is, once a receiver advertises a stream limit using the MAX_STREAMS frame, advertising a smaller limit has no effect.  A receiver MUST ignore any MAX_STREAMS frame that does not increase the stream limit.</p>
<p id="rfc.section.4.5.p.5">As with stream and connection flow control, this document leaves when and how many streams to advertise to a peer via MAX_STREAMS to implementations.  Implementations might choose to increase limits as streams close to keep the number of streams available to peers roughly consistent.</p>
<p id="rfc.section.4.5.p.6">An endpoint that is unable to open a new stream due to the peer&#8217;s limits SHOULD send a STREAMS_BLOCKED frame (<a href="#frame-streams-blocked" class="xref">Section 19.14</a>).  This signal is considered useful for debugging. An endpoint MUST NOT wait to receive this signal before advertising additional credit, since doing so will mean that the peer will be blocked for at least an entire round trip, and potentially for longer if the peer chooses to not send STREAMS_BLOCKED frames.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#connections" id="connections">Connections</a>
</h1>
<p id="rfc.section.5.p.1">QUIC&#8217;s connection establishment combines version negotiation with the cryptographic and transport handshakes to reduce connection establishment latency, as described in <a href="#handshake" class="xref">Section 7</a>.  Once established, a connection may migrate to a different IP or port at either endpoint as described in <a href="#migration" class="xref">Section 9</a>.  Finally, a connection may be terminated by either endpoint, as described in <a href="#termination" class="xref">Section 10</a>.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#connection-id" id="connection-id">Connection ID</a>
</h2>
<p id="rfc.section.5.1.p.1">Each connection possesses a set of connection identifiers, or connection IDs, each of which can identify the connection.  Connection IDs are independently selected by endpoints; each endpoint selects the connection IDs that its peer uses.</p>
<p id="rfc.section.5.1.p.2">The primary function of a connection ID is to ensure that changes in addressing at lower protocol layers (UDP, IP) don&#8217;t cause packets for a QUIC connection to be delivered to the wrong endpoint.  Each endpoint selects connection IDs using an implementation-specific (and perhaps deployment-specific) method which will allow packets with that connection ID to be routed back to the endpoint and identified by the endpoint upon receipt.</p>
<p id="rfc.section.5.1.p.3">Connection IDs MUST NOT contain any information that can be used by an external observer to correlate them with other connection IDs for the same connection.  As a trivial example, this means the same connection ID MUST NOT be issued more than once on the same connection.</p>
<p id="rfc.section.5.1.p.4">Packets with long headers include Source Connection ID and Destination Connection ID fields.  These fields are used to set the connection IDs for new connections, see <a href="#negotiating-connection-ids" class="xref">Section 7.2</a> for details.</p>
<p id="rfc.section.5.1.p.5">Packets with short headers (<a href="#short-header" class="xref">Section 17.3</a>) only include the Destination Connection ID and omit the explicit length.  The length of the Destination Connection ID field is expected to be known to endpoints.  Endpoints using a load balancer that routes based on connection ID could agree with the load balancer on a fixed length for connection IDs, or agree on an encoding scheme.  A fixed portion could encode an explicit length, which allows the entire connection ID to vary in length and still be used by the load balancer.</p>
<p id="rfc.section.5.1.p.6">A Version Negotiation (<a href="#packet-version" class="xref">Section 17.2.1</a>) packet echoes the connection IDs selected by the client, both to ensure correct routing toward the client and to allow the client to validate that the packet is in response to an Initial packet.</p>
<p id="rfc.section.5.1.p.7">A zero-length connection ID MAY be used when the connection ID is not needed for routing and the address/port tuple of packets is sufficient to identify a connection. An endpoint whose peer has selected a zero-length connection ID MUST continue to use a zero-length connection ID for the lifetime of the connection and MUST NOT send packets from any other local address.</p>
<p id="rfc.section.5.1.p.8">When an endpoint has requested a non-zero-length connection ID, it needs to ensure that the peer has a supply of connection IDs from which to choose for packets sent to the endpoint.  These connection IDs are supplied by the endpoint using the NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).</p>
<h3 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#issue-cid" id="issue-cid">Issuing Connection IDs</a>
</h3>
<p id="rfc.section.5.1.1.p.1">Each Connection ID has an associated sequence number to assist in deduplicating messages.  The initial connection ID issued by an endpoint is sent in the Source Connection ID field of the long packet header (<a href="#long-header" class="xref">Section 17.2</a>) during the handshake.  The sequence number of the initial connection ID is 0.  If the preferred_address transport parameter is sent, the sequence number of the supplied connection ID is 1.</p>
<p id="rfc.section.5.1.1.p.2">Additional connection IDs are communicated to the peer using NEW_CONNECTION_ID frames (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).  The sequence number on each newly-issued connection ID MUST increase by 1. The connection ID randomly selected by the client in the Initial packet and any connection ID provided by a Retry packet are not assigned sequence numbers unless a server opts to retain them as its initial connection ID.</p>
<p id="rfc.section.5.1.1.p.3">When an endpoint issues a connection ID, it MUST accept packets that carry this connection ID for the duration of the connection or until its peer invalidates the connection ID via a RETIRE_CONNECTION_ID frame (<a href="#frame-retire-connection-id" class="xref">Section 19.16</a>).</p>
<p id="rfc.section.5.1.1.p.4">Endpoints store received connection IDs for future use.  An endpoint that receives excessive connection IDs MAY discard those it cannot store without sending a RETIRE_CONNECTION_ID frame.  An endpoint that issues connection IDs cannot expect its peer to store and use all issued connection IDs.</p>
<p id="rfc.section.5.1.1.p.5">An endpoint SHOULD ensure that its peer has a sufficient number of available and unused connection IDs.  While each endpoint independently chooses how many connection IDs to issue, endpoints SHOULD provide and maintain at least eight connection IDs.  The endpoint SHOULD do this by supplying a new connection ID when a connection ID is retired by its peer or when the endpoint receives a packet with a previously unused connection ID.  However, it MAY limit the frequency or the total number of connection IDs issued for each connection to avoid the risk of running out of connection IDs (see <a href="#reset-token" class="xref">Section 10.4.2</a>).</p>
<p id="rfc.section.5.1.1.p.6">An endpoint that initiates migration and requires non-zero-length connection IDs SHOULD ensure that the pool of connection IDs available to its peer allows the peer to use a new connection ID on migration, as the peer will close the connection if the pool is exhausted.</p>
<h3 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#retiring-cids" id="retiring-cids">Consuming and Retiring Connection IDs</a>
</h3>
<p id="rfc.section.5.1.2.p.1">An endpoint can change the connection ID it uses for a peer to another available one at any time during the connection.  An endpoint consumes connection IDs in response to a migrating peer, see <a href="#migration-linkability" class="xref">Section 9.5</a> for more.</p>
<p id="rfc.section.5.1.2.p.2">An endpoint maintains a set of connection IDs received from its peer, any of which it can use when sending packets.  When the endpoint wishes to remove a connection ID from use, it sends a RETIRE_CONNECTION_ID frame to its peer.  Sending a RETIRE_CONNECTION_ID frame indicates that the connection ID won&#8217;t be used again and requests that the peer replace it with a new connection ID using a NEW_CONNECTION_ID frame.</p>
<p id="rfc.section.5.1.2.p.3">As discussed in <a href="#migration-linkability" class="xref">Section 9.5</a>, each connection ID MUST be used on packets sent from only one local address.  An endpoint that migrates away from a local address SHOULD retire all connection IDs used on that address once it no longer plans to use that address.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#packet-handling" id="packet-handling">Matching Packets to Connections</a>
</h2>
<p id="rfc.section.5.2.p.1">Incoming packets are classified on receipt.  Packets can either be associated with an existing connection, or - for servers - potentially create a new connection.</p>
<p id="rfc.section.5.2.p.2">Hosts try to associate a packet with an existing connection. If the packet has a Destination Connection ID corresponding to an existing connection, QUIC processes that packet accordingly. Note that more than one connection ID can be associated with a connection; see <a href="#connection-id" class="xref">Section 5.1</a>.</p>
<p id="rfc.section.5.2.p.3">If the Destination Connection ID is zero length and the packet matches the address/port tuple of a connection where the host did not require connection IDs, QUIC processes the packet as part of that connection.  Endpoints SHOULD either reject connection attempts that use the same addresses as existing connections, or use a non-zero-length Destination Connection ID so that packets can be correctly attributed to connections.</p>
<p id="rfc.section.5.2.p.4">Endpoints can send a Stateless Reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) for any packets that cannot be attributed to an existing connection. A stateless reset allows a peer to more quickly identify when a connection becomes unusable.</p>
<p id="rfc.section.5.2.p.5">Packets that are matched to an existing connection are discarded if the packets are inconsistent with the state of that connection.  For example, packets are discarded if they indicate a different protocol version than that of the connection, or if the removal of packet protection is unsuccessful once the expected keys are available.</p>
<p id="rfc.section.5.2.p.6">Invalid packets without packet protection, such as Initial, Retry, or Version Negotiation, MAY be discarded.  An endpoint MUST generate a connection error if it commits changes to state before discovering an error.</p>
<h3 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#client-pkt-handling" id="client-pkt-handling">Client Packet Handling</a>
</h3>
<p id="rfc.section.5.2.1.p.1">Valid packets sent to clients always include a Destination Connection ID that matches a value the client selects.  Clients that choose to receive zero-length connection IDs can use the address/port tuple to identify a connection.  Packets that don&#8217;t match an existing connection are discarded.</p>
<p id="rfc.section.5.2.1.p.2">Due to packet reordering or loss, clients might receive packets for a connection that are encrypted with a key it has not yet computed. Clients MAY drop these packets, or MAY buffer them in anticipation of later packets that allow it to compute the key.</p>
<p id="rfc.section.5.2.1.p.3">If a client receives a packet that has an unsupported version, it MUST discard that packet.</p>
<h3 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#server-pkt-handling" id="server-pkt-handling">Server Packet Handling</a>
</h3>
<p id="rfc.section.5.2.2.p.1">If a server receives a packet that has an unsupported version, but the packet is sufficiently large to initiate a new connection for any version supported by the server, it SHOULD send a Version Negotiation packet as described in <a href="#send-vn" class="xref">Section 6.1</a>. Servers MAY rate control these packets to avoid storms of Version Negotiation packets.</p>
<p id="rfc.section.5.2.2.p.2">The first packet for an unsupported version can use different semantics and encodings for any version-specific field.  In particular, different packet protection keys might be used for different versions.  Servers that do not support a particular version are unlikely to be able to decrypt the payload of the packet.  Servers SHOULD NOT attempt to decode or decrypt a packet from an unknown version, but instead send a Version Negotiation packet, provided that the packet is sufficiently long.</p>
<p id="rfc.section.5.2.2.p.3">Servers MUST drop other packets that contain unsupported versions.</p>
<p id="rfc.section.5.2.2.p.4">Packets with a supported version, or no version field, are matched to a connection using the connection ID or - for packets with zero-length connection IDs - the address tuple.  If the packet doesn&#8217;t match an existing connection, the server continues below.</p>
<p id="rfc.section.5.2.2.p.5">If the packet is an Initial packet fully conforming with the specification, the server proceeds with the handshake (<a href="#handshake" class="xref">Section 7</a>). This commits the server to the version that the client selected.</p>
<p id="rfc.section.5.2.2.p.6">If a server isn&#8217;t currently accepting any new connections, it SHOULD send an Initial packet containing a CONNECTION_CLOSE frame with error code SERVER_BUSY.</p>
<p id="rfc.section.5.2.2.p.7">If the packet is a 0-RTT packet, the server MAY buffer a limited number of these packets in anticipation of a late-arriving Initial Packet. Clients are forbidden from sending Handshake packets prior to receiving a server response, so servers SHOULD ignore any such packets.</p>
<p id="rfc.section.5.2.2.p.8">Servers MUST drop incoming packets under all other circumstances.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#connection-lifecycle" id="connection-lifecycle">Life of a QUIC Connection</a>
</h2>
<p id="rfc.section.5.3.p.1">TBD.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#version-negotiation" id="version-negotiation">Version Negotiation</a>
</h1>
<p id="rfc.section.6.p.1">Version negotiation ensures that client and server agree to a QUIC version that is mutually supported. A server sends a Version Negotiation packet in response to each packet that might initiate a new connection, see <a href="#packet-handling" class="xref">Section 5.2</a> for details.</p>
<p id="rfc.section.6.p.2">The size of the first packet sent by a client will determine whether a server sends a Version Negotiation packet. Clients that support multiple QUIC versions SHOULD pad the first packet they send to the largest of the minimum packet sizes across all versions they support. This ensures that the server responds if there is a mutually supported version.</p>
<h2 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#send-vn" id="send-vn">Sending Version Negotiation Packets</a>
</h2>
<p id="rfc.section.6.1.p.1">If the version selected by the client is not acceptable to the server, the server responds with a Version Negotiation packet (see <a href="#packet-version" class="xref">Section 17.2.1</a>).  This includes a list of versions that the server will accept.  An endpoint MUST NOT send a Version Negotiation packet in response to receiving a Version Negotiation packet.</p>
<p id="rfc.section.6.1.p.2">This system allows a server to process packets with unsupported versions without retaining state.  Though either the Initial packet or the Version Negotiation packet that is sent in response could be lost, the client will send new packets until it successfully receives a response or it abandons the connection attempt.</p>
<p id="rfc.section.6.1.p.3">A server MAY limit the number of Version Negotiation packets it sends.  For instance, a server that is able to recognize packets as 0-RTT might choose not to send Version Negotiation packets in response to 0-RTT packets with the expectation that it will eventually receive an Initial packet.</p>
<h2 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#handle-vn" id="handle-vn">Handling Version Negotiation Packets</a>
</h2>
<p id="rfc.section.6.2.p.1">When a client receives a Version Negotiation packet, it MUST abandon the current connection attempt.  Version Negotiation packets are designed to allow future versions of QUIC to negotiate the version in use between endpoints.  Future versions of QUIC might change how implementations that support multiple versions of QUIC react to Version Negotiation packets when attempting to establish a connection using this version.  How to perform version negotiation is left as future work defined by future versions of QUIC.  In particular, that future work will need to ensure robustness against version downgrade attacks <a href="#version-downgrade" class="xref">Section 21.9</a>.</p>
<h3 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#version-negotiation-between-draft-versions" id="version-negotiation-between-draft-versions">Version Negotiation Between Draft Versions</a>
</h3>
<p id="rfc.section.6.2.1.p.1">[[RFC editor: please remove this section before publication.]]</p>
<p id="rfc.section.6.2.1.p.2">When a draft implementation receives a Version Negotiation packet, it MAY use it to attempt a new connection with one of the versions listed in the packet, instead of abandoning the current connection attempt <a href="#handle-vn" class="xref">Section 6.2</a>.</p>
<p id="rfc.section.6.2.1.p.3">The client MUST check that the Destination and Source Connection ID fields match the Source and Destination Connection ID fields in a packet that the client sent.  If this check fails, the packet MUST be discarded.</p>
<p id="rfc.section.6.2.1.p.4">Once the Version Negotiation packet is determined to be valid, the client then selects an acceptable protocol version from the list provided by the server.  The client then attempts to create a new connection using that version. The new connection MUST use a new random Destination Connection ID different from the one it had previously sent.</p>
<p id="rfc.section.6.2.1.p.5">Note that this mechanism does not protect against downgrade attacks and MUST NOT be used outside of draft implementations.</p>
<h2 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#using-reserved-versions" id="using-reserved-versions">Using Reserved Versions</a>
</h2>
<p id="rfc.section.6.3.p.1">For a server to use a new version in the future, clients need to correctly handle unsupported versions. To help ensure this, a server SHOULD include a version that is reserved for forcing version negotiation (0x?a?a?a?a as defined in <a href="#versions" class="xref">Section 15</a>) when generating a Version Negotiation packet.</p>
<p id="rfc.section.6.3.p.2">The design of version negotiation permits a server to avoid maintaining state for packets that it rejects in this fashion.</p>
<p id="rfc.section.6.3.p.3">A client MAY send a packet using a version that is reserved for forcing version negotiation.  This can be used to solicit a list of supported versions from a server.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#handshake" id="handshake">Cryptographic and Transport Handshake</a>
</h1>
<p id="rfc.section.7.p.1">QUIC relies on a combined cryptographic and transport handshake to minimize connection establishment latency.  QUIC uses the CRYPTO frame <a href="#frame-crypto" class="xref">Section 19.6</a> to transmit the cryptographic handshake.  Version 0x00000001 of QUIC uses TLS as described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>; a different QUIC version number could indicate that a different cryptographic handshake protocol is in use.</p>
<p id="rfc.section.7.p.2">QUIC provides reliable, ordered delivery of the cryptographic handshake data. QUIC packet protection is used to encrypt as much of the handshake protocol as possible. The cryptographic handshake MUST provide the following properties:</p>
<p></p>

<ul>
<li>authenticated key exchange, where  <ul>
<li>a server is always authenticated,</li>
<li>a client is optionally authenticated,</li>
<li>every connection produces distinct and unrelated keys,</li>
<li>keying material is usable for packet protection for both 0-RTT and 1-RTT packets, and</li>
<li>1-RTT keys have forward secrecy</li>
</ul>
</li>
<li>authenticated values for the transport parameters of the peer (see <a href="#transport-parameters" class="xref">Section 7.3</a>)</li>
<li>authenticated negotiation of an application protocol (TLS uses ALPN <a href="#RFC7301" class="xref">[RFC7301]</a> for this purpose)</li>
</ul>
<p id="rfc.section.7.p.4">The first CRYPTO frame from a client MUST be sent in a single packet.  Any second attempt that is triggered by address validation (see <a href="#validate-handshake" class="xref">Section 8.1</a>) MUST also be sent within a single packet. This avoids having to reassemble a message from multiple packets.</p>
<p id="rfc.section.7.p.5">The first client packet of the cryptographic handshake protocol MUST fit within a 1232 byte QUIC packet payload.  This includes overheads that reduce the space available to the cryptographic handshake protocol.</p>
<p id="rfc.section.7.p.6">An endpoint can verify support for Explicit Congestion Notification (ECN) in the first packets it sends, as described in <a href="#ecn-verification" class="xref">Section 13.3.2</a>.</p>
<p id="rfc.section.7.p.7">The CRYPTO frame can be sent in different packet number spaces.  The sequence numbers used by CRYPTO frames to ensure ordered delivery of cryptographic handshake data start from zero in each packet number space.</p>
<p id="rfc.section.7.p.8">Endpoints MUST explicitly negotiate an application protocol.  This avoids situations where there is a disagreement about the protocol that is in use.</p>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#example-handshake-flows" id="example-handshake-flows">Example Handshake Flows</a>
</h2>
<p id="rfc.section.7.1.p.1">Details of how TLS is integrated with QUIC are provided in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>, but some examples are provided here.  An extension of this exchange to support client address validation is shown in <a href="#validate-retry" class="xref">Section 8.1.1</a>.</p>
<p id="rfc.section.7.1.p.2">Once any address validation exchanges are complete, the cryptographic handshake is used to agree on cryptographic keys.  The cryptographic handshake is carried in Initial (<a href="#packet-initial" class="xref">Section 17.2.2</a>) and Handshake (<a href="#packet-handshake" class="xref">Section 17.2.4</a>) packets.</p>
<p><a href="#tls-1rtt-handshake" class="xref">Figure 3</a> provides an overview of the 1-RTT handshake.  Each line shows a QUIC packet with the packet type and packet number shown first, followed by the frames that are typically contained in those packets. So, for instance the first packet is of type Initial, with packet number 0, and contains a CRYPTO frame carrying the ClientHello.</p>
<p id="rfc.section.7.1.p.4">Note that multiple QUIC packets &#8211; even of different encryption levels &#8211; may be coalesced into a single UDP datagram (see <a href="#packet-coalesce" class="xref">Section 12.2</a>), and so this handshake may consist of as few as 4 UDP datagrams, or any number more. For instance, the server&#8217;s first flight contains packets from the Initial encryption level (obfuscation), the Handshake level, and &#8220;0.5-RTT data&#8221; from the server at the 1-RTT encryption level.</p>
<div id="rfc.figure.3"></div>
<div id="tls-1rtt-handshake"></div>
<pre>
Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[0]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, "..."]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] -&gt;

                            1-RTT[1]: STREAM[3, "..."], ACK[0]
                                       &lt;- Handshake[1]: ACK[0]
</pre>
<p class="figure">Figure 3: Example 1-RTT Handshake</p>
<p><a href="#tls-0rtt-handshake" class="xref">Figure 4</a> shows an example of a connection with a 0-RTT handshake and a single packet of 0-RTT data. Note that as described in <a href="#packet-numbers" class="xref">Section 12.3</a>, the server acknowledges 0-RTT data at the 1-RTT encryption level, and the client sends 1-RTT packets in the same packet number space.</p>
<div id="rfc.figure.4"></div>
<div id="tls-0rtt-handshake"></div>
<pre>
Client                                                  Server

Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0, "..."] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[0]
                                  Handshake[0] CRYPTO[EE, FIN]
                          &lt;- 1-RTT[0]: STREAM[1, "..."] ACK[0]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[1]: STREAM[0, "..."] ACK[0] -&gt;

                            1-RTT[1]: STREAM[3, "..."], ACK[1]
                                       &lt;- Handshake[1]: ACK[0]
</pre>
<p class="figure">Figure 4: Example 0-RTT Handshake</p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#negotiating-connection-ids" id="negotiating-connection-ids">Negotiating Connection IDs</a>
</h2>
<p id="rfc.section.7.2.p.1">A connection ID is used to ensure consistent routing of packets, as described in <a href="#connection-id" class="xref">Section 5.1</a>.  The long header contains two connection IDs: the Destination Connection ID is chosen by the recipient of the packet and is used to provide consistent routing; the Source Connection ID is used to set the Destination Connection ID used by the peer.</p>
<p id="rfc.section.7.2.p.2">During the handshake, packets with the long header (<a href="#long-header" class="xref">Section 17.2</a>) are used to establish the connection ID that each endpoint uses.  Each endpoint uses the Source Connection ID field to specify the connection ID that is used in the Destination Connection ID field of packets being sent to them.  Upon receiving a packet, each endpoint sets the Destination Connection ID it sends to match the value of the Source Connection ID that they receive.</p>
<p id="rfc.section.7.2.p.3">When an Initial packet is sent by a client which has not previously received a Retry packet from the server, it populates the Destination Connection ID field with an unpredictable value.  This MUST be at least 8 bytes in length. Until a packet is received from the server, the client MUST use the same value unless it abandons the connection attempt and starts a new one. The initial Destination Connection ID is used to determine packet protection keys for Initial packets.</p>
<p id="rfc.section.7.2.p.4">The client populates the Source Connection ID field with a value of its choosing and sets the SCIL field to indicate the length.</p>
<p id="rfc.section.7.2.p.5">The first flight of 0-RTT packets use the same Destination and Source Connection ID values as the client&#8217;s first Initial.</p>
<p id="rfc.section.7.2.p.6">The Destination Connection ID field in the server&#8217;s Initial packet contains a connection ID that is chosen by the recipient of the packet (i.e., the client); the Source Connection ID includes the connection ID that the sender of the packet wishes to use (see <a href="#connection-id" class="xref">Section 5.1</a>). The server MUST use consistent Source Connection IDs during the handshake.</p>
<p id="rfc.section.7.2.p.7">On first receiving an Initial or Retry packet from the server, the client uses the Source Connection ID supplied by the server as the Destination Connection ID for subsequent packets, including any subsequent 0-RTT packets.  That means that a client might change the Destination Connection ID twice during connection establishment, once in response to a Retry and once in response to the first Initial packet from the server. Once a client has received an Initial packet from the server, it MUST discard any packet it receives with a different Source Connection ID.</p>
<p id="rfc.section.7.2.p.8">A client MUST only change the value it sends in the Destination Connection ID in response to the first packet of each type it receives from the server (Retry or Initial); a server MUST set its value based on the Initial packet.  Any additional changes are not permitted; if subsequent packets of those types include a different Source Connection ID, they MUST be discarded.  This avoids problems that might arise from stateless processing of multiple Initial packets producing different connection IDs.</p>
<p id="rfc.section.7.2.p.9">The connection ID can change over the lifetime of a connection, especially in response to connection migration (<a href="#migration" class="xref">Section 9</a>), see <a href="#issue-cid" class="xref">Section 5.1.1</a> for details.</p>
<h2 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#transport-parameters" id="transport-parameters">Transport Parameters</a>
</h2>
<p id="rfc.section.7.3.p.1">During connection establishment, both endpoints make authenticated declarations of their transport parameters.  These declarations are made unilaterally by each endpoint.  Endpoints are required to comply with the restrictions implied by these parameters; the description of each parameter includes rules for its handling.</p>
<p id="rfc.section.7.3.p.2">The encoding of the transport parameters is detailed in <a href="#transport-parameter-encoding" class="xref">Section 18</a>.</p>
<p id="rfc.section.7.3.p.3">QUIC includes the encoded transport parameters in the cryptographic handshake.  Once the handshake completes, the transport parameters declared by the peer are available.  Each endpoint validates the value provided by its peer.</p>
<p id="rfc.section.7.3.p.4">Definitions for each of the defined transport parameters are included in <a href="#transport-parameter-definitions" class="xref">Section 18.1</a>.  An endpoint MUST treat receipt of a transport parameter with an invalid value as a connection error of type TRANSPORT_PARAMETER_ERROR.  Any given parameter MUST appear at most once in a given transport parameters extension.  An endpoint MUST treat receipt of duplicate transport parameters as a connection error of type TRANSPORT_PARAMETER_ERROR.</p>
<p id="rfc.section.7.3.p.5">A server MUST include the original_connection_id transport parameter (<a href="#transport-parameter-definitions" class="xref">Section 18.1</a>) if it sent a Retry packet to enable validation of the Retry, as described in <a href="#packet-retry" class="xref">Section 17.2.5</a>.</p>
<h3 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#zerortt-parameters" id="zerortt-parameters">Values of Transport Parameters for 0-RTT</a>
</h3>
<p id="rfc.section.7.3.1.p.1">Both endpoints store the value of the server transport parameters from a connection and apply them to any 0-RTT packets that are sent in subsequent connections to that peer, except for transport parameters that are explicitly excluded. Remembered transport parameters apply to the new connection until the handshake completes and the client starts sending 1-RTT packets. Once the handshake completes, the client uses the transport parameters established in the handshake.</p>
<p id="rfc.section.7.3.1.p.2">The definition of new transport parameters (<a href="#new-transport-parameters" class="xref">Section 7.3.2</a>) MUST specify whether they MUST, MAY, or MUST NOT be stored for 0-RTT. A client need not store a transport parameter it cannot process.</p>
<p id="rfc.section.7.3.1.p.3">A client MUST NOT use remembered values for the following parameters: original_connection_id, preferred_address, stateless_reset_token, and ack_delay_exponent. The client MUST use the server&#8217;s new values in the handshake instead, and absent new values from the server, the default value.</p>
<p id="rfc.section.7.3.1.p.4">A client that attempts to send 0-RTT data MUST remember all other transport parameters used by the server. The server can remember these transport parameters, or store an integrity-protected copy of the values in the ticket and recover the information when accepting 0-RTT data. A server uses the transport parameters in determining whether to accept 0-RTT data.</p>
<p id="rfc.section.7.3.1.p.5">If 0-RTT data is accepted by the server, the server MUST NOT reduce any limits or alter any values that might be violated by the client with its 0-RTT data.  In particular, a server that accepts 0-RTT data MUST NOT set values for the following parameters (<a href="#transport-parameter-definitions" class="xref">Section 18.1</a>) that are smaller than the remembered value of the parameters.</p>
<p></p>

<ul>
<li>initial_max_data</li>
<li>initial_max_stream_data_bidi_local</li>
<li>initial_max_stream_data_bidi_remote</li>
<li>initial_max_stream_data_uni</li>
<li>initial_max_streams_bidi</li>
<li>initial_max_streams_uni</li>
</ul>
<p id="rfc.section.7.3.1.p.7">Omitting or setting a zero value for certain transport parameters can result in 0-RTT data being enabled, but not usable.  The applicable subset of transport parameters that permit sending of application data SHOULD be set to non-zero values for 0-RTT.  This includes initial_max_data and either initial_max_streams_bidi and initial_max_stream_data_bidi_remote, or initial_max_streams_uni and initial_max_stream_data_uni.</p>
<p id="rfc.section.7.3.1.p.8">A server MUST either reject 0-RTT data or abort a handshake if the implied values for transport parameters cannot be supported.</p>
<h3 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#new-transport-parameters" id="new-transport-parameters">New Transport Parameters</a>
</h3>
<p id="rfc.section.7.3.2.p.1">New transport parameters can be used to negotiate new protocol behavior.  An endpoint MUST ignore transport parameters that it does not support.  Absence of a transport parameter therefore disables any optional protocol feature that is negotiated using the parameter.</p>
<p id="rfc.section.7.3.2.p.2">New transport parameters can be registered according to the rules in <a href="#iana-transport-parameters" class="xref">Section 22.1</a>.</p>
<h2 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#cryptographic-message-buffering" id="cryptographic-message-buffering">Cryptographic Message Buffering</a>
</h2>
<p id="rfc.section.7.4.p.1">Implementations need to maintain a buffer of CRYPTO data received out of order.  Because there is no flow control of CRYPTO frames, an endpoint could potentially force its peer to buffer an unbounded amount of data.</p>
<p id="rfc.section.7.4.p.2">Implementations MUST support buffering at least 4096 bytes of data received in CRYPTO frames out of order. Endpoints MAY choose to allow more data to be buffered during the handshake. A larger limit during the handshake could allow for larger keys or credentials to be exchanged. An endpoint&#8217;s buffer size does not need to remain constant during the life of the connection.</p>
<p id="rfc.section.7.4.p.3">Being unable to buffer CRYPTO frames during the handshake can lead to a connection failure. If an endpoint&#8217;s buffer is exceeded during the handshake, it can expand its buffer temporarily to complete the handshake. If an endpoint does not expand its buffer, it MUST close the connection with a CRYPTO_BUFFER_EXCEEDED error code.</p>
<p id="rfc.section.7.4.p.4">Once the handshake completes, if an endpoint is unable to buffer all data in a CRYPTO frame, it MAY discard that CRYPTO frame and all CRYPTO frames received in the future, or it MAY close the connection with an CRYPTO_BUFFER_EXCEEDED error code. Packets containing discarded CRYPTO frames MUST be acknowledged because the packet has been received and processed by the transport even though the CRYPTO frame was discarded.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#address-validation" id="address-validation">Address Validation</a>
</h1>
<p id="rfc.section.8.p.1">Address validation is used by QUIC to avoid being used for a traffic amplification attack.  In such an attack, a packet is sent to a server with spoofed source address information that identifies a victim.  If a server generates more or larger packets in response to that packet, the attacker can use the server to send more data toward the victim than it would be able to send on its own.</p>
<p id="rfc.section.8.p.2">The primary defense against amplification attack is verifying that an endpoint is able to receive packets at the transport address that it claims.  Address validation is performed both during connection establishment (see <a href="#validate-handshake" class="xref">Section 8.1</a>) and during connection migration (see <a href="#migrate-validate" class="xref">Section 8.2</a>).</p>
<h2 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#validate-handshake" id="validate-handshake">Address Validation During Connection Establishment</a>
</h2>
<p id="rfc.section.8.1.p.1">Connection establishment implicitly provides address validation for both endpoints.  In particular, receipt of a packet protected with Handshake keys confirms that the client received the Initial packet from the server.  Once the server has successfully processed a Handshake packet from the client, it can consider the client address to have been validated.</p>
<p id="rfc.section.8.1.p.2">Prior to validating the client address, servers MUST NOT send more than three times as many bytes as the number of bytes they have received.  This limits the magnitude of any amplification attack that can be mounted using spoofed source addresses.  In determining this limit, servers only count the size of successfully processed packets.</p>
<p id="rfc.section.8.1.p.3">Clients MUST ensure that UDP datagrams containing only Initial packets are sized to at least 1200 bytes, adding padding to packets in the datagram as necessary.  Sending padded datagrams ensures that the server is not overly constrained by the amplification restriction.</p>
<p id="rfc.section.8.1.p.4">Packet loss, in particular loss of a Handshake packet from the server, can cause a situation in which the server cannot send when the client has no data to send and the anti-amplification limit is reached. In order to avoid this causing a handshake deadlock, clients SHOULD send a packet upon a crypto retransmission timeout, as described in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>. If the client has no data to retransmit and does not have Handshake keys, it SHOULD send an Initial packet in a UDP datagram of at least 1200 bytes.  If the client has Handshake keys, it SHOULD send a Handshake packet.</p>
<p id="rfc.section.8.1.p.5">A server might wish to validate the client address before starting the cryptographic handshake. QUIC uses a token in the Initial packet to provide address validation prior to completing the handshake. This token is delivered to the client during connection establishment with a Retry packet (see <a href="#validate-retry" class="xref">Section 8.1.1</a>) or in a previous connection using the NEW_TOKEN frame (see <a href="#validate-future" class="xref">Section 8.1.2</a>).</p>
<p id="rfc.section.8.1.p.6">In addition to sending limits imposed prior to address validation, servers are also constrained in what they can send by the limits set by the congestion controller.  Clients are only constrained by the congestion controller.</p>
<h3 id="rfc.section.8.1.1">
<a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#validate-retry" id="validate-retry">Address Validation using Retry Packets</a>
</h3>
<p id="rfc.section.8.1.1.p.1">Upon receiving the client&#8217;s Initial packet, the server can request address validation by sending a Retry packet (<a href="#packet-retry" class="xref">Section 17.2.5</a>) containing a token. This token MUST be repeated by the client in all Initial packets it sends for that connection after it receives the Retry packet.  In response to processing an Initial containing a token, a server can either abort the connection or permit it to proceed.</p>
<p id="rfc.section.8.1.1.p.2">As long as it is not possible for an attacker to generate a valid token for its own address (see <a href="#token-integrity" class="xref">Section 8.1.3</a>) and the client is able to return that token, it proves to the server that it received the token.</p>
<p id="rfc.section.8.1.1.p.3">A server can also use a Retry packet to defer the state and processing costs of connection establishment.  By giving the client a different connection ID to use, a server can cause the connection to be routed to a server instance with more resources available for new connections.</p>
<p id="rfc.section.8.1.1.p.4">A flow showing the use of a Retry packet is shown in <a href="#fig-retry" class="xref">Figure 5</a>.</p>
<div id="rfc.figure.5"></div>
<div id="fig-retry"></div>
<pre>
Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                                &lt;- Retry+Token

Initial+Token[1]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, "..."]
</pre>
<p class="figure">Figure 5: Example Handshake with Retry</p>
<h3 id="rfc.section.8.1.2">
<a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#validate-future" id="validate-future">Address Validation for Future Connections</a>
</h3>
<p id="rfc.section.8.1.2.p.1">A server MAY provide clients with an address validation token during one connection that can be used on a subsequent connection.  Address validation is especially important with 0-RTT because a server potentially sends a significant amount of data to a client in response to 0-RTT data.</p>
<p id="rfc.section.8.1.2.p.2">The server uses the NEW_TOKEN frame <a href="#frame-new-token" class="xref">Section 19.7</a> to provide the client with an address validation token that can be used to validate future connections.  The client includes this token in Initial packets to provide address validation in a future connection.  The client MUST include the token in all Initial packets it sends, unless a Retry or NEW_TOKEN frame replaces the token with a newer one. The client MUST NOT use the token provided in a Retry for future connections. Servers MAY discard any Initial packet that does not carry the expected token.</p>
<p id="rfc.section.8.1.2.p.3">Unlike the token that is created for a Retry packet, there might be some time between when the token is created and when the token is subsequently used.  Thus, a token SHOULD include an expiration time.  The server MAY include either an explicit expiration time or an issued timestamp and dynamically calculate the expiration time.  It is also unlikely that the client port number is the same on two different connections; validating the port is therefore unlikely to be successful.</p>
<p id="rfc.section.8.1.2.p.4">A token SHOULD be constructed for the server to easily distinguish it from tokens that are sent in Retry packets as they are carried in the same field.</p>
<p id="rfc.section.8.1.2.p.5">If the client has a token received in a NEW_TOKEN frame on a previous connection to what it believes to be the same server, it SHOULD include that value in the Token field of its Initial packet.  Including a token might allow the server to validate the client address without an additional round trip.</p>
<p id="rfc.section.8.1.2.p.6">A token allows a server to correlate activity between the connection where the token was issued and any connection where it is used.  Clients that want to break continuity of identity with a server MAY discard tokens provided using the NEW_TOKEN frame.  A token obtained in a Retry packet MUST be used immediately during the connection attempt and cannot be used in subsequent connection attempts.</p>
<p id="rfc.section.8.1.2.p.7">A client SHOULD NOT reuse a token in different connections. Reusing a token allows connections to be linked by entities on the network path (see <a href="#migration-linkability" class="xref">Section 9.5</a>).  A client MUST NOT reuse a token if it believes that its point of network attachment has changed since the token was last used; that is, if there is a change in its local IP address or network interface.  A client needs to start the connection process over if it migrates prior to completing the handshake.</p>
<p id="rfc.section.8.1.2.p.8">When a server receives an Initial packet with an address validation token, it MUST attempt to validate the token, unless it has already completed address validation.  If the token is invalid then the server SHOULD proceed as if the client did not have a validated address, including potentially sending a Retry. If the validation succeeds, the server SHOULD then allow the handshake to proceed.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">The rationale for treating the client as unvalidated rather than discarding the packet is that the client might have received the token in a previous connection using the NEW_TOKEN frame, and if the server has lost state, it might be unable to validate the token at all, leading to connection failure if the packet is discarded.  A server SHOULD encode tokens provided with NEW_TOKEN frames and Retry packets differently, and validate the latter more strictly.</dd>
</dl>
<p id="rfc.section.8.1.2.p.10">In a stateless design, a server can use encrypted and authenticated tokens to pass information to clients that the server can later recover and use to validate a client address.  Tokens are not integrated into the cryptographic handshake and so they are not authenticated.  For instance, a client might be able to reuse a token.  To avoid attacks that exploit this property, a server can limit its use of tokens to only the information needed to validate client addresses.</p>
<p id="rfc.section.8.1.2.p.11">Attackers could replay tokens to use servers as amplifiers in DDoS attacks. To protect against such attacks, servers SHOULD ensure that tokens sent in Retry packets are only accepted for a short time. Tokens that are provided in NEW_TOKEN frames (see <a href="#frame-new-token" class="xref">Section 19.7</a>) need to be valid for longer, but SHOULD NOT be accepted multiple times in a short period. Servers are encouraged to allow tokens to be used only once, if possible.</p>
<h3 id="rfc.section.8.1.3">
<a href="#rfc.section.8.1.3">8.1.3.</a> <a href="#token-integrity" id="token-integrity">Address Validation Token Integrity</a>
</h3>
<p id="rfc.section.8.1.3.p.1">An address validation token MUST be difficult to guess.  Including a large enough random value in the token would be sufficient, but this depends on the server remembering the value it sends to clients.</p>
<p id="rfc.section.8.1.3.p.2">A token-based scheme allows the server to offload any state associated with validation to the client.  For this design to work, the token MUST be covered by integrity protection against modification or falsification by clients.  Without integrity protection, malicious clients could generate or guess values for tokens that would be accepted by the server.  Only the server requires access to the integrity protection key for tokens.</p>
<p id="rfc.section.8.1.3.p.3">There is no need for a single well-defined format for the token because the server that generates the token also consumes it.  A token could include information about the claimed client address (IP and port), a timestamp, and any other supplementary information the server will need to validate the token in the future.</p>
<h2 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#migrate-validate" id="migrate-validate">Path Validation</a>
</h2>
<p id="rfc.section.8.2.p.1">Path validation is used during connection migration (see <a href="#migration" class="xref">Section 9</a> and <a href="#preferred-address" class="xref">Section 9.6</a>) by the migrating endpoint to verify reachability of a peer from a new local address.  In path validation, endpoints test reachability between a specific local address and a specific peer address, where an address is the two-tuple of IP address and port.</p>
<p id="rfc.section.8.2.p.2">Path validation tests that packets (PATH_CHALLENGE) can be both sent to and received (PATH_RESPONSE) from a peer on the path.  Importantly, it validates that the packets received from the migrating endpoint do not carry a spoofed source address.</p>
<p id="rfc.section.8.2.p.3">Path validation can be used at any time by either endpoint.  For instance, an endpoint might check that a peer is still in possession of its address after a period of quiescence.</p>
<p id="rfc.section.8.2.p.4">Path validation is not designed as a NAT traversal mechanism. Though the mechanism described here might be effective for the creation of NAT bindings that support NAT traversal, the expectation is that one or other peer is able to receive packets without first having sent a packet on that path. Effective NAT traversal needs additional synchronization mechanisms that are not provided here.</p>
<p id="rfc.section.8.2.p.5">An endpoint MAY bundle PATH_CHALLENGE and PATH_RESPONSE frames that are used for path validation with other frames.  In particular, an endpoint may pad a packet carrying a PATH_CHALLENGE for PMTU discovery, or an endpoint may bundle a PATH_RESPONSE with its own PATH_CHALLENGE.</p>
<p id="rfc.section.8.2.p.6">When probing a new path, an endpoint might want to ensure that its peer has an unused connection ID available for responses. The endpoint can send NEW_CONNECTION_ID and PATH_CHALLENGE frames in the same packet. This ensures that an unused connection ID will be available to the peer when sending a response.</p>
<h2 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#initiating-path-validation" id="initiating-path-validation">Initiating Path Validation</a>
</h2>
<p id="rfc.section.8.3.p.1">To initiate path validation, an endpoint sends a PATH_CHALLENGE frame containing a random payload on the path to be validated.</p>
<p id="rfc.section.8.3.p.2">An endpoint MAY send multiple PATH_CHALLENGE frames to guard against packet loss.  An endpoint SHOULD NOT send a PATH_CHALLENGE more frequently than it would an Initial packet, ensuring that connection migration is no more load on a new path than establishing a new connection.</p>
<p id="rfc.section.8.3.p.3">The endpoint MUST use unpredictable data in every PATH_CHALLENGE frame so that it can associate the peer&#8217;s response with the corresponding PATH_CHALLENGE.</p>
<h2 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#path-validation-responses" id="path-validation-responses">Path Validation Responses</a>
</h2>
<p id="rfc.section.8.4.p.1">On receiving a PATH_CHALLENGE frame, an endpoint MUST respond immediately by echoing the data contained in the PATH_CHALLENGE frame in a PATH_RESPONSE frame.</p>
<p id="rfc.section.8.4.p.2">To ensure that packets can be both sent to and received from the peer, the PATH_RESPONSE MUST be sent on the same path as the triggering PATH_CHALLENGE.  That is, from the same local address on which the PATH_CHALLENGE was received, to the same remote address from which the PATH_CHALLENGE was received.</p>
<h2 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#successful-path-validation" id="successful-path-validation">Successful Path Validation</a>
</h2>
<p id="rfc.section.8.5.p.1">A new address is considered valid when a PATH_RESPONSE frame is received that meets the following criteria:</p>
<p></p>

<ul>
<li>It contains the data that was sent in a previous PATH_CHALLENGE. Receipt of an acknowledgment for a packet containing a PATH_CHALLENGE frame is not adequate validation, since the acknowledgment can be spoofed by a malicious peer.</li>
<li>It was sent from the same remote address to which the corresponding PATH_CHALLENGE was sent. If a PATH_RESPONSE frame is received from a different remote address than the one to which the PATH_CHALLENGE was sent, path validation is considered to have failed, even if the data matches that sent in the PATH_CHALLENGE.</li>
<li>It was received on the same local address from which the corresponding PATH_CHALLENGE was sent.</li>
</ul>
<p id="rfc.section.8.5.p.3">Note that receipt on a different local address does not result in path validation failure, as it might be a result of a forwarded packet (see <a href="#off-path-forward" class="xref">Section 9.3.3</a>) or misrouting. It is possible that a valid PATH_RESPONSE might be received in the future.</p>
<h2 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> <a href="#failed-path-validation" id="failed-path-validation">Failed Path Validation</a>
</h2>
<p id="rfc.section.8.6.p.1">Path validation only fails when the endpoint attempting to validate the path abandons its attempt to validate the path.</p>
<p id="rfc.section.8.6.p.2">Endpoints SHOULD abandon path validation based on a timer. When setting this timer, implementations are cautioned that the new path could have a longer round-trip time than the original.  A value of three times the larger of the current Probe Timeout (PTO) or the initial timeout (that is, 2*kInitialRtt) as defined in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a> is RECOMMENDED.  That is:</p>
<pre>
   validation_timeout = max(3*PTO, 6*kInitialRtt)
</pre>
<p id="rfc.section.8.6.p.3">Note that the endpoint might receive packets containing other frames on the new path, but a PATH_RESPONSE frame with appropriate data is required for path validation to succeed.</p>
<p id="rfc.section.8.6.p.4">When an endpoint abandons path validation, it determines that the path is unusable.  This does not necessarily imply a failure of the connection - endpoints can continue sending packets over other paths as appropriate.  If no paths are available, an endpoint can wait for a new path to become available or close the connection.</p>
<p id="rfc.section.8.6.p.5">A path validation might be abandoned for other reasons besides failure. Primarily, this happens if a connection migration to a new path is initiated while a path validation on the old path is in progress.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#migration" id="migration">Connection Migration</a>
</h1>
<p id="rfc.section.9.p.1">The use of a connection ID allows connections to survive changes to endpoint addresses (that is, IP address and/or port), such as those caused by an endpoint migrating to a new network.  This section describes the process by which an endpoint migrates to a new address.</p>
<p id="rfc.section.9.p.2">An endpoint MUST NOT initiate connection migration before the handshake is finished and the endpoint has 1-RTT keys.  The design of QUIC relies on endpoints retaining a stable address for the duration of the handshake.</p>
<p id="rfc.section.9.p.3">An endpoint also MUST NOT initiate connection migration if the peer sent the <samp>disable_migration</samp> transport parameter during the handshake.  An endpoint which has sent this transport parameter, but detects that a peer has nonetheless migrated to a different network MAY treat this as a connection error of type INVALID_MIGRATION.  Similarly, an endpoint MUST NOT initiate migration if its peer supplies a zero-length connection ID as packets without a Destination Connection ID cannot be attributed to a connection based on address tuple.</p>
<p id="rfc.section.9.p.4">Not all changes of peer address are intentional migrations. The peer could experience NAT rebinding: a change of address due to a middlebox, usually a NAT, allocating a new outgoing port or even a new outgoing IP address for a flow.  NAT rebinding is not connection migration as defined in this section, though an endpoint SHOULD perform path validation (<a href="#migrate-validate" class="xref">Section 8.2</a>) if it detects a change in the IP address of its peer.</p>
<p id="rfc.section.9.p.5">When an endpoint has no validated path on which to send packets, it MAY discard connection state.  An endpoint capable of connection migration MAY wait for a new path to become available before discarding connection state.</p>
<p id="rfc.section.9.p.6">This document limits migration of connections to new client addresses, except as described in <a href="#preferred-address" class="xref">Section 9.6</a>. Clients are responsible for initiating all migrations.  Servers do not send non-probing packets (see <a href="#probing" class="xref">Section 9.1</a>) toward a client address until they see a non-probing packet from that address.  If a client receives packets from an unknown server address, the client MUST discard these packets.</p>
<h2 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#probing" id="probing">Probing a New Path</a>
</h2>
<p id="rfc.section.9.1.p.1">An endpoint MAY probe for peer reachability from a new local address using path validation <a href="#migrate-validate" class="xref">Section 8.2</a> prior to migrating the connection to the new local address.  Failure of path validation simply means that the new path is not usable for this connection.  Failure to validate a path does not cause the connection to end unless there are no valid alternative paths available.</p>
<p id="rfc.section.9.1.p.2">An endpoint uses a new connection ID for probes sent from a new local address, see <a href="#migration-linkability" class="xref">Section 9.5</a> for further discussion. An endpoint that uses a new local address needs to ensure that at least one new connection ID is available at the peer. That can be achieved by including a NEW_CONNECTION_ID frame in the probe.</p>
<p id="rfc.section.9.1.p.3">Receiving a PATH_CHALLENGE frame from a peer indicates that the peer is probing for reachability on a path. An endpoint sends a PATH_RESPONSE in response as per <a href="#migrate-validate" class="xref">Section 8.2</a>.</p>
<p id="rfc.section.9.1.p.4">PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, and PADDING frames are &#8220;probing frames&#8221;, and all other frames are &#8220;non-probing frames&#8221;.  A packet containing only probing frames is a &#8220;probing packet&#8221;, and a packet containing any other frame is a &#8220;non-probing packet&#8221;.</p>
<h2 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#initiating-migration" id="initiating-migration">Initiating Connection Migration</a>
</h2>
<p id="rfc.section.9.2.p.1">An endpoint can migrate a connection to a new local address by sending packets containing non-probing frames from that address.</p>
<p id="rfc.section.9.2.p.2">Each endpoint validates its peer&#8217;s address during connection establishment.  Therefore, a migrating endpoint can send to its peer knowing that the peer is willing to receive at the peer&#8217;s current address. Thus an endpoint can migrate to a new local address without first validating the peer&#8217;s address.</p>
<p id="rfc.section.9.2.p.3">When migrating, the new path might not support the endpoint&#8217;s current sending rate. Therefore, the endpoint resets its congestion controller, as described in <a href="#migration-cc" class="xref">Section 9.4</a>.</p>
<p id="rfc.section.9.2.p.4">The new path might not have the same ECN capability. Therefore, the endpoint verifies ECN capability as described in <a href="#ecn" class="xref">Section 13.3</a>.</p>
<p id="rfc.section.9.2.p.5">Receiving acknowledgments for data sent on the new path serves as proof of the peer&#8217;s reachability from the new address.  Note that since acknowledgments may be received on any path, return reachability on the new path is not established. To establish return reachability on the new path, an endpoint MAY concurrently initiate path validation <a href="#migrate-validate" class="xref">Section 8.2</a> on the new path.</p>
<h2 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#migration-response" id="migration-response">Responding to Connection Migration</a>
</h2>
<p id="rfc.section.9.3.p.1">Receiving a packet from a new peer address containing a non-probing frame indicates that the peer has migrated to that address.</p>
<p id="rfc.section.9.3.p.2">In response to such a packet, an endpoint MUST start sending subsequent packets to the new peer address and MUST initiate path validation (<a href="#migrate-validate" class="xref">Section 8.2</a>) to verify the peer&#8217;s ownership of the unvalidated address.</p>
<p id="rfc.section.9.3.p.3">An endpoint MAY send data to an unvalidated peer address, but it MUST protect against potential attacks as described in <a href="#address-spoofing" class="xref">Section 9.3.1</a> and <a href="#on-path-spoofing" class="xref">Section 9.3.2</a>.  An endpoint MAY skip validation of a peer address if that address has been seen recently.</p>
<p id="rfc.section.9.3.p.4">An endpoint only changes the address that it sends packets to in response to the highest-numbered non-probing packet. This ensures that an endpoint does not send packets to an old peer address in the case that it receives reordered packets.</p>
<p id="rfc.section.9.3.p.5">After changing the address to which it sends non-probing packets, an endpoint could abandon any path validation for other addresses.</p>
<p id="rfc.section.9.3.p.6">Receiving a packet from a new peer address might be the result of a NAT rebinding at the peer.</p>
<p id="rfc.section.9.3.p.7">After verifying a new client address, the server SHOULD send new address validation tokens (<a href="#address-validation" class="xref">Section 8</a>) to the client.</p>
<h3 id="rfc.section.9.3.1">
<a href="#rfc.section.9.3.1">9.3.1.</a> <a href="#address-spoofing" id="address-spoofing">Peer Address Spoofing</a>
</h3>
<p id="rfc.section.9.3.1.p.1">It is possible that a peer is spoofing its source address to cause an endpoint to send excessive amounts of data to an unwilling host.  If the endpoint sends significantly more data than the spoofing peer, connection migration might be used to amplify the volume of data that an attacker can generate toward a victim.</p>
<p id="rfc.section.9.3.1.p.2">As described in <a href="#migration-response" class="xref">Section 9.3</a>, an endpoint is required to validate a peer&#8217;s new address to confirm the peer&#8217;s possession of the new address.  Until a peer&#8217;s address is deemed valid, an endpoint MUST limit the rate at which it sends data to this address.  The endpoint MUST NOT send more than a minimum congestion window&#8217;s worth of data per estimated round-trip time (kMinimumWindow, as defined in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>).  In the absence of this limit, an endpoint risks being used for a denial of service attack against an unsuspecting victim.  Note that since the endpoint will not have any round-trip time measurements to this address, the estimate SHOULD be the default initial value (see <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>).</p>
<p id="rfc.section.9.3.1.p.3">If an endpoint skips validation of a peer address as described in <a href="#migration-response" class="xref">Section 9.3</a>, it does not need to limit its sending rate.</p>
<h3 id="rfc.section.9.3.2">
<a href="#rfc.section.9.3.2">9.3.2.</a> <a href="#on-path-spoofing" id="on-path-spoofing">On-Path Address Spoofing</a>
</h3>
<p id="rfc.section.9.3.2.p.1">An on-path attacker could cause a spurious connection migration by copying and forwarding a packet with a spoofed address such that it arrives before the original packet.  The packet with the spoofed address will be seen to come from a migrating connection, and the original packet will be seen as a duplicate and dropped. After a spurious migration, validation of the source address will fail because the entity at the source address does not have the necessary cryptographic keys to read or respond to the PATH_CHALLENGE frame that is sent to it even if it wanted to.</p>
<p id="rfc.section.9.3.2.p.2">To protect the connection from failing due to such a spurious migration, an endpoint MUST revert to using the last validated peer address when validation of a new peer address fails.</p>
<p id="rfc.section.9.3.2.p.3">If an endpoint has no state about the last validated peer address, it MUST close the connection silently by discarding all connection state. This results in new packets on the connection being handled generically. For instance, an endpoint MAY send a stateless reset in response to any further incoming packets.</p>
<p id="rfc.section.9.3.2.p.4">Note that receipt of packets with higher packet numbers from the legitimate peer address will trigger another connection migration.  This will cause the validation of the address of the spurious migration to be abandoned.</p>
<h3 id="rfc.section.9.3.3">
<a href="#rfc.section.9.3.3">9.3.3.</a> <a href="#off-path-forward" id="off-path-forward">Off-Path Packet Forwarding</a>
</h3>
<p id="rfc.section.9.3.3.p.1">An off-path attacker that can observe packets might forward copies of genuine packets to endpoints.  If the copied packet arrives before the genuine packet, this will appear as a NAT rebinding.  Any genuine packet will be discarded as a duplicate.  If the attacker is able to continue forwarding packets, it might be able to cause migration to a path via the attacker.  This places the attacker on path, giving it the ability to observe or drop all subsequent packets.</p>
<p id="rfc.section.9.3.3.p.2">Unlike the attack described in <a href="#on-path-spoofing" class="xref">Section 9.3.2</a>, the attacker can ensure that the new path is successfully validated.</p>
<p id="rfc.section.9.3.3.p.3">This style of attack relies on the attacker using a path that is approximately as fast as the direct path between endpoints.  The attack is more reliable if relatively few packets are sent or if packet loss coincides with the attempted attack.</p>
<p id="rfc.section.9.3.3.p.4">A non-probing packet received on the original path that increases the maximum received packet number will cause the endpoint to move back to that path.  Eliciting packets on this path increases the likelihood that the attack is unsuccessful.  Therefore, mitigation of this attack relies on triggering the exchange of packets.</p>
<p id="rfc.section.9.3.3.p.5">In response to an apparent migration, endpoints MUST validate the previously active path using a PATH_CHALLENGE frame.  This induces the sending of new packets on that path.  If the path is no longer viable, the validation attempt will time out and fail; if the path is viable, but no longer desired, the validation will succeed, but only results in probing packets being sent on the path.</p>
<p id="rfc.section.9.3.3.p.6">An endpoint that receives a PATH_CHALLENGE on an active path SHOULD send a non-probing packet in response.  If the non-probing packet arrives before any copy made by an attacker, this results in the connection being migrated back to the original path.  Any subsequent migration to another path restarts this entire process.</p>
<p id="rfc.section.9.3.3.p.7">This defense is imperfect, but this is not considered a serious problem. If the path via the attack is reliably faster than the original path despite multiple attempts to use that original path, it is not possible to distinguish between attack and an improvement in routing.</p>
<p id="rfc.section.9.3.3.p.8">An endpoint could also use heuristics to improve detection of this style of attack.  For instance, NAT rebinding is improbable if packets were recently received on the old path, similarly rebinding is rare on IPv6 paths.  Endpoints can also look for duplicated packets.  Conversely, a change in connection ID is more likely to indicate an intentional migration rather than an attack.</p>
<h2 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#migration-cc" id="migration-cc">Loss Detection and Congestion Control</a>
</h2>
<p id="rfc.section.9.4.p.1">The capacity available on the new path might not be the same as the old path.  Packets sent on the old path SHOULD NOT contribute to congestion control or RTT estimation for the new path.</p>
<p id="rfc.section.9.4.p.2">On confirming a peer&#8217;s ownership of its new address, an endpoint SHOULD immediately reset the congestion controller and round-trip time estimator for the new path.</p>
<p id="rfc.section.9.4.p.3">An endpoint MUST NOT return to the send rate used for the previous path unless it is reasonably sure that the previous send rate is valid for the new path.  For instance, a change in the client&#8217;s port number is likely indicative of a rebinding in a middlebox and not a complete change in path.  This determination likely depends on heuristics, which could be imperfect; if the new path capacity is significantly reduced, ultimately this relies on the congestion controller responding to congestion signals and reducing send rates appropriately.</p>
<p id="rfc.section.9.4.p.4">There may be apparent reordering at the receiver when an endpoint sends data and probes from/to multiple addresses during the migration period, since the two resulting paths may have different round-trip times.  A receiver of packets on multiple paths will still send ACK frames covering all received packets.</p>
<p id="rfc.section.9.4.p.5">While multiple paths might be used during connection migration, a single congestion control context and a single loss recovery context (as described in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>) may be adequate.  For instance, an endpoint might delay switching to a new congestion control context until it is confirmed that an old path is no longer needed (such as the case in <a href="#off-path-forward" class="xref">Section 9.3.3</a>).</p>
<p id="rfc.section.9.4.p.6">A sender can make exceptions for probe packets so that their loss detection is independent and does not unduly cause the congestion controller to reduce its sending rate.  An endpoint might set a separate timer when a PATH_CHALLENGE is sent, which is cancelled when the corresponding PATH_RESPONSE is received.  If the timer fires before the PATH_RESPONSE is received, the endpoint might send a new PATH_CHALLENGE, and restart the timer for a longer period of time.</p>
<h2 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#migration-linkability" id="migration-linkability">Privacy Implications of Connection Migration</a>
</h2>
<p id="rfc.section.9.5.p.1">Using a stable connection ID on multiple network paths allows a passive observer to correlate activity between those paths.  An endpoint that moves between networks might not wish to have their activity correlated by any entity other than their peer, so different connection IDs are used when sending from different local addresses, as discussed in <a href="#connection-id" class="xref">Section 5.1</a>.  For this to be effective endpoints need to ensure that connections IDs they provide cannot be linked by any other entity.</p>
<p id="rfc.section.9.5.p.2">At any time, endpoints MAY change the Destination Connection ID they send to a value that has not been used on another path.</p>
<p id="rfc.section.9.5.p.3">An endpoint MUST use a new connection ID if it initiates connection migration.  Using a new connection ID eliminates the use of the connection ID for linking activity from the same connection on different networks.  Header protection ensures that packet numbers cannot be used to correlate activity.  This does not prevent other properties of packets, such as timing and size, from being used to correlate activity.</p>
<p id="rfc.section.9.5.p.4">Unintentional changes in path without a change in connection ID are possible.  For example, after a period of network inactivity, NAT rebinding might cause packets to be sent on a new path when the client resumes sending.</p>
<p id="rfc.section.9.5.p.5">A client might wish to reduce linkability by employing a new connection ID and source UDP port when sending traffic after a period of inactivity.  Changing the UDP port from which it sends packets at the same time might cause the packet to appear as a connection migration. This ensures that the mechanisms that support migration are exercised even for clients that don&#8217;t experience NAT rebindings or genuine migrations.  Changing port number can cause a peer to reset its congestion state (see <a href="#migration-cc" class="xref">Section 9.4</a>), so the port SHOULD only be changed infrequently.</p>
<p id="rfc.section.9.5.p.6">An endpoint that exhausts available connection IDs cannot migrate.  To ensure that migration is possible and packets sent on different paths cannot be correlated, endpoints SHOULD provide new connection IDs before peers migrate.</p>
<h2 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> <a href="#preferred-address" id="preferred-address">Server&#8217;s Preferred Address</a>
</h2>
<p id="rfc.section.9.6.p.1">QUIC allows servers to accept connections on one IP address and attempt to transfer these connections to a more preferred address shortly after the handshake.  This is particularly useful when clients initially connect to an address shared by multiple servers but would prefer to use a unicast address to ensure connection stability. This section describes the protocol for migrating a connection to a preferred server address.</p>
<p id="rfc.section.9.6.p.2">Migrating a connection to a new server address mid-connection is left for future work. If a client receives packets from a new server address not indicated by the preferred_address transport parameter, the client SHOULD discard these packets.</p>
<h3 id="rfc.section.9.6.1">
<a href="#rfc.section.9.6.1">9.6.1.</a> <a href="#communicating-a-preferred-address" id="communicating-a-preferred-address">Communicating A Preferred Address</a>
</h3>
<p id="rfc.section.9.6.1.p.1">A server conveys a preferred address by including the preferred_address transport parameter in the TLS handshake.</p>
<p id="rfc.section.9.6.1.p.2">Servers MAY communicate a preferred address of each address family (IPv4 and IPv6) to allow clients to pick the one most suited to their network attachment.</p>
<p id="rfc.section.9.6.1.p.3">Once the handshake is finished, the client SHOULD select one of the two server&#8217;s preferred addresses and initiate path validation (see <a href="#migrate-validate" class="xref">Section 8.2</a>) of that address using the connection ID provided in the preferred_address transport parameter.</p>
<p id="rfc.section.9.6.1.p.4">If path validation succeeds, the client SHOULD immediately begin sending all future packets to the new server address using the new connection ID and discontinue use of the old server address.  If path validation fails, the client MUST continue sending all future packets to the server&#8217;s original IP address.</p>
<h3 id="rfc.section.9.6.2">
<a href="#rfc.section.9.6.2">9.6.2.</a> <a href="#responding-to-connection-migration" id="responding-to-connection-migration">Responding to Connection Migration</a>
</h3>
<p id="rfc.section.9.6.2.p.1">A server might receive a packet addressed to its preferred IP address at any time after it accepts a connection.  If this packet contains a PATH_CHALLENGE frame, the server sends a PATH_RESPONSE frame as per <a href="#migrate-validate" class="xref">Section 8.2</a>.  The server MUST send other non-probing frames from its original address until it receives a non-probing packet from the client at its preferred address and until the server has validated the new path.</p>
<p id="rfc.section.9.6.2.p.2">The server MUST probe on the path toward the client from its preferred address.  This helps to guard against spurious migration initiated by an attacker.</p>
<p id="rfc.section.9.6.2.p.3">Once the server has completed its path validation and has received a non-probing packet with a new largest packet number on its preferred address, the server begins sending non-probing packets to the client exclusively from its preferred IP address.  It SHOULD drop packets for this connection received on the old IP address, but MAY continue to process delayed packets.</p>
<h3 id="rfc.section.9.6.3">
<a href="#rfc.section.9.6.3">9.6.3.</a> <a href="#interaction-of-client-migration-and-preferred-address" id="interaction-of-client-migration-and-preferred-address">Interaction of Client Migration and Preferred Address</a>
</h3>
<p id="rfc.section.9.6.3.p.1">A client might need to perform a connection migration before it has migrated to the server&#8217;s preferred address.  In this case, the client SHOULD perform path validation to both the original and preferred server address from the client&#8217;s new address concurrently.</p>
<p id="rfc.section.9.6.3.p.2">If path validation of the server&#8217;s preferred address succeeds, the client MUST abandon validation of the original address and migrate to using the server&#8217;s preferred address.  If path validation of the server&#8217;s preferred address fails but validation of the server&#8217;s original address succeeds, the client MAY migrate to its new address and continue sending to the server&#8217;s original address.</p>
<p id="rfc.section.9.6.3.p.3">If the connection to the server&#8217;s preferred address is not from the same client address, the server MUST protect against potential attacks as described in <a href="#address-spoofing" class="xref">Section 9.3.1</a> and <a href="#on-path-spoofing" class="xref">Section 9.3.2</a>.  In addition to intentional simultaneous migration, this might also occur because the client&#8217;s access network used a different NAT binding for the server&#8217;s preferred address.</p>
<p id="rfc.section.9.6.3.p.4">Servers SHOULD initiate path validation to the client&#8217;s new address upon receiving a probe packet from a different address.  Servers MUST NOT send more than a minimum congestion window&#8217;s worth of non-probing packets to the new address before path validation is complete.</p>
<p id="rfc.section.9.6.3.p.5">A client that migrates to a new address SHOULD use a preferred address from the same address family for the server.</p>
<h2 id="rfc.section.9.7">
<a href="#rfc.section.9.7">9.7.</a> <a href="#ipv6-flow-label" id="ipv6-flow-label">Use of IPv6 Flow-Label and Migration</a>
</h2>
<p id="rfc.section.9.7.p.1">Endpoints that send data using IPv6 SHOULD apply an IPv6 flow label in compliance with <a href="#RFC6437" class="xref">[RFC6437]</a>, unless the local API does not allow setting IPv6 flow labels.</p>
<p id="rfc.section.9.7.p.2">The IPv6 flow label SHOULD be a pseudo-random function of the source and destination addresses, source and destination UDP ports, and the destination CID. The flow label generation MUST be designed to minimize the chances of linkability with a previously used flow label, as this would enable correlating activity on multiple paths (see <a href="#migration-linkability" class="xref">Section 9.5</a>).</p>
<p id="rfc.section.9.7.p.3">A possible implementation is to compute the flow label as a cryptographic hash function of the source and destination addresses, source and destination UDP ports, destination CID, and a local secret.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#termination" id="termination">Connection Termination</a>
</h1>
<p id="rfc.section.10.p.1">An established QUIC connection can be terminated in one of three ways:</p>
<p></p>

<ul>
<li>idle timeout (<a href="#idle-timeout" class="xref">Section 10.2</a>)</li>
<li>immediate close (<a href="#immediate-close" class="xref">Section 10.3</a>)</li>
<li>stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>)</li>
</ul>
<p id="rfc.section.10.p.3">An endpoint MAY discard connection state if it does not have a validated path on which it can send packets (see <a href="#migrate-validate" class="xref">Section 8.2</a>).</p>
<h2 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#draining" id="draining">Closing and Draining Connection States</a>
</h2>
<p id="rfc.section.10.1.p.1">The closing and draining connection states exist to ensure that connections close cleanly and that delayed or reordered packets are properly discarded.  These states SHOULD persist for at least three times the current Probe Timeout (PTO) interval as defined in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<p id="rfc.section.10.1.p.2">An endpoint enters a closing period after initiating an immediate close (<a href="#immediate-close" class="xref">Section 10.3</a>).  While closing, an endpoint MUST NOT send packets unless they contain a CONNECTION_CLOSE frame (see <a href="#immediate-close" class="xref">Section 10.3</a> for details).  An endpoint retains only enough information to generate a packet containing a CONNECTION_CLOSE frame and to identify packets as belonging to the connection.  The endpoint&#8217;s selected connection ID and the QUIC version are sufficient information to identify packets for a closing connection; an endpoint can discard all other connection state. An endpoint MAY retain packet protection keys for incoming packets to allow it to read and process a CONNECTION_CLOSE frame.</p>
<p id="rfc.section.10.1.p.3">The draining state is entered once an endpoint receives a signal that its peer is closing or draining.  While otherwise identical to the closing state, an endpoint in the draining state MUST NOT send any packets.  Retaining packet protection keys is unnecessary once a connection is in the draining state.</p>
<p id="rfc.section.10.1.p.4">An endpoint MAY transition from the closing period to the draining period if it receives a CONNECTION_CLOSE frame or stateless reset, both of which indicate that the peer is also closing or draining.  The draining period SHOULD end when the closing period would have ended.  In other words, the endpoint can use the same end time, but cease retransmission of the closing packet.</p>
<p id="rfc.section.10.1.p.5">Disposing of connection state prior to the end of the closing or draining period could cause delayed or reordered packets to be handled poorly.  Endpoints that have some alternative means to ensure that late-arriving packets on the connection do not create QUIC state, such as those that are able to close the UDP socket, MAY use an abbreviated draining period which can allow for faster resource recovery.  Servers that retain an open socket for accepting new connections SHOULD NOT exit the closing or draining period early.</p>
<p id="rfc.section.10.1.p.6">Once the closing or draining period has ended, an endpoint SHOULD discard all connection state.  This results in new packets on the connection being handled generically.  For instance, an endpoint MAY send a stateless reset in response to any further incoming packets.</p>
<p id="rfc.section.10.1.p.7">The draining and closing periods do not apply when a stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) is sent.</p>
<p id="rfc.section.10.1.p.8">An endpoint is not expected to handle key updates when it is closing or draining.  A key update might prevent the endpoint from moving from the closing state to draining, but it otherwise has no impact.</p>
<p id="rfc.section.10.1.p.9">While in the closing period, an endpoint could receive packets from a new source address, indicating a connection migration (<a href="#migration" class="xref">Section 9</a>). An endpoint in the closing state MUST strictly limit the number of packets it sends to this new address until the address is validated (see <a href="#migrate-validate" class="xref">Section 8.2</a>). A server in the closing state MAY instead choose to discard packets received from a new source address.</p>
<h2 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#idle-timeout" id="idle-timeout">Idle Timeout</a>
</h2>
<p id="rfc.section.10.2.p.1">If the idle timeout is enabled, a connection is silently closed and the state is discarded when it remains idle for longer than both the advertised idle timeout (see <a href="#transport-parameter-definitions" class="xref">Section 18.1</a>) and three times the current Probe Timeout (PTO).</p>
<p id="rfc.section.10.2.p.2">Each endpoint advertises its own idle timeout to its peer.  An endpoint restarts any timer it maintains when a packet from its peer is received and processed successfully.  The timer is also restarted when sending a packet containing frames other than ACK or PADDING (an ACK-eliciting packet, see <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>), but only if no other ACK-eliciting packets have been sent since last receiving a packet.  Restarting when sending packets ensures that connections do not prematurely time out when initiating new activity.</p>
<p id="rfc.section.10.2.p.3">The value for an idle timeout can be asymmetric.  The value advertised by an endpoint is only used to determine whether the connection is live at that endpoint.  An endpoint that sends packets near the end of the idle timeout period of a peer risks having those packets discarded if its peer enters the draining state before the packets arrive.  If a peer could timeout within an Probe Timeout (PTO, see Section 6.2.2 of <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>), it is advisable to test for liveness before sending any data that cannot be retried safely.  Note that it is likely that only applications or application protocols will know what information can be retried.</p>
<h2 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> <a href="#immediate-close" id="immediate-close">Immediate Close</a>
</h2>
<p id="rfc.section.10.3.p.1">An endpoint sends a CONNECTION_CLOSE frame (<a href="#frame-connection-close" class="xref">Section 19.19</a>) to terminate the connection immediately.  A CONNECTION_CLOSE frame causes all streams to immediately become closed; open streams can be assumed to be implicitly reset.</p>
<p id="rfc.section.10.3.p.2">After sending a CONNECTION_CLOSE frame, endpoints immediately enter the closing state.  During the closing period, an endpoint that sends a CONNECTION_CLOSE frame SHOULD respond to any packet that it receives with another packet containing a CONNECTION_CLOSE frame.  To minimize the state that an endpoint maintains for a closing connection, endpoints MAY send the exact same packet.  However, endpoints SHOULD limit the number of packets they generate containing a CONNECTION_CLOSE frame.  For instance, an endpoint could progressively increase the number of packets that it receives before sending additional packets or increase the time between packets.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">Allowing retransmission of a closing packet contradicts other advice in this document that recommends the creation of new packet numbers for every packet.  Sending new packet numbers is primarily of advantage to loss recovery and congestion control, which are not expected to be relevant for a closed connection.  Retransmitting the final packet requires less state.</dd>
</dl>
<p id="rfc.section.10.3.p.4">New packets from unverified addresses could be used to create an amplification attack (see <a href="#address-validation" class="xref">Section 8</a>).  To avoid this, endpoints MUST either limit transmission of CONNECTION_CLOSE frames to validated addresses or drop packets without response if the response would be more than three times larger than the received packet.</p>
<p id="rfc.section.10.3.p.5">After receiving a CONNECTION_CLOSE frame, endpoints enter the draining state.  An endpoint that receives a CONNECTION_CLOSE frame MAY send a single packet containing a CONNECTION_CLOSE frame before entering the draining state, using a CONNECTION_CLOSE frame and a NO_ERROR code if appropriate.  An endpoint MUST NOT send further packets, which could result in a constant exchange of CONNECTION_CLOSE frames until the closing period on either peer ended.</p>
<p id="rfc.section.10.3.p.6">An immediate close can be used after an application protocol has arranged to close a connection.  This might be after the application protocols negotiates a graceful shutdown.  The application protocol exchanges whatever messages that are needed to cause both endpoints to agree to close the connection, after which the application requests that the connection be closed.  The application protocol can use an CONNECTION_CLOSE frame with an appropriate error code to signal closure.</p>
<p id="rfc.section.10.3.p.7">If the connection has been successfully established, endpoints MUST send any CONNECTION_CLOSE frames in a 1-RTT packet.  Prior to connection establishment a peer might not have 1-RTT keys, so endpoints SHOULD send CONNECTION_CLOSE frames in a Handshake packet.  If the endpoint does not have Handshake keys, or it is not certain that the peer has Handshake keys, it MAY send CONNECTION_CLOSE frames in an Initial packet.  If multiple packets are sent, they can be coalesced (see <a href="#packet-coalesce" class="xref">Section 12.2</a>) to facilitate retransmission.</p>
<h2 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> <a href="#stateless-reset" id="stateless-reset">Stateless Reset</a>
</h2>
<p id="rfc.section.10.4.p.1">A stateless reset is provided as an option of last resort for an endpoint that does not have access to the state of a connection.  A crash or outage might result in peers continuing to send data to an endpoint that is unable to properly continue the connection.  A stateless reset is not appropriate for signaling error conditions.  An endpoint that wishes to communicate a fatal connection error MUST use a CONNECTION_CLOSE frame if it has sufficient state to do so.</p>
<p id="rfc.section.10.4.p.2">To support this process, a token is sent by endpoints.  The token is carried in the NEW_CONNECTION_ID frame sent by either peer, and servers can specify the stateless_reset_token transport parameter during the handshake (clients cannot because their transport parameters don&#8217;t have confidentiality protection).  This value is protected by encryption, so only client and server know this value.  Tokens are invalidated when their associated connection ID is retired via a RETIRE_CONNECTION_ID frame (<a href="#frame-retire-connection-id" class="xref">Section 19.16</a>).</p>
<p id="rfc.section.10.4.p.3">An endpoint that receives packets that it cannot process sends a packet in the following layout:</p>
<div id="rfc.figure.6"></div>
<div id="fig-stateless-reset"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|1|               Unpredictable Bits (182..)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                   Stateless Reset Token (128)                 +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 6: Stateless Reset Packet</p>
<p id="rfc.section.10.4.p.4">This design ensures that a stateless reset packet is - to the extent possible - indistinguishable from a regular packet with a short header.</p>
<p id="rfc.section.10.4.p.5">A stateless reset uses an entire UDP datagram, starting with the first two bits of the packet header.  The remainder of the first byte and an arbitrary number of bytes following it that are set to unpredictable values.  The last 16 bytes of the datagram contain a Stateless Reset Token.</p>
<p id="rfc.section.10.4.p.6">To entities other than its intended recipient, a stateless reset will be appear to be a packet with a short header.  For the packet to appear as valid, the Unpredictable Bits field needs to include at least 182 bits of data (or 23 bytes, less the two fixed bits).  This is intended to allow for a Destination Connection ID of the maximum length permitted, with a minimal packet number, and payload.  The Stateless Reset Token corresponds to the minimum expansion of the packet protection AEAD.  More unpredictable bytes might be necessary if the endpoint could have negotiated a packet protection scheme with a larger minimum AEAD expansion.</p>
<p id="rfc.section.10.4.p.7">An endpoint SHOULD NOT send a stateless reset that is significantly larger than the packet it receives.  Endpoints MUST discard packets that are too small to be valid QUIC packets.  With the set of AEAD functions defined in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>, packets that are smaller than 21 bytes are never valid.</p>
<p id="rfc.section.10.4.p.8">Endpoints MUST send stateless reset packets formatted as a packet with a short header.  However, endpoints MUST treat any packet ending in a valid stateless reset token as a stateless reset, as other QUIC versions might allow the use of a long header.</p>
<p id="rfc.section.10.4.p.9">An endpoint MAY send a stateless reset in response to a packet with a long header.  Sending a stateless reset is not effective prior to the stateless reset token being available to a peer.  In this QUIC version, packets with a long header are only used during connection establishment.   Because the stateless reset token is not available until connection establishment is complete or near completion, ignoring an unknown packet with a long header might be as effective than sending a stateless reset.</p>
<p id="rfc.section.10.4.p.10">An endpoint cannot determine the Source Connection ID from a packet with a short header, therefore it cannot set the Destination Connection ID in the stateless reset packet.  The Destination Connection ID will therefore differ from the value used in previous packets.  A random Destination Connection ID makes the connection ID appear to be the result of moving to a new connection ID that was provided using a NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).</p>
<p id="rfc.section.10.4.p.11">Using a randomized connection ID results in two problems:</p>
<p></p>

<ul>
<li>The packet might not reach the peer.  If the Destination Connection ID is critical for routing toward the peer, then this packet could be incorrectly routed.  This might also trigger another Stateless Reset in response, see <a href="#reset-looping" class="xref">Section 10.4.3</a>.  A Stateless Reset that is not correctly routed is an ineffective error detection and recovery mechanism.  In this case, endpoints will need to rely on other methods - such as timers - to detect that the connection has failed.</li>
<li>The randomly generated connection ID can be used by entities other than the peer to identify this as a potential stateless reset.  An endpoint that occasionally uses different connection IDs might introduce some uncertainty about this.</li>
</ul>
<p id="rfc.section.10.4.p.13">Finally, the last 16 bytes of the packet are set to the value of the Stateless Reset Token.</p>
<p id="rfc.section.10.4.p.14">This stateless reset design is specific to QUIC version 1.  An endpoint that supports multiple versions of QUIC needs to generate a stateless reset that will be accepted by peers that support any version that the endpoint might support (or might have supported prior to losing state).  Designers of new versions of QUIC need to be aware of this and either reuse this design, or use a portion of the packet other than the last 16 bytes for carrying data.</p>
<h3 id="rfc.section.10.4.1">
<a href="#rfc.section.10.4.1">10.4.1.</a> <a href="#detecting-a-stateless-reset" id="detecting-a-stateless-reset">Detecting a Stateless Reset</a>
</h3>
<p id="rfc.section.10.4.1.p.1">An endpoint detects a potential stateless reset when an incoming packet either cannot be associated with a connection, cannot be decrypted, or is marked as a duplicate packet.  The endpoint MUST then compare the last 16 bytes of the packet with all Stateless Reset Tokens that are associated with connection IDs that are currently in use.  This includes Stateless Reset Tokens from NEW_CONNECTION_ID frames and the server&#8217;s transport parameters.  An endpoint MUST NOT check for any Stateless Reset Tokens associated with connection IDs it has not used or for connection IDs that have been retired.</p>
<p id="rfc.section.10.4.1.p.2">If the last 16 bytes of the packet values are identical to a Stateless Reset Token, the endpoint MUST enter the draining period and not send any further packets on this connection.  If the comparison fails, the packet can be discarded.</p>
<h3 id="rfc.section.10.4.2">
<a href="#rfc.section.10.4.2">10.4.2.</a> <a href="#reset-token" id="reset-token">Calculating a Stateless Reset Token</a>
</h3>
<p id="rfc.section.10.4.2.p.1">The stateless reset token MUST be difficult to guess.  In order to create a Stateless Reset Token, an endpoint could randomly generate <a href="#RFC4086" class="xref">[RFC4086]</a> a secret for every connection that it creates.  However, this presents a coordination problem when there are multiple instances in a cluster or a storage problem for an endpoint that might lose state.  Stateless reset specifically exists to handle the case where state is lost, so this approach is suboptimal.</p>
<p id="rfc.section.10.4.2.p.2">A single static key can be used across all connections to the same endpoint by generating the proof using a second iteration of a preimage-resistant function that takes a static key and the connection ID chosen by the endpoint (see <a href="#connection-id" class="xref">Section 5.1</a>) as input.  An endpoint could use HMAC <a href="#RFC2104" class="xref">[RFC2104]</a> (for example, HMAC(static_key, connection_id)) or HKDF <a href="#RFC5869" class="xref">[RFC5869]</a> (for example, using the static key as input keying material, with the connection ID as salt).  The output of this function is truncated to 16 bytes to produce the Stateless Reset Token for that connection.</p>
<p id="rfc.section.10.4.2.p.3">An endpoint that loses state can use the same method to generate a valid Stateless Reset Token.  The connection ID comes from the packet that the endpoint receives.</p>
<p id="rfc.section.10.4.2.p.4">This design relies on the peer always sending a connection ID in its packets so that the endpoint can use the connection ID from a packet to reset the connection.  An endpoint that uses this design MUST either use the same connection ID length for all connections or encode the length of the connection ID such that it can be recovered without state.  In addition, it cannot provide a zero-length connection ID.</p>
<p id="rfc.section.10.4.2.p.5">Revealing the Stateless Reset Token allows any entity to terminate the connection, so a value can only be used once.  This method for choosing the Stateless Reset Token means that the combination of connection ID and static key MUST NOT be used for another connection.  A denial of service attack is possible if the same connection ID is used by instances that share a static key, or if an attacker can cause a packet to be routed to an instance that has no state but the same static key (see <a href="#reset-oracle" class="xref">Section 21.8</a>).  A connection ID from a connection that is reset by revealing the Stateless Reset Token MUST NOT be reused for new connections at nodes that share a static key.</p>
<p id="rfc.section.10.4.2.p.6">Note that Stateless Reset packets do not have any cryptographic protection.</p>
<h3 id="rfc.section.10.4.3">
<a href="#rfc.section.10.4.3">10.4.3.</a> <a href="#reset-looping" id="reset-looping">Looping</a>
</h3>
<p id="rfc.section.10.4.3.p.1">The design of a Stateless Reset is such that without knowing the stateless reset token it is indistinguishable from a valid packet.  For instance, if a server sends a Stateless Reset to another server it might receive another Stateless Reset in response, which could lead to an infinite exchange.</p>
<p id="rfc.section.10.4.3.p.2">An endpoint MUST ensure that every Stateless Reset that it sends is smaller than the packet which triggered it, unless it maintains state sufficient to prevent looping.  In the event of a loop, this results in packets eventually being too small to trigger a response.</p>
<p id="rfc.section.10.4.3.p.3">An endpoint can remember the number of Stateless Reset packets that it has sent and stop generating new Stateless Reset packets once a limit is reached.  Using separate limits for different remote addresses will ensure that Stateless Reset packets can be used to close connections when other peers or connections have exhausted limits.</p>
<p id="rfc.section.10.4.3.p.4">Reducing the size of a Stateless Reset below the recommended minimum size of 39 bytes could mean that the packet could reveal to an observer that it is a Stateless Reset.  Conversely, refusing to send a Stateless Reset in response to a small packet might result in Stateless Reset not being useful in detecting cases of broken connections where only very small packets are sent; such failures might only be detected by other means, such as timers.</p>
<p id="rfc.section.10.4.3.p.5">An endpoint can increase the odds that a packet will trigger a Stateless Reset if it cannot be processed by padding it to at least 40 bytes.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#error-handling" id="error-handling">Error Handling</a>
</h1>
<p id="rfc.section.11.p.1">An endpoint that detects an error SHOULD signal the existence of that error to its peer.  Both transport-level and application-level errors can affect an entire connection (see <a href="#connection-errors" class="xref">Section 11.1</a>), while only application-level errors can be isolated to a single stream (see <a href="#stream-errors" class="xref">Section 11.2</a>).</p>
<p id="rfc.section.11.p.2">The most appropriate error code (<a href="#error-codes" class="xref">Section 20</a>) SHOULD be included in the frame that signals the error.  Where this specification identifies error conditions, it also identifies the error code that is used.</p>
<p id="rfc.section.11.p.3">A stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) is not suitable for any error that can be signaled with a CONNECTION_CLOSE or RESET_STREAM frame.  A stateless reset MUST NOT be used by an endpoint that has the state necessary to send a frame on the connection.</p>
<h2 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#connection-errors" id="connection-errors">Connection Errors</a>
</h2>
<p id="rfc.section.11.1.p.1">Errors that result in the connection being unusable, such as an obvious violation of protocol semantics or corruption of state that affects an entire connection, MUST be signaled using a CONNECTION_CLOSE frame (<a href="#frame-connection-close" class="xref">Section 19.19</a>). An endpoint MAY close the connection in this manner even if the error only affects a single stream.</p>
<p id="rfc.section.11.1.p.2">Application protocols can signal application-specific protocol errors using the application-specific variant of the CONNECTION_CLOSE frame.  Errors that are specific to the transport, including all those described in this document, are carried the QUIC-specific variant of the CONNECTION_CLOSE frame.</p>
<p id="rfc.section.11.1.p.3">A CONNECTION_CLOSE frame could be sent in a packet that is lost.  An endpoint SHOULD be prepared to retransmit a packet containing a CONNECTION_CLOSE frame if it receives more packets on a terminated connection. Limiting the number of retransmissions and the time over which this final packet is sent limits the effort expended on terminated connections.</p>
<p id="rfc.section.11.1.p.4">An endpoint that chooses not to retransmit packets containing a CONNECTION_CLOSE frame risks a peer missing the first such packet.  The only mechanism available to an endpoint that continues to receive data for a terminated connection is to use the stateless reset process (<a href="#stateless-reset" class="xref">Section 10.4</a>).</p>
<p id="rfc.section.11.1.p.5">An endpoint that receives an invalid CONNECTION_CLOSE frame MUST NOT signal the existence of the error to its peer.</p>
<h2 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> <a href="#stream-errors" id="stream-errors">Stream Errors</a>
</h2>
<p id="rfc.section.11.2.p.1">If an application-level error affects a single stream, but otherwise leaves the connection in a recoverable state, the endpoint can send a RESET_STREAM frame (<a href="#frame-reset-stream" class="xref">Section 19.4</a>) with an appropriate error code to terminate just the affected stream.</p>
<p id="rfc.section.11.2.p.2">RESET_STREAM MUST be instigated by the protocol using QUIC, either directly or through the receipt of a STOP_SENDING frame from a peer.  RESET_STREAM carries an application error code.  Resetting a stream without knowledge of the application protocol could cause the protocol to enter an unrecoverable state.  Application protocols might require certain streams to be reliably delivered in order to guarantee consistent state between endpoints.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#packets-frames" id="packets-frames">Packets and Frames</a>
</h1>
<p id="rfc.section.12.p.1">QUIC endpoints communicate by exchanging packets. Packets have confidentiality and integrity protection (see <a href="#packet-protected" class="xref">Section 12.1</a>) and are carried in UDP datagrams (see <a href="#packet-coalesce" class="xref">Section 12.2</a>).</p>
<p id="rfc.section.12.p.2">This version of QUIC uses the long packet header (see <a href="#long-header" class="xref">Section 17.2</a>) during connection establishment.  Packets with the long header are Initial (<a href="#packet-initial" class="xref">Section 17.2.2</a>), 0-RTT (<a href="#packet-0rtt" class="xref">Section 17.2.3</a>), Handshake (<a href="#packet-handshake" class="xref">Section 17.2.4</a>), and Retry (<a href="#packet-retry" class="xref">Section 17.2.5</a>).  Version negotiation uses a version-independent packet with a long header (see <a href="#packet-version" class="xref">Section 17.2.1</a>).</p>
<p id="rfc.section.12.p.3">Packets with the short header (<a href="#short-header" class="xref">Section 17.3</a>) are designed for minimal overhead and are used after a connection is established and 1-RTT keys are available.</p>
<h2 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#packet-protected" id="packet-protected">Protected Packets</a>
</h2>
<p id="rfc.section.12.1.p.1">All QUIC packets except Version Negotiation and Retry packets use authenticated encryption with additional data (AEAD) <a href="#RFC5116" class="xref">[RFC5116]</a> to provide confidentiality and integrity protection. Details of packet protection are found in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>; this section includes an overview of the process.</p>
<p id="rfc.section.12.1.p.2">Initial packets are protected using keys that are statically derived. This packet protection is not effective confidentiality protection.  Initial protection only exists to ensure that the sender of the packet is on the network path. Any entity that receives the Initial packet from a client can recover the keys necessary to remove packet protection or to generate packets that will be successfully authenticated.</p>
<p id="rfc.section.12.1.p.3">All other packets are protected with keys derived from the cryptographic handshake. The type of the packet from the long header or key phase from the short header are used to identify which encryption level - and therefore the keys - that are used. Packets protected with 0-RTT and 1-RTT keys are expected to have confidentiality and data origin authentication; the cryptographic handshake ensures that only the communicating endpoints receive the corresponding keys.</p>
<p id="rfc.section.12.1.p.4">The packet number field contains a packet number, which has additional confidentiality protection that is applied after packet protection is applied (see <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> for details).  The underlying packet number increases with each packet sent in a given packet number space, see <a href="#packet-numbers" class="xref">Section 12.3</a> for details.</p>
<h2 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#packet-coalesce" id="packet-coalesce">Coalescing Packets</a>
</h2>
<p id="rfc.section.12.2.p.1">Initial (<a href="#packet-initial" class="xref">Section 17.2.2</a>), 0-RTT (<a href="#packet-0rtt" class="xref">Section 17.2.3</a>), and Handshake (<a href="#packet-handshake" class="xref">Section 17.2.4</a>) packets contain a Length field, which determines the end of the packet.  The length includes both the Packet Number and Payload fields, both of which are confidentiality protected and initially of unknown length. The length of the Payload field is learned once header protection is removed.</p>
<p id="rfc.section.12.2.p.2">Using the Length field, a sender can coalesce multiple QUIC packets into one UDP datagram.  This can reduce the number of UDP datagrams needed to complete the cryptographic handshake and starting sending data.  Receivers MUST be able to process coalesced packets.</p>
<p id="rfc.section.12.2.p.3">Coalescing packets in order of increasing encryption levels (Initial, 0-RTT, Handshake, 1-RTT) makes it more likely the receiver will be able to process all the packets in a single pass.  A packet with a short header does not include a length, so it can only be the last packet included in a UDP datagram.</p>
<p id="rfc.section.12.2.p.4">Senders MUST NOT coalesce QUIC packets for different connections into a single UDP datagram. Receivers SHOULD ignore any subsequent packets with a different Destination Connection ID than the first packet in the datagram.</p>
<p id="rfc.section.12.2.p.5">Every QUIC packet that is coalesced into a single UDP datagram is separate and complete.  Though the values of some fields in the packet header might be redundant, no fields are omitted.  The receiver of coalesced QUIC packets MUST individually process each QUIC packet and separately acknowledge them, as if they were received as the payload of different UDP datagrams.  For example, if decryption fails (because the keys are not available or any other reason), the receiver MAY either discard or buffer the packet for later processing and MUST attempt to process the remaining packets.</p>
<p id="rfc.section.12.2.p.6">Retry packets (<a href="#packet-retry" class="xref">Section 17.2.5</a>), Version Negotiation packets (<a href="#packet-version" class="xref">Section 17.2.1</a>), and packets with a short header (<a href="#short-header" class="xref">Section 17.3</a>) do not contain a Length field and so cannot be followed by other packets in the same UDP datagram.</p>
<h2 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> <a href="#packet-numbers" id="packet-numbers">Packet Numbers</a>
</h2>
<p id="rfc.section.12.3.p.1">The packet number is an integer in the range 0 to 2^62-1.  This number is used in determining the cryptographic nonce for packet protection.  Each endpoint maintains a separate packet number for sending and receiving.</p>
<p id="rfc.section.12.3.p.2">Packet numbers are limited to this range because they need to be representable in whole in the Largest Acknowledged field of an ACK frame (<a href="#frame-ack" class="xref">Section 19.3</a>).  When present in a long or short header however, packet numbers are reduced and encoded in 1 to 4 bytes (see <a href="#packet-encoding" class="xref">Section 17.1</a>).</p>
<p id="rfc.section.12.3.p.3">Version Negotiation (<a href="#packet-version" class="xref">Section 17.2.1</a>) and Retry (<a href="#packet-retry" class="xref">Section 17.2.5</a>) packets do not include a packet number.</p>
<p id="rfc.section.12.3.p.4">Packet numbers are divided into 3 spaces in QUIC:</p>
<p></p>

<ul>
<li>Initial space: All Initial packets (<a href="#packet-initial" class="xref">Section 17.2.2</a>) are in this space.</li>
<li>Handshake space: All Handshake packets (<a href="#packet-handshake" class="xref">Section 17.2.4</a>) are in this space.</li>
<li>Application data space: All 0-RTT and 1-RTT encrypted packets (<a href="#packet-protected" class="xref">Section 12.1</a>) are in this space.</li>
</ul>
<p id="rfc.section.12.3.p.6">As described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>, each packet type uses different protection keys.</p>
<p id="rfc.section.12.3.p.7">Conceptually, a packet number space is the context in which a packet can be processed and acknowledged.  Initial packets can only be sent with Initial packet protection keys and acknowledged in packets which are also Initial packets.  Similarly, Handshake packets are sent at the Handshake encryption level and can only be acknowledged in Handshake packets.</p>
<p id="rfc.section.12.3.p.8">This enforces cryptographic separation between the data sent in the different packet sequence number spaces.  Packet numbers in each space start at packet number 0.  Subsequent packets sent in the same packet number space MUST increase the packet number by at least one.</p>
<p id="rfc.section.12.3.p.9">0-RTT and 1-RTT data exist in the same packet number space to make loss recovery algorithms easier to implement between the two packet types.</p>
<p id="rfc.section.12.3.p.10">A QUIC endpoint MUST NOT reuse a packet number within the same packet number space in one connection.  If the packet number for sending reaches 2^62 - 1, the sender MUST close the connection without sending a CONNECTION_CLOSE frame or any further packets; an endpoint MAY send a Stateless Reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) in response to further packets that it receives.</p>
<p id="rfc.section.12.3.p.11">A receiver MUST discard a newly unprotected packet unless it is certain that it has not processed another packet with the same packet number from the same packet number space. Duplicate suppression MUST happen after removing packet protection for the reasons described in Section 9.3 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>. An efficient algorithm for duplicate suppression can be found in Section 3.4.3 of <a href="#RFC4303" class="xref">[RFC4303]</a>.</p>
<p id="rfc.section.12.3.p.12">Packet number encoding at a sender and decoding at a receiver are described in <a href="#packet-encoding" class="xref">Section 17.1</a>.</p>
<h2 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> <a href="#frames" id="frames">Frames and Frame Types</a>
</h2>
<p id="rfc.section.12.4.p.1">The payload of QUIC packets, after removing packet protection, consists of a sequence of complete frames, as shown in <a href="#packet-frames" class="xref">Figure 7</a>.  Version Negotiation, Stateless Reset, and Retry packets do not contain frames.</p>
<div id="rfc.figure.7"></div>
<div id="packet-frames"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 1 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 2 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame N (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 7: QUIC Payload</p>
<p id="rfc.section.12.4.p.2">The payload of a packet that contains frames MUST contain at least one frame, and MAY contain multiple frames and multiple frame types.  Frames always fit within a single QUIC packet and cannot span multiple packets.</p>
<p id="rfc.section.12.4.p.3">Each frame begins with a Frame Type, indicating its type, followed by additional type-dependent fields:</p>
<div id="rfc.figure.8"></div>
<div id="frame-layout"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Frame Type (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Type-Dependent Fields (*)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 8: Generic Frame Layout</p>
<p id="rfc.section.12.4.p.4">The frame types defined in this specification are listed in <a href="#frame-types" class="xref">Table 3</a>.  The Frame Type in ACK, STREAM, MAX_STREAMS, STREAMS_BLOCKED, and CONNECTION_CLOSE frames is used to carry other frame-specific flags. For all other frames, the Frame Type field simply identifies the frame.  These frames are explained in more detail in <a href="#frame-formats" class="xref">Section 19</a>.</p>
<div id="rfc.table.3"></div>
<div id="frame-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Frame Types</caption>
<thead><tr>
<th class="left">Type Value</th>
<th class="left">Frame Type Name</th>
<th class="left">Definition</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x00</td>
<td class="left">PADDING</td>
<td class="left"><a href="#frame-padding" class="xref">Section 19.1</a></td>
</tr>
<tr>
<td class="left">0x01</td>
<td class="left">PING</td>
<td class="left"><a href="#frame-ping" class="xref">Section 19.2</a></td>
</tr>
<tr>
<td class="left">0x02 - 0x03</td>
<td class="left">ACK</td>
<td class="left"><a href="#frame-ack" class="xref">Section 19.3</a></td>
</tr>
<tr>
<td class="left">0x04</td>
<td class="left">RESET_STREAM</td>
<td class="left"><a href="#frame-reset-stream" class="xref">Section 19.4</a></td>
</tr>
<tr>
<td class="left">0x05</td>
<td class="left">STOP_SENDING</td>
<td class="left"><a href="#frame-stop-sending" class="xref">Section 19.5</a></td>
</tr>
<tr>
<td class="left">0x06</td>
<td class="left">CRYPTO</td>
<td class="left"><a href="#frame-crypto" class="xref">Section 19.6</a></td>
</tr>
<tr>
<td class="left">0x07</td>
<td class="left">NEW_TOKEN</td>
<td class="left"><a href="#frame-new-token" class="xref">Section 19.7</a></td>
</tr>
<tr>
<td class="left">0x08 - 0x0f</td>
<td class="left">STREAM</td>
<td class="left"><a href="#frame-stream" class="xref">Section 19.8</a></td>
</tr>
<tr>
<td class="left">0x10</td>
<td class="left">MAX_DATA</td>
<td class="left"><a href="#frame-max-data" class="xref">Section 19.9</a></td>
</tr>
<tr>
<td class="left">0x11</td>
<td class="left">MAX_STREAM_DATA</td>
<td class="left"><a href="#frame-max-stream-data" class="xref">Section 19.10</a></td>
</tr>
<tr>
<td class="left">0x12 - 0x13</td>
<td class="left">MAX_STREAMS</td>
<td class="left"><a href="#frame-max-streams" class="xref">Section 19.11</a></td>
</tr>
<tr>
<td class="left">0x14</td>
<td class="left">DATA_BLOCKED</td>
<td class="left"><a href="#frame-data-blocked" class="xref">Section 19.12</a></td>
</tr>
<tr>
<td class="left">0x15</td>
<td class="left">STREAM_DATA_BLOCKED</td>
<td class="left"><a href="#frame-stream-data-blocked" class="xref">Section 19.13</a></td>
</tr>
<tr>
<td class="left">0x16 - 0x17</td>
<td class="left">STREAMS_BLOCKED</td>
<td class="left"><a href="#frame-streams-blocked" class="xref">Section 19.14</a></td>
</tr>
<tr>
<td class="left">0x18</td>
<td class="left">NEW_CONNECTION_ID</td>
<td class="left"><a href="#frame-new-connection-id" class="xref">Section 19.15</a></td>
</tr>
<tr>
<td class="left">0x19</td>
<td class="left">RETIRE_CONNECTION_ID</td>
<td class="left"><a href="#frame-retire-connection-id" class="xref">Section 19.16</a></td>
</tr>
<tr>
<td class="left">0x1a</td>
<td class="left">PATH_CHALLENGE</td>
<td class="left"><a href="#frame-path-challenge" class="xref">Section 19.17</a></td>
</tr>
<tr>
<td class="left">0x1b</td>
<td class="left">PATH_RESPONSE</td>
<td class="left"><a href="#frame-path-response" class="xref">Section 19.18</a></td>
</tr>
<tr>
<td class="left">0x1c - 0x1d</td>
<td class="left">CONNECTION_CLOSE</td>
<td class="left"><a href="#frame-connection-close" class="xref">Section 19.19</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.12.4.p.5">An endpoint MUST treat the receipt of a frame of unknown type as a connection error of type FRAME_ENCODING_ERROR.</p>
<p id="rfc.section.12.4.p.6">All QUIC frames are idempotent in this version of QUIC.  That is, a valid frame does not cause undesirable side effects or errors when received more than once.</p>
<p id="rfc.section.12.4.p.7">The Frame Type field uses a variable length integer encoding (see <a href="#integer-encoding" class="xref">Section 16</a>) with one exception.  To ensure simple and efficient implementations of frame parsing, a frame type MUST use the shortest possible encoding.  Though a two-, four- or eight-byte encoding of the frame types defined in this document is possible, the Frame Type field for these frames is encoded on a single byte.  For instance, though 0x4001 is a legitimate two-byte encoding for a variable-length integer with a value of 1, PING frames are always encoded as a single byte with the value 0x01.  An endpoint MAY treat the receipt of a frame type that uses a longer encoding than necessary as a connection error of type PROTOCOL_VIOLATION.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#packetization" id="packetization">Packetization and Reliability</a>
</h1>
<p id="rfc.section.13.p.1">A sender bundles one or more frames in a QUIC packet (see <a href="#frames" class="xref">Section 12.4</a>).</p>
<p id="rfc.section.13.p.2">A sender can minimize per-packet bandwidth and computational costs by bundling as many frames as possible within a QUIC packet.  A sender MAY wait for a short period of time to bundle multiple frames before sending a packet that is not maximally packed, to avoid sending out large numbers of small packets.  An implementation MAY use knowledge about application sending behavior or heuristics to determine whether and for how long to wait.  This waiting period is an implementation decision, and an implementation should be careful to delay conservatively, since any delay is likely to increase application-visible latency.</p>
<p id="rfc.section.13.p.3">Stream multiplexing is achieved by interleaving STREAM frames from multiple streams into one or more QUIC packets.  A single QUIC packet can include multiple STREAM frames from one or more streams.</p>
<p id="rfc.section.13.p.4">One of the benefits of QUIC is avoidance of head-of-line blocking across multiple streams.  When a packet loss occurs, only streams with data in that packet are blocked waiting for a retransmission to be received, while other streams can continue making progress.  Note that when data from multiple streams is bundled into a single QUIC packet, loss of that packet blocks all those streams from making progress.  Implementations are advised to bundle as few streams as necessary in outgoing packets without losing transmission efficiency to underfilled packets.</p>
<h2 id="rfc.section.13.1">
<a href="#rfc.section.13.1">13.1.</a> <a href="#processing-and-ack" id="processing-and-ack">Packet Processing and Acknowledgment</a>
</h2>
<p id="rfc.section.13.1.p.1">A packet MUST NOT be acknowledged until packet protection has been successfully removed and all frames contained in the packet have been processed.  For STREAM frames, this means the data has been enqueued in preparation to be received by the application protocol, but it does not require that data is delivered and consumed.</p>
<p id="rfc.section.13.1.p.2">Once the packet has been fully processed, a receiver acknowledges receipt by sending one or more ACK frames containing the packet number of the received packet.</p>
<h3 id="rfc.section.13.1.1">
<a href="#rfc.section.13.1.1">13.1.1.</a> <a href="#sending-ack-frames" id="sending-ack-frames">Sending ACK Frames</a>
</h3>
<p id="rfc.section.13.1.1.p.1">An endpoint MUST NOT send more than one packet containing only an ACK frame per received packet that contains frames other than ACK and PADDING frames.  An endpoint MUST NOT send a packet containing only an ACK frame in response to a packet containing only ACK or PADDING frames, even if there are packet gaps which precede the received packet. This prevents an indefinite feedback loop of ACKs. The endpoint MUST however acknowledge packets containing only ACK or PADDING frames when sending ACK frames in response to other packets.</p>
<p id="rfc.section.13.1.1.p.2">Packets containing PADDING frames are considered to be in flight for congestion control purposes <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>. Sending only PADDING frames might cause the sender to become limited by the congestion controller (as described in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>) with no acknowledgments forthcoming from the receiver. Therefore, a sender SHOULD ensure that other frames are sent in addition to PADDING frames to elicit acknowledgments from the receiver.</p>
<p id="rfc.section.13.1.1.p.3">The receiver&#8217;s delayed acknowledgment timer SHOULD NOT exceed the current RTT estimate or the value it indicates in the <samp>max_ack_delay</samp> transport parameter.  This ensures an acknowledgment is sent at least once per RTT when packets needing acknowledgement are received.  The sender can use the receiver&#8217;s <samp>max_ack_delay</samp> value in determining timeouts for timer-based retransmission.</p>
<p id="rfc.section.13.1.1.p.4">Strategies and implications of the frequency of generating acknowledgments are discussed in more detail in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<p id="rfc.section.13.1.1.p.5">To limit ACK Ranges (see <a href="#ack-ranges" class="xref">Section 19.3.1</a>) to those that have not yet been received by the sender, the receiver SHOULD track which ACK frames have been acknowledged by its peer. The receiver SHOULD exclude already acknowledged packets from future ACK frames whenever these packets would unnecessarily contribute to the ACK frame size.</p>
<p id="rfc.section.13.1.1.p.6">Because ACK frames are not sent in response to ACK-only packets, a receiver that is only sending ACK frames will only receive acknowledgements for its packets if the sender includes them in packets with non-ACK frames.  A sender SHOULD bundle ACK frames with other frames when possible.</p>
<p id="rfc.section.13.1.1.p.7">To limit receiver state or the size of ACK frames, a receiver MAY limit the number of ACK Ranges it sends.  A receiver can do this even without receiving acknowledgment of its ACK frames, with the knowledge this could cause the sender to unnecessarily retransmit some data.  Standard QUIC <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a> algorithms declare packets lost after sufficiently newer packets are acknowledged.  Therefore, the receiver SHOULD repeatedly acknowledge newly received packets in preference to packets received in the past.</p>
<p id="rfc.section.13.1.1.p.8">An endpoint SHOULD treat receipt of an acknowledgment for a packet it did not send as a connection error of type PROTOCOL_VIOLATION, if it is able to detect the condition.</p>
<h3 id="rfc.section.13.1.2">
<a href="#rfc.section.13.1.2">13.1.2.</a> <a href="#ack-frames-and-packet-protection" id="ack-frames-and-packet-protection">ACK Frames and Packet Protection</a>
</h3>
<p id="rfc.section.13.1.2.p.1">ACK frames MUST only be carried in a packet that has the same packet number space as the packet being ACKed (see <a href="#packet-protected" class="xref">Section 12.1</a>). For instance, packets that are protected with 1-RTT keys MUST be acknowledged in packets that are also protected with 1-RTT keys.</p>
<p id="rfc.section.13.1.2.p.2">Packets that a client sends with 0-RTT packet protection MUST be acknowledged by the server in packets protected by 1-RTT keys.  This can mean that the client is unable to use these acknowledgments if the server cryptographic handshake messages are delayed or lost.  Note that the same limitation applies to other data sent by the server protected by the 1-RTT keys.</p>
<p id="rfc.section.13.1.2.p.3">Endpoints SHOULD send acknowledgments for packets containing CRYPTO frames with a reduced delay; see Section 6.2.1 of <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.13.2">
<a href="#rfc.section.13.2">13.2.</a> <a href="#retransmission-of-information" id="retransmission-of-information">Retransmission of Information</a>
</h2>
<p id="rfc.section.13.2.p.1">QUIC packets that are determined to be lost are not retransmitted whole. The same applies to the frames that are contained within lost packets. Instead, the information that might be carried in frames is sent again in new frames as needed.</p>
<p id="rfc.section.13.2.p.2">New frames and packets are used to carry information that is determined to have been lost.  In general, information is sent again when a packet containing that information is determined to be lost and sending ceases when a packet containing that information is acknowledged.</p>
<p></p>

<ul>
<li>Data sent in CRYPTO frames is retransmitted according to the rules in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>, until all data has been acknowledged.  Data in CRYPTO frames for Initial and Handshake packets is discarded when keys for the corresponding encryption level are discarded.</li>
<li>Application data sent in STREAM frames is retransmitted in new STREAM frames unless the endpoint has sent a RESET_STREAM for that stream.  Once an endpoint sends a RESET_STREAM frame, no further STREAM frames are needed.</li>
<li>The most recent set of acknowledgments are sent in ACK frames.  An ACK frame SHOULD contain all unacknowledged acknowledgments, as described in <a href="#sending-ack-frames" class="xref">Section 13.1.1</a>.</li>
<li>Cancellation of stream transmission, as carried in a RESET_STREAM frame, is sent until acknowledged or until all stream data is acknowledged by the peer (that is, either the &#8220;Reset Recvd&#8221; or &#8220;Data Recvd&#8221; state is reached on the sending part of the stream). The content of a RESET_STREAM frame MUST NOT change when it is sent again.</li>
<li>Similarly, a request to cancel stream transmission, as encoded in a STOP_SENDING frame, is sent until the receiving part of the stream enters either a &#8220;Data Recvd&#8221; or &#8220;Reset Recvd&#8221; state, see <a href="#solicited-state-transitions" class="xref">Section 3.5</a>.</li>
<li>Connection close signals, including packets that contain CONNECTION_CLOSE frames, are not sent again when packet loss is detected, but as described in <a href="#termination" class="xref">Section 10</a>.</li>
<li>The current connection maximum data is sent in MAX_DATA frames. An updated value is sent in a MAX_DATA frame if the packet containing the most recently sent MAX_DATA frame is declared lost, or when the endpoint decides to update the limit.  Care is necessary to avoid sending this frame too often as the limit can increase frequently and cause an unnecessarily large number of MAX_DATA frames to be sent.</li>
<li>The current maximum stream data offset is sent in MAX_STREAM_DATA frames.  Like MAX_DATA, an updated value is sent when the packet containing the most recent MAX_STREAM_DATA frame for a stream is lost or when the limit is updated, with care taken to prevent the frame from being sent too often. An endpoint SHOULD stop sending MAX_STREAM_DATA frames when the receiving part of the stream enters a &#8220;Size Known&#8221; state.</li>
<li>The limit on streams of a given type is sent in MAX_STREAMS frames.  Like MAX_DATA, an updated value is sent when a packet containing the most recent MAX_STREAMS for a stream type frame is declared lost or when the limit is updated, with care taken to prevent the frame from being sent too often.</li>
<li>Blocked signals are carried in DATA_BLOCKED, STREAM_DATA_BLOCKED, and STREAMS_BLOCKED frames. DATA_BLOCKED frames have connection scope, STREAM_DATA_BLOCKED frames have stream scope, and STREAMS_BLOCKED frames are scoped to a specific stream type. New frames are sent if packets containing the most recent frame for a scope is lost, but only while the endpoint is blocked on the corresponding limit. These frames always include the limit that is causing blocking at the time that they are transmitted.</li>
<li>A liveness or path validation check using PATH_CHALLENGE frames is sent periodically until a matching PATH_RESPONSE frame is received or until there is no remaining need for liveness or path validation checking. PATH_CHALLENGE frames include a different payload each time they are sent.</li>
<li>Responses to path validation using PATH_RESPONSE frames are sent just once.  A new PATH_CHALLENGE frame will be sent if another PATH_RESPONSE frame is needed.</li>
<li>New connection IDs are sent in NEW_CONNECTION_ID frames and retransmitted if the packet containing them is lost.  Retransmissions of this frame carry the same sequence number value.  Likewise, retired connection IDs are sent in RETIRE_CONNECTION_ID frames and retransmitted if the packet containing them is lost.</li>
<li>PING and PADDING frames contain no information, so lost PING or PADDING frames do not require repair.</li>
</ul>
<p id="rfc.section.13.2.p.4">Endpoints SHOULD prioritize retransmission of data over sending new data, unless priorities specified by the application indicate otherwise (see <a href="#stream-prioritization" class="xref">Section 2.3</a>).</p>
<p id="rfc.section.13.2.p.5">Even though a sender is encouraged to assemble frames containing up-to-date information every time it sends a packet, it is not forbidden to retransmit copies of frames from lost packets.  A receiver MUST accept packets containing an outdated frame, such as a MAX_DATA frame carrying a smaller maximum data than one found in an older packet.</p>
<p id="rfc.section.13.2.p.6">Upon detecting losses, a sender MUST take appropriate congestion control action.  The details of loss detection and congestion control are described in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.13.3">
<a href="#rfc.section.13.3">13.3.</a> <a href="#ecn" id="ecn">Explicit Congestion Notification</a>
</h2>
<p id="rfc.section.13.3.p.1">QUIC endpoints can use Explicit Congestion Notification (ECN) <a href="#RFC3168" class="xref">[RFC3168]</a> to detect and respond to network congestion.  ECN allows a network node to indicate congestion in the network by setting a codepoint in the IP header of a packet instead of dropping it.  Endpoints react to congestion by reducing their sending rate in response, as described in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<p id="rfc.section.13.3.p.2">To use ECN, QUIC endpoints first determine whether a path supports ECN marking and the peer is able to access the ECN codepoint in the IP header.  A network path does not support ECN if ECN marked packets get dropped or ECN markings are rewritten on the path. An endpoint verifies the path, both during connection establishment and when migrating to a new path (see <a href="#migration" class="xref">Section 9</a>).</p>
<h3 id="rfc.section.13.3.1">
<a href="#rfc.section.13.3.1">13.3.1.</a> <a href="#ecn-counts" id="ecn-counts">ECN Counts</a>
</h3>
<p id="rfc.section.13.3.1.p.1">On receiving a QUIC packet with an ECT or CE codepoint, an ECN-enabled endpoint that can access the ECN codepoints from the enclosing IP packet increases the corresponding ECT(0), ECT(1), or CE count, and includes these counts in subsequent ACK frames (see <a href="#processing-and-ack" class="xref">Section 13.1</a> and <a href="#frame-ack" class="xref">Section 19.3</a>).  Note that this requires being able to read the ECN codepoints from the enclosing IP packet, which is not possible on all platforms.</p>
<p id="rfc.section.13.3.1.p.2">A packet detected by a receiver as a duplicate does not affect the receiver&#8217;s local ECN codepoint counts; see (<a href="#security-ecn" class="xref">Section 21.7</a>) for relevant security concerns.</p>
<p id="rfc.section.13.3.1.p.3">If an endpoint receives a QUIC packet without an ECT or CE codepoint in the IP packet header, it responds per <a href="#processing-and-ack" class="xref">Section 13.1</a> with an ACK frame without increasing any ECN counts.  If an endpoint does not implement ECN support or does not have access to received ECN codepoints, it does not increase ECN counts.</p>
<p id="rfc.section.13.3.1.p.4">Coalesced packets (see <a href="#packet-coalesce" class="xref">Section 12.2</a>) mean that several packets can share the same IP header.  The ECN counter for the ECN codepoint received in the associated IP header are incremented once for each QUIC packet, not per enclosing IP packet or UDP datagram.</p>
<p id="rfc.section.13.3.1.p.5">Each packet number space maintains separate acknowledgement state and separate ECN counts.  For example, if one each of an Initial, 0-RTT, Handshake, and 1-RTT QUIC packet are coalesced, the corresponding counts for the Initial and Handshake packet number space will be incremented by one and the counts for the 1-RTT packet number space will be increased by two.</p>
<h3 id="rfc.section.13.3.2">
<a href="#rfc.section.13.3.2">13.3.2.</a> <a href="#ecn-verification" id="ecn-verification">ECN Verification</a>
</h3>
<p id="rfc.section.13.3.2.p.1">Each endpoint independently verifies and enables use of ECN by setting the IP header ECN codepoint to ECN Capable Transport (ECT) for the path from it to the other peer. Even if not setting ECN codepoints on packets it transmits, the endpoint SHOULD provide feedback about ECN markings received (if accessible).</p>
<p id="rfc.section.13.3.2.p.2">To verify both that a path supports ECN and the peer can provide ECN feedback, an endpoint sets the ECT(0) codepoint in the IP header of all outgoing packets <a href="#RFC8311" class="xref">[RFC8311]</a>.</p>
<p id="rfc.section.13.3.2.p.3">If an ECT codepoint set in the IP header is not corrupted by a network device, then a received packet contains either the codepoint sent by the peer or the Congestion Experienced (CE) codepoint set by a network device that is experiencing congestion.</p>
<p id="rfc.section.13.3.2.p.4">If a QUIC packet sent with an ECT codepoint is newly acknowledged by the peer in an ACK frame without ECN feedback, the endpoint stops setting ECT codepoints in subsequent IP packets, with the expectation that either the network path or the peer no longer supports ECN.</p>
<p id="rfc.section.13.3.2.p.5">Network devices that corrupt or apply non-standard ECN markings might result in reduced throughput or other undesirable side-effects.  To reduce this risk, an endpoint uses the following steps to verify the counts it receives in an ACK frame.</p>
<p></p>

<ul>
<li>The total increase in ECT(0), ECT(1), and CE counts MUST be no smaller than the total number of QUIC packets sent with an ECT codepoint that are newly acknowledged in this ACK frame.  This step detects any network remarking from ECT(0), ECT(1), or CE codepoints to Not-ECT.</li>
<li>Any increase in either ECT(0) or ECT(1) counts, plus any increase in the CE count, MUST be no smaller than the number of packets sent with the corresponding ECT codepoint that are newly acknowledged in this ACK frame.  This step detects any erroneous network remarking from ECT(0) to ECT(1) (or vice versa).</li>
</ul>
<p id="rfc.section.13.3.2.p.7">An endpoint could miss acknowledgements for a packet when ACK frames are lost.  It is therefore possible for the total increase in ECT(0), ECT(1), and CE counts to be greater than the number of packets acknowledged in an ACK frame.  When this happens, and if verification succeeds, the local reference counts MUST be increased to match the counts in the ACK frame.</p>
<p id="rfc.section.13.3.2.p.8">Processing counts out of order can result in verification failure.  An endpoint SHOULD NOT perform this verification if the ACK frame is received in a packet with packet number lower than a previously received ACK frame.  Verifying based on ACK frames that arrive out of order can result in disabling ECN unnecessarily.</p>
<p id="rfc.section.13.3.2.p.9">Upon successful verification, an endpoint continues to set ECT codepoints in subsequent packets with the expectation that the path is ECN-capable.</p>
<p id="rfc.section.13.3.2.p.10">If verification fails, then the endpoint ceases setting ECT codepoints in subsequent IP packets with the expectation that either the network path or the peer does not support ECN.</p>
<p id="rfc.section.13.3.2.p.11">If an endpoint sets ECT codepoints on outgoing IP packets and encounters a retransmission timeout due to the absence of acknowledgments from the peer (see <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>), or if an endpoint has reason to believe that an element on the network path might be corrupting ECN codepoints, the endpoint MAY cease setting ECT codepoints in subsequent packets.  Doing so allows the connection to be resilient to network elements that corrupt ECN codepoints in the IP header or drop packets with ECT or CE codepoints in the IP header.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#packet-size" id="packet-size">Packet Size</a>
</h1>
<p id="rfc.section.14.p.1">The QUIC packet size includes the QUIC header and protected payload, but not the UDP or IP header.</p>
<p id="rfc.section.14.p.2">Clients MUST ensure they send the first Initial packet in a single IP packet.  Similarly, the first Initial packet sent after receiving a Retry packet MUST be sent in a single IP packet.</p>
<p id="rfc.section.14.p.3">The payload of a UDP datagram carrying the first Initial packet MUST be expanded to at least 1200 bytes, by adding PADDING frames to the Initial packet and/or by combining the Initial packet with a 0-RTT packet (see <a href="#packet-coalesce" class="xref">Section 12.2</a>).  Sending a UDP datagram of this size ensures that the network path supports a reasonable Maximum Transmission Unit (MTU), and helps reduce the amplitude of amplification attacks caused by server responses toward an unverified client address, see <a href="#address-validation" class="xref">Section 8</a>.</p>
<p id="rfc.section.14.p.4">The datagram containing the first Initial packet from a client MAY exceed 1200 bytes if the client believes that the Path Maximum Transmission Unit (PMTU) supports the size that it chooses.</p>
<p id="rfc.section.14.p.5">A server MAY send a CONNECTION_CLOSE frame with error code PROTOCOL_VIOLATION in response to the first Initial packet it receives from a client if the UDP datagram is smaller than 1200 bytes. It MUST NOT send any other frame type in response, or otherwise behave as if any part of the offending packet was processed as valid.</p>
<p id="rfc.section.14.p.6">The server MUST also limit the number of bytes it sends before validating the address of the client, see <a href="#address-validation" class="xref">Section 8</a>.</p>
<h2 id="rfc.section.14.1">
<a href="#rfc.section.14.1">14.1.</a> <a href="#path-maximum-transmission-unit-pmtu" id="path-maximum-transmission-unit-pmtu">Path Maximum Transmission Unit (PMTU)</a>
</h2>
<p id="rfc.section.14.1.p.1">The PMTU is the maximum size of the entire IP packet including the IP header, UDP header, and UDP payload.  The UDP payload includes the QUIC packet header, protected payload, and any authentication fields. The PMTU can depend upon the current path characteristics.  Therefore, the current largest UDP payload an implementation will send is referred to as the QUIC maximum packet size.</p>
<p id="rfc.section.14.1.p.2">QUIC depends on a PMTU of at least 1280 bytes. This is the IPv6 minimum size <a href="#RFC8200" class="xref">[RFC8200]</a> and is also supported by most modern IPv4 networks.  All QUIC packets (except for PMTU probe packets) SHOULD be sized to fit within the maximum packet size to avoid the packet being fragmented or dropped <a href="#RFC8085" class="xref">[RFC8085]</a>.</p>
<p id="rfc.section.14.1.p.3">An endpoint SHOULD use Datagram Packetization Layer PMTU Discovery (<a href="#DPLPMTUD" class="xref">[DPLPMTUD]</a>) or implement Path MTU Discovery (PMTUD) <a href="#RFC1191" class="xref">[RFC1191]</a> <a href="#RFC8201" class="xref">[RFC8201]</a> to determine whether the path to a destination will support a desired message size without fragmentation.</p>
<p id="rfc.section.14.1.p.4">In the absence of these mechanisms, QUIC endpoints SHOULD NOT send IP packets larger than 1280 bytes. Assuming the minimum IP header size, this results in a QUIC maximum packet size of 1232 bytes for IPv6 and 1252 bytes for IPv4. A QUIC implementation MAY be more conservative in computing the QUIC maximum packet size to allow for unknown tunnel overheads or IP header options/extensions.</p>
<p id="rfc.section.14.1.p.5">Each pair of local and remote addresses could have a different PMTU.  QUIC implementations that implement any kind of PMTU discovery therefore SHOULD maintain a maximum packet size for each combination of local and remote IP addresses.</p>
<p id="rfc.section.14.1.p.6">If a QUIC endpoint determines that the PMTU between any pair of local and remote IP addresses has fallen below the size needed to support the smallest allowed maximum packet size, it MUST immediately cease sending QUIC packets, except for PMTU probe packets, on the affected path.  An endpoint MAY terminate the connection if an alternative path cannot be found.</p>
<h2 id="rfc.section.14.2">
<a href="#rfc.section.14.2">14.2.</a> <a href="#icmp-pmtud" id="icmp-pmtud">ICMP Packet Too Big Messages</a>
</h2>
<p id="rfc.section.14.2.p.1">PMTU discovery <a href="#RFC1191" class="xref">[RFC1191]</a> <a href="#RFC8201" class="xref">[RFC8201]</a> relies on reception of ICMP messages (e.g., IPv6 Packet Too Big messages) that indicate when a packet is dropped because it is larger than the local router MTU. DPLPMTUD can also optionally use these messages.  This use of ICMP messages is potentially vulnerable to off-path attacks that successfully guess the addresses used on the path and reduce the PMTU to a bandwidth-inefficient value.</p>
<p id="rfc.section.14.2.p.2">An endpoint MUST ignore an ICMP message that claims the PMTU has decreased below 1280 bytes.</p>
<p id="rfc.section.14.2.p.3">The requirements for generating ICMP (<a href="#RFC1812" class="xref">[RFC1812]</a>, <a href="#RFC4443" class="xref">[RFC4443]</a>) state that the quoted packet should contain as much of the original packet as possible without exceeding the minimum MTU for the IP version.  The size of the quoted packet can actually be smaller, or the information unintelligible, as described in Section 1.1 of <a href="#DPLPMTUD" class="xref">[DPLPMTUD]</a>.</p>
<p id="rfc.section.14.2.p.4">QUIC endpoints SHOULD validate ICMP messages to protect from off-path injection as specified in <a href="#RFC8201" class="xref">[RFC8201]</a> and Section 5.2 of <a href="#RFC8085" class="xref">[RFC8085]</a>. This validation SHOULD use the quoted packet supplied in the payload of an ICMP message to associate the message with a corresponding transport connection <a href="#DPLPMTUD" class="xref">[DPLPMTUD]</a>.</p>
<p id="rfc.section.14.2.p.5">ICMP message validation MUST include matching IP addresses and UDP ports <a href="#RFC8085" class="xref">[RFC8085]</a> and, when possible, connection IDs to an active QUIC session.</p>
<p id="rfc.section.14.2.p.6">Further validation can also be provided:</p>
<p></p>

<ul>
<li>An IPv4 endpoint could set the Don&#8217;t Fragment (DF) bit on a small proportion of packets, so that most invalid ICMP messages arrive when there are no DF packets outstanding, and can therefore be identified as spurious.</li>
<li>An endpoint could store additional information from the IP or UDP headers to use for validation (for example, the IP ID or UDP checksum).</li>
</ul>
<p id="rfc.section.14.2.p.8">The endpoint SHOULD ignore all ICMP messages that fail validation.</p>
<p id="rfc.section.14.2.p.9">An endpoint MUST NOT increase PMTU based on ICMP messages.  Any reduction in the QUIC maximum packet size MAY be provisional until QUIC&#8217;s loss detection algorithm determines that the quoted packet has actually been lost.</p>
<h2 id="rfc.section.14.3">
<a href="#rfc.section.14.3">14.3.</a> <a href="#datagram-packetization-layer-pmtu-discovery" id="datagram-packetization-layer-pmtu-discovery">Datagram Packetization Layer PMTU Discovery</a>
</h2>
<p id="rfc.section.14.3.p.1">Section 6.4 of <a href="#DPLPMTUD" class="xref">[DPLPMTUD]</a> provides considerations for implementing Datagram Packetization Layer PMTUD (DPLPMTUD) with QUIC.</p>
<p id="rfc.section.14.3.p.2">When implementing the algorithm in Section 5.3 of <a href="#DPLPMTUD" class="xref">[DPLPMTUD]</a>, the initial value of BASE_PMTU SHOULD be consistent with the minimum QUIC packet size (1232 bytes for IPv6 and 1252 bytes for IPv4).</p>
<p id="rfc.section.14.3.p.3">PING and PADDING frames can be used to generate PMTU probe packets. These frames might not be retransmitted if a probe packet containing them is lost.  However, these frames do consume congestion window, which could delay the transmission of subsequent application data.</p>
<p id="rfc.section.14.3.p.4">A PING frame can be included in a PMTU probe to ensure that a valid probe is acknowledged.</p>
<p id="rfc.section.14.3.p.5">The considerations for processing ICMP messages in the previous section also apply if these messages are used by DPLPMTUD.</p>
<h1 id="rfc.section.15">
<a href="#rfc.section.15">15.</a> <a href="#versions" id="versions">Versions</a>
</h1>
<p id="rfc.section.15.p.1">QUIC versions are identified using a 32-bit unsigned number.</p>
<p id="rfc.section.15.p.2">The version 0x00000000 is reserved to represent version negotiation.  This version of the specification is identified by the number 0x00000001.</p>
<p id="rfc.section.15.p.3">Other versions of QUIC might have different properties to this version.  The properties of QUIC that are guaranteed to be consistent across all versions of the protocol are described in <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a>.</p>
<p id="rfc.section.15.p.4">Version 0x00000001 of QUIC uses TLS as a cryptographic handshake protocol, as described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<p id="rfc.section.15.p.5">Versions with the most significant 16 bits of the version number cleared are reserved for use in future IETF consensus documents.</p>
<p id="rfc.section.15.p.6">Versions that follow the pattern 0x?a?a?a?a are reserved for use in forcing version negotiation to be exercised.  That is, any version number where the low four bits of all bytes is 1010 (in binary).  A client or server MAY advertise support for any of these reserved versions.</p>
<p id="rfc.section.15.p.7">Reserved version numbers will probably never represent a real protocol; a client MAY use one of these version numbers with the expectation that the server will initiate version negotiation; a server MAY advertise support for one of these versions and can expect that clients ignore the value.</p>
<p id="rfc.section.15.p.8">[[RFC editor: please remove the remainder of this section before publication.]]</p>
<p id="rfc.section.15.p.9">The version number for the final version of this specification (0x00000001), is reserved for the version of the protocol that is published as an RFC.</p>
<p id="rfc.section.15.p.10">Version numbers used to identify IETF drafts are created by adding the draft number to 0xff000000.  For example, draft-ietf-quic-transport-13 would be identified as 0xff00000D.</p>
<p id="rfc.section.15.p.11">Implementors are encouraged to register version numbers of QUIC that they are using for private experimentation on the GitHub wiki at &lt;https://github.com/quicwg/base-drafts/wiki/QUIC-Versions&gt;.</p>
<h1 id="rfc.section.16">
<a href="#rfc.section.16">16.</a> <a href="#integer-encoding" id="integer-encoding">Variable-Length Integer Encoding</a>
</h1>
<p id="rfc.section.16.p.1">QUIC packets and frames commonly use a variable-length encoding for non-negative integer values.  This encoding ensures that smaller integer values need fewer bytes to encode.</p>
<p id="rfc.section.16.p.2">The QUIC variable-length integer encoding reserves the two most significant bits of the first byte to encode the base 2 logarithm of the integer encoding length in bytes.  The integer value is encoded on the remaining bits, in network byte order.</p>
<p id="rfc.section.16.p.3">This means that integers are encoded on 1, 2, 4, or 8 bytes and can encode 6, 14, 30, or 62 bit values respectively.  <a href="#integer-summary" class="xref">Table 4</a> summarizes the encoding properties.</p>
<div id="rfc.table.4"></div>
<div id="integer-summary"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Summary of Integer Encodings</caption>
<thead><tr>
<th class="left">2Bit</th>
<th class="left">Length</th>
<th class="left">Usable Bits</th>
<th class="left">Range</th>
</tr></thead>
<tbody>
<tr>
<td class="left">00</td>
<td class="left">1</td>
<td class="left">6</td>
<td class="left">0-63</td>
</tr>
<tr>
<td class="left">01</td>
<td class="left">2</td>
<td class="left">14</td>
<td class="left">0-16383</td>
</tr>
<tr>
<td class="left">10</td>
<td class="left">4</td>
<td class="left">30</td>
<td class="left">0-1073741823</td>
</tr>
<tr>
<td class="left">11</td>
<td class="left">8</td>
<td class="left">62</td>
<td class="left">0-4611686018427387903</td>
</tr>
</tbody>
</table>
<p id="rfc.section.16.p.4">For example, the eight byte sequence c2 19 7c 5e ff 14 e8 8c (in hexadecimal) decodes to the decimal value 151288809941952652; the four byte sequence 9d 7f 3e 7d decodes to 494878333; the two byte sequence 7b bd decodes to 15293; and the single byte 25 decodes to 37 (as does the two byte sequence 40 25).</p>
<p id="rfc.section.16.p.5">Error codes (<a href="#error-codes" class="xref">Section 20</a>) and versions (<a href="#versions" class="xref">Section 15</a>) are described using integers, but do not use this encoding.</p>
<h1 id="rfc.section.17">
<a href="#rfc.section.17">17.</a> <a href="#packet-formats" id="packet-formats">Packet Formats</a>
</h1>
<p id="rfc.section.17.p.1">All numeric values are encoded in network byte order (that is, big-endian) and all field sizes are in bits.  Hexadecimal notation is used for describing the value of fields.</p>
<h2 id="rfc.section.17.1">
<a href="#rfc.section.17.1">17.1.</a> <a href="#packet-encoding" id="packet-encoding">Packet Number Encoding and Decoding</a>
</h2>
<p id="rfc.section.17.1.p.1">Packet numbers are integers in the range 0 to 2^62-1 (<a href="#packet-numbers" class="xref">Section 12.3</a>).  When present in long or short packet headers, they are encoded in 1 to 4 bytes.  The number of bits required to represent the packet number is reduced by including the least significant bits of the packet number.</p>
<p id="rfc.section.17.1.p.2">The encoded packet number is protected as described in Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<p id="rfc.section.17.1.p.3">The sender MUST use a packet number size able to represent more than twice as large a range than the difference between the largest acknowledged packet and packet number being sent.  A peer receiving the packet will then correctly decode the packet number, unless the packet is delayed in transit such that it arrives after many higher-numbered packets have been received.  An endpoint SHOULD use a large enough packet number encoding to allow the packet number to be recovered even if the packet arrives after packets that are sent afterwards.</p>
<p id="rfc.section.17.1.p.4">As a result, the size of the packet number encoding is at least one bit more than the base-2 logarithm of the number of contiguous unacknowledged packet numbers, including the new packet.</p>
<p id="rfc.section.17.1.p.5">For example, if an endpoint has received an acknowledgment for packet 0xabe8bc, sending a packet with a number of 0xac5c02 requires a packet number encoding with 16 bits or more; whereas the 24-bit packet number encoding is needed to send a packet with a number of 0xace8fe.</p>
<p id="rfc.section.17.1.p.6">At a receiver, protection of the packet number is removed prior to recovering the full packet number. The full packet number is then reconstructed based on the number of significant bits present, the value of those bits, and the largest packet number received on a successfully authenticated packet. Recovering the full packet number is necessary to successfully remove packet protection.</p>
<p id="rfc.section.17.1.p.7">Once header protection is removed, the packet number is decoded by finding the packet number value that is closest to the next expected packet.  The next expected packet is the highest received packet number plus one.  For example, if the highest successfully authenticated packet had a packet number of 0xa82f30ea, then a packet containing a 16-bit value of 0x9b32 will be decoded as 0xa82f9b32.  Example pseudo-code for packet number decoding can be found in <a href="#sample-packet-number-decoding" class="xref">Appendix A</a>.</p>
<h2 id="rfc.section.17.2">
<a href="#rfc.section.17.2">17.2.</a> <a href="#long-header" id="long-header">Long Header Packets</a>
</h2>
<div id="rfc.figure.9"></div>
<div id="fig-long-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|1|T T|X X X X|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|DCIL(4)|SCIL(4)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Destination Connection ID (0/32..144)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Connection ID (0/32..144)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 9: Long Header Packet Format</p>
<p id="rfc.section.17.2.p.1">Long headers are used for packets that are sent prior to the establishment of 1-RTT keys. Once both conditions are met, a sender switches to sending packets using the short header (<a href="#short-header" class="xref">Section 17.3</a>).  The long form allows for special packets - such as the Version Negotiation packet - to be represented in this uniform fixed-length packet format. Packets that use the long header contain the following fields:</p>
<p></p>

<dl>
<dt>Header Form:</dt>
<dd style="margin-left: 8">The most significant bit (0x80) of byte 0 (the first byte) is set to 1 for long headers.</dd>
<dt>Fixed Bit:</dt>
<dd style="margin-left: 8">The next bit (0x40) of byte 0 is set to 1.  Packets containing a zero value for this bit are not valid packets in this version and MUST be discarded.</dd>
<dt>Long Packet Type (T):</dt>
<dd style="margin-left: 8">The next two bits (those with a mask of 0x30) of byte 0 contain a packet type.  Packet types are listed in <a href="#long-packet-types" class="xref">Table 5</a>.</dd>
<dt>Type-Specific Bits (X):</dt>
<dd style="margin-left: 8">The lower four bits (those with a mask of 0x0f) of byte 0 are type-specific.</dd>
<dt>Version:</dt>
<dd style="margin-left: 8">The QUIC Version is a 32-bit field that follows the first byte.  This field indicates which version of QUIC is in use and determines how the rest of the protocol fields are interpreted.</dd>
<dt>DCIL and SCIL:</dt>
<dd style="margin-left: 8">The byte following the version contains the lengths of the two connection ID fields that follow it.  These lengths are encoded as two 4-bit unsigned integers. The Destination Connection ID Length (DCIL) field occupies the 4 high bits of the byte and the Source Connection ID Length (SCIL) field occupies the 4 low bits of the byte.  An encoded length of 0 indicates that the connection ID is also 0 bytes in length.  Non-zero encoded lengths are increased by 3 to get the full length of the connection ID, producing a length between 4 and 18 bytes inclusive.  For example, an byte with the value 0x50 describes an 8-byte Destination Connection ID and a zero-length Source Connection ID.</dd>
<dt>Destination Connection ID:</dt>
<dd style="margin-left: 8">The Destination Connection ID field follows the connection ID lengths and is either 0 bytes in length or between 4 and 18 bytes.  <a href="#negotiating-connection-ids" class="xref">Section 7.2</a> describes the use of this field in more detail.</dd>
<dt>Source Connection ID:</dt>
<dd style="margin-left: 8">The Source Connection ID field follows the Destination Connection ID and is either 0 bytes in length or between 4 and 18 bytes.  <a href="#negotiating-connection-ids" class="xref">Section 7.2</a> describes the use of this field in more detail.</dd>
</dl>
<p id="rfc.section.17.2.p.3">In this version of QUIC, the following packet types with the long header are defined:</p>
<div id="rfc.table.5"></div>
<div id="long-packet-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Long Header Packet Types</caption>
<thead><tr>
<th class="right">Type</th>
<th class="left">Name</th>
<th class="left">Section</th>
</tr></thead>
<tbody>
<tr>
<td class="right">0x0</td>
<td class="left">Initial</td>
<td class="left"><a href="#packet-initial" class="xref">Section 17.2.2</a></td>
</tr>
<tr>
<td class="right">0x1</td>
<td class="left">0-RTT</td>
<td class="left"><a href="#packet-0rtt" class="xref">Section 17.2.3</a></td>
</tr>
<tr>
<td class="right">0x2</td>
<td class="left">Handshake</td>
<td class="left"><a href="#packet-handshake" class="xref">Section 17.2.4</a></td>
</tr>
<tr>
<td class="right">0x3</td>
<td class="left">Retry</td>
<td class="left"><a href="#packet-retry" class="xref">Section 17.2.5</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.17.2.p.4">The header form bit, connection ID lengths byte, Destination and Source Connection ID fields, and Version fields of a long header packet are version-independent. The other fields in the first byte are version-specific.  See <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a> for details on how packets from different versions of QUIC are interpreted.</p>
<p id="rfc.section.17.2.p.5">The interpretation of the fields and the payload are specific to a version and packet type.  While type-specific semantics for this version are described in the following sections, several long-header packets in this version of QUIC contain these additional fields:</p>
<p></p>

<dl>
<dt>Reserved Bits (R):</dt>
<dd style="margin-left: 8">Two bits (those with a mask of 0x0c) of byte 0 are reserved across multiple packet types.  These bits are protected using header protection (see Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>). The value included prior to protection MUST be set to 0.  An endpoint MUST treat receipt of a packet that has a non-zero value for these bits, after removing both packet and header protection, as a connection error of type PROTOCOL_VIOLATION. Discarding such a packet after only removing header protection can expose the endpoint to attacks (see Section 9.3 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).</dd>
<dt>Packet Number Length (P):</dt>
<dd style="margin-left: 8">In packet types which contain a Packet Number field, the least significant two bits (those with a mask of 0x03) of byte 0 contain the length of the packet number, encoded as an unsigned, two-bit integer that is one less than the length of the packet number field in bytes.  That is, the length of the packet number field is the value of this field, plus one.  These bits are protected using header protection (see Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">The length of the remainder of the packet (that is, the Packet Number and Payload fields) in bytes, encoded as a variable-length integer (<a href="#integer-encoding" class="xref">Section 16</a>).</dd>
<dt>Packet Number:</dt>
<dd style="margin-left: 8">The packet number field is 1 to 4 bytes long. The packet number has confidentiality protection separate from packet protection, as described in Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>. The length of the packet number field is encoded in the Packet Number Length bits of byte 0 (see above).</dd>
</dl>
<h3 id="rfc.section.17.2.1">
<a href="#rfc.section.17.2.1">17.2.1.</a> <a href="#packet-version" id="packet-version">Version Negotiation Packet</a>
</h3>
<p id="rfc.section.17.2.1.p.1">A Version Negotiation packet is inherently not version-specific. Upon receipt by a client, it will be identified as a Version Negotiation packet based on the Version field having a value of 0.</p>
<p id="rfc.section.17.2.1.p.2">The Version Negotiation packet is a response to a client packet that contains a version that is not supported by the server, and is only sent by servers.</p>
<p id="rfc.section.17.2.1.p.3">The layout of a Version Negotiation packet is:</p>
<div id="rfc.figure.10"></div>
<div id="version-negotiation-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|  Unused (7) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Version (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|DCIL(4)|SCIL(4)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Destination Connection ID (0/32..144)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Connection ID (0/32..144)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version 1 (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version 2 (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version N (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 10: Version Negotiation Packet</p>
<p id="rfc.section.17.2.1.p.4">The value in the Unused field is selected randomly by the server.  Clients MUST ignore the value of this field.  Servers SHOULD set the most significant bit of this field (0x40) to 1 so that Version Negotiation packets appear to have the Fixed Bit field.</p>
<p id="rfc.section.17.2.1.p.5">The Version field of a Version Negotiation packet MUST be set to 0x00000000.</p>
<p id="rfc.section.17.2.1.p.6">The server MUST include the value from the Source Connection ID field of the packet it receives in the Destination Connection ID field.  The value for Source Connection ID MUST be copied from the Destination Connection ID of the received packet, which is initially randomly selected by a client.  Echoing both connection IDs gives clients some assurance that the server received the packet and that the Version Negotiation packet was not generated by an off-path attacker.</p>
<p id="rfc.section.17.2.1.p.7">The remainder of the Version Negotiation packet is a list of 32-bit versions which the server supports.</p>
<p id="rfc.section.17.2.1.p.8">A Version Negotiation packet cannot be explicitly acknowledged in an ACK frame by a client.  Receiving another Initial packet implicitly acknowledges a Version Negotiation packet.</p>
<p id="rfc.section.17.2.1.p.9">The Version Negotiation packet does not include the Packet Number and Length fields present in other packets that use the long header form.  Consequently, a Version Negotiation packet consumes an entire UDP datagram.</p>
<p id="rfc.section.17.2.1.p.10">A server MUST NOT send more than one Version Negotiation packet in response to a single UDP datagram.</p>
<p id="rfc.section.17.2.1.p.11">See <a href="#version-negotiation" class="xref">Section 6</a> for a description of the version negotiation process.</p>
<h3 id="rfc.section.17.2.2">
<a href="#rfc.section.17.2.2">17.2.2.</a> <a href="#packet-initial" id="packet-initial">Initial Packet</a>
</h3>
<p id="rfc.section.17.2.2.p.1">An Initial packet uses long headers with a type value of 0x0.  It carries the first CRYPTO frames sent by the client and server to perform key exchange, and carries ACKs in either direction.</p>
<div id="rfc.figure.11"></div>
<div id="initial-format"></div>
<pre>
+-+-+-+-+-+-+-+-+
|1|1| 0 |R R|P P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|DCIL(4)|SCIL(4)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Destination Connection ID (0/32..144)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Connection ID (0/32..144)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Token Length (i)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Token (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Length (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Packet Number (8/16/24/32)               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 11: Initial Packet</p>
<p id="rfc.section.17.2.2.p.2">The Initial packet contains a long header as well as the Length and Packet Number fields.  The first byte contains the Reserved and Packet Number Length bits.  Between the SCID and Length fields, there are two additional field specific to the Initial packet.</p>
<p></p>

<dl>
<dt>Token Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the Token field, in bytes.  This value is zero if no token is present.  Initial packets sent by the server MUST set the Token Length field to zero; clients that receive an Initial packet with a non-zero Token Length field MUST either discard the packet or generate a connection error of type PROTOCOL_VIOLATION.</dd>
<dt>Token:</dt>
<dd style="margin-left: 8">The value of the token that was previously provided in a Retry packet or NEW_TOKEN frame.</dd>
<dt>Payload:</dt>
<dd style="margin-left: 8">The payload of the packet.</dd>
</dl>
<p id="rfc.section.17.2.2.p.4">In order to prevent tampering by version-unaware middleboxes, Initial packets are protected with connection- and version-specific keys (Initial keys) as described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.  This protection does not provide confidentiality or integrity against on-path attackers, but provides some level of protection against off-path attackers.</p>
<p id="rfc.section.17.2.2.p.5">The client and server use the Initial packet type for any packet that contains an initial cryptographic handshake message. This includes all cases where a new packet containing the initial cryptographic message needs to be created, such as the packets sent after receiving a Retry packet (<a href="#packet-retry" class="xref">Section 17.2.5</a>).</p>
<p id="rfc.section.17.2.2.p.6">A server sends its first Initial packet in response to a client Initial.  A server may send multiple Initial packets.  The cryptographic key exchange could require multiple round trips or retransmissions of this data.</p>
<p id="rfc.section.17.2.2.p.7">The payload of an Initial packet includes a CRYPTO frame (or frames) containing a cryptographic handshake message, ACK frames, or both.  PADDING and CONNECTION_CLOSE frames are also permitted.  An endpoint that receives an Initial packet containing other frames can either discard the packet as spurious or treat it as a connection error.</p>
<p id="rfc.section.17.2.2.p.8">The first packet sent by a client always includes a CRYPTO frame that contains the entirety of the first cryptographic handshake message.  This packet, and the cryptographic handshake message, MUST fit in a single UDP datagram (see <a href="#handshake" class="xref">Section 7</a>).  The first CRYPTO frame sent always begins at an offset of 0 (see <a href="#handshake" class="xref">Section 7</a>).</p>
<p id="rfc.section.17.2.2.p.9">Note that if the server sends a HelloRetryRequest, the client will send a second Initial packet.  This Initial packet will continue the cryptographic handshake and will contain a CRYPTO frame with an offset matching the size of the CRYPTO frame sent in the first Initial packet.  Cryptographic handshake messages subsequent to the first do not need to fit within a single UDP datagram.</p>
<h4 id="rfc.section.17.2.2.1">
<a href="#rfc.section.17.2.2.1">17.2.2.1.</a> <a href="#discard-initial" id="discard-initial">Abandoning Initial Packets</a>
</h4>
<p id="rfc.section.17.2.2.1.p.1">A client stops both sending and processing Initial packets when it sends its first Handshake packet.  A server stops sending and processing Initial packets when it receives its first Handshake packet.  Though packets might still be in flight or awaiting acknowledgment, no further Initial packets need to be exchanged beyond this point.  Initial packet protection keys are discarded (see Section 4.10 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>) along with any loss recovery and congestion control state (see Sections 5.3.1.2 and 6.9 of <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>).</p>
<p id="rfc.section.17.2.2.1.p.2">Any data in CRYPTO frames is discarded - and no longer retransmitted - when Initial keys are discarded.</p>
<h3 id="rfc.section.17.2.3">
<a href="#rfc.section.17.2.3">17.2.3.</a> <a href="#packet-0rtt" id="packet-0rtt">0-RTT</a>
</h3>
<p id="rfc.section.17.2.3.p.1">A 0-RTT packet uses long headers with a type value of 0x1, followed by the Length and Packet Number fields. The first byte contains the Reserved and Packet Number Length bits.  It is used to carry &#8220;early&#8221; data from the client to the server as part of the first flight, prior to handshake completion. As part of the TLS handshake, the server can accept or reject this early data.</p>
<p id="rfc.section.17.2.3.p.2">See Section 2.3 of <a href="#TLS13" class="xref">[TLS13]</a> for a discussion of 0-RTT data and its limitations.</p>
<pre>
+-+-+-+-+-+-+-+-+
|1|1| 1 |R R|P P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|DCIL(4)|SCIL(4)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Destination Connection ID (0/32..144)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Connection ID (0/32..144)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Length (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Packet Number (8/16/24/32)               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">0-RTT Packet</p>
<p id="rfc.section.17.2.3.p.3">Packet numbers for 0-RTT protected packets use the same space as 1-RTT protected packets.</p>
<p id="rfc.section.17.2.3.p.4">After a client receives a Retry packet, 0-RTT packets are likely to have been lost or discarded by the server.  A client MAY attempt to resend data in 0-RTT packets after it sends a new Initial packet.</p>
<p id="rfc.section.17.2.3.p.5">A client MUST NOT reset the packet number it uses for 0-RTT packets.  The keys used to protect 0-RTT packets will not change as a result of responding to a Retry packet unless the client also regenerates the cryptographic handshake message.  Sending packets with the same packet number in that case is likely to compromise the packet protection for all 0-RTT packets because the same key and nonce could be used to protect different content.</p>
<p id="rfc.section.17.2.3.p.6">Receiving a Retry packet, especially a Retry that changes the connection ID used for subsequent packets, indicates a strong possibility that 0-RTT packets could be lost.  A client only receives acknowledgments for its 0-RTT packets once the handshake is complete.  Consequently, a server might expect 0-RTT packets to start with a packet number of 0.  Therefore, in determining the length of the packet number encoding for 0-RTT packets, a client MUST assume that all packets up to the current packet number are in flight, starting from a packet number of 0.  Thus, 0-RTT packets could need to use a longer packet number encoding.</p>
<p id="rfc.section.17.2.3.p.7">A client SHOULD instead generate a fresh cryptographic handshake message and start packet numbers from 0.  This ensures that new 0-RTT packets will not use the same keys, avoiding any risk of key and nonce reuse; this also prevents 0-RTT packets from previous handshake attempts from being accepted as part of the connection.</p>
<h3 id="rfc.section.17.2.4">
<a href="#rfc.section.17.2.4">17.2.4.</a> <a href="#packet-handshake" id="packet-handshake">Handshake Packet</a>
</h3>
<p id="rfc.section.17.2.4.p.1">A Handshake packet uses long headers with a type value of 0x2, followed by the Length and Packet Number fields.  The first byte contains the Reserved and Packet Number Length bits.  It is used to carry acknowledgments and cryptographic handshake messages from the server and client.</p>
<div id="rfc.figure.12"></div>
<div id="handshake-format"></div>
<pre>
+-+-+-+-+-+-+-+-+
|1|1| 2 |R R|P P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|DCIL(4)|SCIL(4)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Destination Connection ID (0/32..144)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Connection ID (0/32..144)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Length (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Packet Number (8/16/24/32)               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 12: Handshake Protected Packet</p>
<p id="rfc.section.17.2.4.p.2">Once a client has received a Handshake packet from a server, it uses Handshake packets to send subsequent cryptographic handshake messages and acknowledgments to the server.</p>
<p id="rfc.section.17.2.4.p.3">The Destination Connection ID field in a Handshake packet contains a connection ID that is chosen by the recipient of the packet; the Source Connection ID includes the connection ID that the sender of the packet wishes to use (see <a href="#negotiating-connection-ids" class="xref">Section 7.2</a>).</p>
<p id="rfc.section.17.2.4.p.4">Handshake packets are their own packet number space, and thus the first Handshake packet sent by a server contains a packet number of 0.</p>
<p id="rfc.section.17.2.4.p.5">The payload of this packet contains CRYPTO frames and could contain PADDING, or ACK frames. Handshake packets MAY contain CONNECTION_CLOSE frames.  Endpoints MUST treat receipt of Handshake packets with other frames as a connection error.</p>
<p id="rfc.section.17.2.4.p.6">Like Initial packets (see <a href="#discard-initial" class="xref">Section 17.2.2.1</a>), data in CRYPTO frames at the Handshake encryption level is discarded - and no longer retransmitted - when Handshake protection keys are discarded.</p>
<h3 id="rfc.section.17.2.5">
<a href="#rfc.section.17.2.5">17.2.5.</a> <a href="#packet-retry" id="packet-retry">Retry Packet</a>
</h3>
<p id="rfc.section.17.2.5.p.1">A Retry packet uses a long packet header with a type value of 0x3. It carries an address validation token created by the server. It is used by a server that wishes to perform a stateless retry (see <a href="#validate-handshake" class="xref">Section 8.1</a>).</p>
<div id="rfc.figure.13"></div>
<div id="retry-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|1| 3 | ODCIL |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|DCIL(4)|SCIL(4)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Destination Connection ID (0/32..144)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Source Connection ID (0/32..144)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Original Destination Connection ID (0/32..144)     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Retry Token (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 13: Retry Packet</p>
<p id="rfc.section.17.2.5.p.2">A Retry packet (shown in <a href="#retry-format" class="xref">Figure 13</a>) does not contain any protected fields.  In addition to the long header, it contains these additional fields:</p>
<p></p>

<dl>
<dt>ODCIL:</dt>
<dd style="margin-left: 8">The four least-significant bits of the first byte of a Retry packet are not protected as they are for other packets with the long header, because Retry packets don&#8217;t contain a protected payload.  These bits instead encode the length of the Original Destination Connection ID field.  The length uses the same encoding as the DCIL and SCIL fields.</dd>
<dt>Original Destination Connection ID:</dt>
<dd style="margin-left: 8">The Original Destination Connection ID contains the value of the Destination Connection ID from the Initial packet that this Retry is in response to. The length of this field is given in ODCIL.</dd>
<dt>Retry Token:</dt>
<dd style="margin-left: 8">An opaque token that the server can use to validate the client&#8217;s address.</dd>
</dl>
<p id="rfc.section.17.2.5.p.4">The server populates the Destination Connection ID with the connection ID that the client included in the Source Connection ID of the Initial packet.</p>
<p id="rfc.section.17.2.5.p.5">The server includes a connection ID of its choice in the Source Connection ID field.  This value MUST not be equal to the Destination Connection ID field of the packet sent by the client.  The client MUST use this connection ID in the Destination Connection ID of subsequent packets that it sends.</p>
<p id="rfc.section.17.2.5.p.6">A server MAY send Retry packets in response to Initial and 0-RTT packets.  A server can either discard or buffer 0-RTT packets that it receives.  A server can send multiple Retry packets as it receives Initial or 0-RTT packets.  A server MUST NOT send more than one Retry packet in response to a single UDP datagram.</p>
<p id="rfc.section.17.2.5.p.7">A client MUST accept and process at most one Retry packet for each connection attempt.  After the client has received and processed an Initial or Retry packet from the server, it MUST discard any subsequent Retry packets that it receives.</p>
<p id="rfc.section.17.2.5.p.8">Clients MUST discard Retry packets that contain an Original Destination Connection ID field that does not match the Destination Connection ID from its Initial packet.  This prevents an off-path attacker from injecting a Retry packet.</p>
<p id="rfc.section.17.2.5.p.9">The client responds to a Retry packet with an Initial packet that includes the provided Retry Token to continue connection establishment.</p>
<p id="rfc.section.17.2.5.p.10">A client sets the Destination Connection ID field of this Initial packet to the value from the Source Connection ID in the Retry packet. Changing Destination Connection ID also results in a change to the keys used to protect the Initial packet. It also sets the Token field to the token provided in the Retry. The client MUST NOT change the Source Connection ID because the server could include the connection ID as part of its token validation logic (see <a href="#token-integrity" class="xref">Section 8.1.3</a>).</p>
<p id="rfc.section.17.2.5.p.11">The next Initial packet from the client uses the connection ID and token values from the Retry packet (see <a href="#negotiating-connection-ids" class="xref">Section 7.2</a>).  Aside from this, the Initial packet sent by the client is subject to the same restrictions as the first Initial packet.  A client can either reuse the cryptographic handshake message or construct a new one at its discretion.</p>
<p id="rfc.section.17.2.5.p.12">A client MAY attempt 0-RTT after receiving a Retry packet by sending 0-RTT packets to the connection ID provided by the server.  A client that sends additional 0-RTT packets without constructing a new cryptographic handshake message MUST NOT reset the packet number to 0 after a Retry packet, see <a href="#packet-0rtt" class="xref">Section 17.2.3</a>.</p>
<p id="rfc.section.17.2.5.p.13">A server acknowledges the use of a Retry packet for a connection using the original_connection_id transport parameter (see <a href="#transport-parameter-definitions" class="xref">Section 18.1</a>).  If the server sends a Retry packet, it MUST include the value of the Original Destination Connection ID field of the Retry packet (that is, the Destination Connection ID field from the client&#8217;s first Initial packet) in the transport parameter.</p>
<p id="rfc.section.17.2.5.p.14">If the client received and processed a Retry packet, it MUST validate that the original_connection_id transport parameter is present and correct; otherwise, it MUST validate that the transport parameter is absent.  A client MUST treat a failed validation as a connection error of type TRANSPORT_PARAMETER_ERROR.</p>
<p id="rfc.section.17.2.5.p.15">A Retry packet does not include a packet number and cannot be explicitly acknowledged by a client.</p>
<h2 id="rfc.section.17.3">
<a href="#rfc.section.17.3">17.3.</a> <a href="#short-header" id="short-header">Short Header Packets</a>
</h2>
<p id="rfc.section.17.3.p.1">This version of QUIC defines a single packet type which uses the short packet header.</p>
<div id="rfc.figure.14"></div>
<div id="fig-short-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|0|1|S|R|R|K|P P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Destination Connection ID (0..144)           ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Packet Number (8/16/24/32)              ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Protected Payload (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 14: Short Header Packet Format</p>
<p id="rfc.section.17.3.p.2">The short header can be used after the version and 1-RTT keys are negotiated.  Packets that use the short header contain the following fields:</p>
<p></p>

<dl>
<dt>Header Form:</dt>
<dd style="margin-left: 8">The most significant bit (0x80) of byte 0 is set to 0 for the short header.</dd>
<dt>Fixed Bit:</dt>
<dd style="margin-left: 8">The next bit (0x40) of byte 0 is set to 1.  Packets containing a zero value for this bit are not valid packets in this version and MUST be discarded.</dd>
<dt>Spin Bit (S):</dt>
<dd style="margin-left: 8">The third most significant bit (0x20) of byte 0 is the latency spin bit, set as described in <a href="#spin-bit" class="xref">Section 17.3.1</a>.</dd>
<dt>Reserved Bits (R):</dt>
<dd style="margin-left: 8">The next two bits (those with a mask of 0x18) of byte 0 are reserved.  These bits are protected using header protection (see Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).  The value included prior to protection MUST be set to 0.  An endpoint MUST treat receipt of a packet that has a non-zero value for these bits, after removing both packet and header protection, as a connection error of type PROTOCOL_VIOLATION. Discarding such a packet after only removing header protection can expose the endpoint to attacks (see Section 9.3 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).</dd>
<dt>Key Phase (K):</dt>
<dd style="margin-left: 8">The next bit (0x04) of byte 0 indicates the key phase, which allows a recipient of a packet to identify the packet protection keys that are used to protect the packet.  See <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> for details.  This bit is protected using header protection (see Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).</dd>
<dt>Packet Number Length (P):</dt>
<dd style="margin-left: 8">The least significant two bits (those with a mask of 0x03) of byte 0 contain the length of the packet number, encoded as an unsigned, two-bit integer that is one less than the length of the packet number field in bytes.  That is, the length of the packet number field is the value of this field, plus one.  These bits are protected using header protection (see Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).</dd>
<dt>Destination Connection ID:</dt>
<dd style="margin-left: 8">The Destination Connection ID is a connection ID that is chosen by the intended recipient of the packet.  See <a href="#connection-id" class="xref">Section 5.1</a> for more details.</dd>
<dt>Packet Number:</dt>
<dd style="margin-left: 8">The packet number field is 1 to 4 bytes long. The packet number has confidentiality protection separate from packet protection, as described in Section 5.4 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>. The length of the packet number field is encoded in Packet Number Length field. See <a href="#packet-encoding" class="xref">Section 17.1</a> for details.</dd>
<dt>Protected Payload:</dt>
<dd style="margin-left: 8">Packets with a short header always include a 1-RTT protected payload.</dd>
</dl>
<p id="rfc.section.17.3.p.4">The header form bit and the connection ID field of a short header packet are version-independent.  The remaining fields are specific to the selected QUIC version.  See <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a> for details on how packets from different versions of QUIC are interpreted.</p>
<h3 id="rfc.section.17.3.1">
<a href="#rfc.section.17.3.1">17.3.1.</a> <a href="#spin-bit" id="spin-bit">Latency Spin Bit</a>
</h3>
<p id="rfc.section.17.3.1.p.1">The latency spin bit enables passive latency monitoring from observation points on the network path throughout the duration of a connection. The spin bit is only present in the short packet header, since it is possible to measure the initial RTT of a connection by observing the handshake. Therefore, the spin bit is available after version negotiation and connection establishment are completed. On-path measurement and use of the latency spin bit is further discussed in <a href="#QUIC-MANAGEABILITY" class="xref">[QUIC-MANAGEABILITY]</a>.</p>
<p id="rfc.section.17.3.1.p.2">The spin bit is an OPTIONAL feature of QUIC. A QUIC stack that chooses to support the spin bit MUST implement it as specified in this section.</p>
<p id="rfc.section.17.3.1.p.3">Each endpoint unilaterally decides if the spin bit is enabled or disabled for a connection. Implementations MUST allow administrators of clients and servers to disable the spin bit either globally or on a per-connection basis. Even when the spin bit is not disabled by the administrator, implementations MUST disable the spin bit for a given connection with a certain likelihood. The random selection process SHOULD be designed such that on average the spin bit is disabled for at least one eighth of connections. The selection process performed at the beginning of the connection SHOULD be applied for all paths used by the connection.</p>
<p id="rfc.section.17.3.1.p.4">In case multiple connections share the same five-tuple, that is, have the same source and destination IP address and UDP ports, endpoints should try to co-ordinate across all connections to ensure a clear signal to any on-path measurement points.</p>
<p id="rfc.section.17.3.1.p.5">When the spin bit is disabled, endpoints MAY set the spin bit to any value, and MUST ignore any incoming value. It is RECOMMENDED that endpoints set the spin bit to a random value either chosen independently for each packet or chosen independently for each connection ID.</p>
<p id="rfc.section.17.3.1.p.6">If the spin bit is enabled for the connection, the endpoint maintains a spin value and sets the spin bit in the short header to the currently stored value when a packet with a short header is sent out. The spin value is initialized to 0 in the endpoint at connection start.  Each endpoint also remembers the highest packet number seen from its peer on the connection.</p>
<p id="rfc.section.17.3.1.p.7">When a server receives a short header packet that increments the highest packet number seen by the server from the client, it sets the spin value to be equal to the spin bit in the received packet.</p>
<p id="rfc.section.17.3.1.p.8">When a client receives a short header packet that increments the highest packet number seen by the client from the server, it sets the spin value to the inverse of the spin bit in the received packet.</p>
<p id="rfc.section.17.3.1.p.9">An endpoint resets its spin value to zero when sending the first packet of a given connection with a new connection ID. This reduces the risk that transient spin bit state can be used to link flows across connection migration or ID change.</p>
<p id="rfc.section.17.3.1.p.10">With this mechanism, the server reflects the spin value received, while the client &#8216;spins&#8217; it after one RTT. On-path observers can measure the time between two spin bit toggle events to estimate the end-to-end RTT of a connection.</p>
<h1 id="rfc.section.18">
<a href="#rfc.section.18">18.</a> <a href="#transport-parameter-encoding" id="transport-parameter-encoding">Transport Parameter Encoding</a>
</h1>
<p id="rfc.section.18.p.1">The format of the transport parameters is the TransportParameters struct from <a href="#figure-transport-parameters" class="xref">Figure 15</a>.  This is described using the presentation language from Section 3 of <a href="#TLS13" class="xref">[TLS13]</a>.</p>
<div id="rfc.figure.15"></div>
<div id="figure-transport-parameters"></div>
<pre>
   enum {
      original_connection_id(0),
      idle_timeout(1),
      stateless_reset_token(2),
      max_packet_size(3),
      initial_max_data(4),
      initial_max_stream_data_bidi_local(5),
      initial_max_stream_data_bidi_remote(6),
      initial_max_stream_data_uni(7),
      initial_max_streams_bidi(8),
      initial_max_streams_uni(9),
      ack_delay_exponent(10),
      max_ack_delay(11),
      disable_migration(12),
      preferred_address(13),
      (65535)
   } TransportParameterId;

   struct {
      TransportParameterId parameter;
      opaque value&lt;0..2^16-1&gt;;
   } TransportParameter;

   TransportParameter TransportParameters&lt;0..2^16-1&gt;;
</pre>
<p class="figure">Figure 15: Definition of TransportParameters</p>
<p id="rfc.section.18.p.2">The <samp>extension_data</samp> field of the quic_transport_parameters extension defined in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> contains a TransportParameters value.  TLS encoding rules are therefore used to describe the encoding of transport parameters.</p>
<p id="rfc.section.18.p.3">QUIC encodes transport parameters into a sequence of bytes, which are then included in the cryptographic handshake.</p>
<h2 id="rfc.section.18.1">
<a href="#rfc.section.18.1">18.1.</a> <a href="#transport-parameter-definitions" id="transport-parameter-definitions">Transport Parameter Definitions</a>
</h2>
<p id="rfc.section.18.1.p.1">This section details the transport parameters defined in this document.</p>
<p id="rfc.section.18.1.p.2">Many transport parameters listed here have integer values.  Those transport parameters that are identified as integers use a variable-length integer encoding (see <a href="#integer-encoding" class="xref">Section 16</a>) and have a default value of 0 if the transport parameter is absent, unless otherwise stated.</p>
<p id="rfc.section.18.1.p.3">The following transport parameters are defined:</p>
<p></p>

<dl>
<dt>original_connection_id (0x0000):</dt>
<dd style="margin-left: 8">The value of the Destination Connection ID field from the first Initial packet sent by the client.  This transport parameter is only sent by a server.  A server MUST include the original_connection_id transport parameter if it sent a Retry packet.</dd>
<dt>idle_timeout (0x0001):</dt>
<dd style="margin-left: 8">The idle timeout is a value in milliseconds that is encoded as an integer, see (<a href="#idle-timeout" class="xref">Section 10.2</a>).  If this parameter is absent or zero then the idle timeout is disabled.</dd>
<dt>stateless_reset_token (0x0002):</dt>
<dd style="margin-left: 8">A stateless reset token is used in verifying a stateless reset, see <a href="#stateless-reset" class="xref">Section 10.4</a>.  This parameter is a sequence of 16 bytes.  This transport parameter is only sent by a server.</dd>
<dt>max_packet_size (0x0003):</dt>
<dd style="margin-left: 8">The maximum packet size parameter is an integer value that limits the size of packets that the endpoint is willing to receive.  This indicates that packets larger than this limit will be dropped.  The default for this parameter is the maximum permitted UDP payload of 65527.  Values below 1200 are invalid.  This limit only applies to protected packets (<a href="#packet-protected" class="xref">Section 12.1</a>).</dd>
<dt>initial_max_data (0x0004):</dt>
<dd style="margin-left: 8">The initial maximum data parameter is an integer value that contains the initial value for the maximum amount of data that can be sent on the connection.  This is equivalent to sending a MAX_DATA (<a href="#frame-max-data" class="xref">Section 19.9</a>) for the connection immediately after completing the handshake.</dd>
<dt>initial_max_stream_data_bidi_local (0x0005):</dt>
<dd style="margin-left: 8">This parameter is an integer value specifying the initial flow control limit for locally-initiated bidirectional streams.  This limit applies to newly created bidirectional streams opened by the endpoint that sends the transport parameter.  In client transport parameters, this applies to streams with an identifier with the least significant two bits set to 0x0; in server transport parameters, this applies to streams with the least significant two bits set to 0x1.</dd>
<dt>initial_max_stream_data_bidi_remote (0x0006):</dt>
<dd style="margin-left: 8">This parameter is an integer value specifying the initial flow control limit for peer-initiated bidirectional streams.  This limit applies to newly created bidirectional streams opened by the endpoint that receives the transport parameter.  In client transport parameters, this applies to streams with an identifier with the least significant two bits set to 0x1; in server transport parameters, this applies to streams with the least significant two bits set to 0x0.</dd>
<dt>initial_max_stream_data_uni (0x0007):</dt>
<dd style="margin-left: 8">This parameter is an integer value specifying the initial flow control limit for unidirectional streams.  This limit applies to newly created unidirectional streams opened by the endpoint that receives the transport parameter.  In client transport parameters, this applies to streams with an identifier with the least significant two bits set to 0x3; in server transport parameters, this applies to streams with the least significant two bits set to 0x2.</dd>
<dt>initial_max_streams_bidi (0x0008):</dt>
<dd style="margin-left: 8">The initial maximum bidirectional streams parameter is an integer value that contains the initial maximum number of bidirectional streams the peer may initiate.  If this parameter is absent or zero, the peer cannot open bidirectional streams until a MAX_STREAMS frame is sent.  Setting this parameter is equivalent to sending a MAX_STREAMS (<a href="#frame-max-streams" class="xref">Section 19.11</a>) of the corresponding type with the same value.</dd>
<dt>initial_max_streams_uni (0x0009):</dt>
<dd style="margin-left: 8">The initial maximum unidirectional streams parameter is an integer value that contains the initial maximum number of unidirectional streams the peer may initiate.  If this parameter is absent or zero, the peer cannot open unidirectional streams until a MAX_STREAMS frame is sent.  Setting this parameter is equivalent to sending a MAX_STREAMS (<a href="#frame-max-streams" class="xref">Section 19.11</a>) of the corresponding type with the same value.</dd>
<dt>ack_delay_exponent (0x000a):</dt>
<dd style="margin-left: 8">The ACK delay exponent is an integer value indicating an exponent used to decode the ACK Delay field in the ACK frame (<a href="#frame-ack" class="xref">Section 19.3</a>).  If this value is absent, a default value of 3 is assumed (indicating a multiplier of 8).  The default value is also used for ACK frames that are sent in Initial and Handshake packets.  Values above 20 are invalid.</dd>
<dt>max_ack_delay (0x000b):</dt>
<dd style="margin-left: 8">The maximum ACK delay is an integer value indicating the maximum amount of time in milliseconds by which the endpoint will delay sending acknowledgments.  This value SHOULD include the receiver&#8217;s expected delays in alarms firing.  For example, if a receiver sets a timer for 5ms and alarms commonly fire up to 1ms late, then it should send a max_ack_delay of 6ms.  If this value is absent, a default of 25 milliseconds is assumed.  Values of 2^14 or greater are invalid.</dd>
<dt>disable_migration (0x000c):</dt>
<dd style="margin-left: 8">The disable migration transport parameter is included if the endpoint does not support connection migration (<a href="#migration" class="xref">Section 9</a>). Peers of an endpoint that sets this transport parameter MUST NOT send any packets, including probing packets (<a href="#probing" class="xref">Section 9.1</a>), from a local address or port other than that used to perform the handshake.  This parameter is a zero-length value.</dd>
<dt>preferred_address (0x000d):</dt>
<dd style="margin-left: 8">The server&#8217;s preferred address is used to effect a change in server address at the end of the handshake, as described in <a href="#preferred-address" class="xref">Section 9.6</a>.  The format of this transport parameter is the PreferredAddress struct shown in <a href="#fig-preferred-address" class="xref">Figure 16</a>.  This transport parameter is only sent by a server.  Servers MAY choose to only send a preferred address of one address family by sending an all-zero address and port (0.0.0.0:0 or ::.0) for the other family.</dd>
</dl>
<div id="rfc.figure.16"></div>
<div id="fig-preferred-address"></div>
<pre>
   struct {
     opaque ipv4Address[4];
     uint16 ipv4Port;
     opaque ipv6Address[16];
     uint16 ipv6Port;
     opaque connectionId&lt;0..18&gt;;
     opaque statelessResetToken[16];
   } PreferredAddress;
</pre>
<p class="figure">Figure 16: Preferred Address format</p>
<p id="rfc.section.18.1.p.5">If present, transport parameters that set initial flow control limits (initial_max_stream_data_bidi_local, initial_max_stream_data_bidi_remote, and initial_max_stream_data_uni) are equivalent to sending a MAX_STREAM_DATA frame (<a href="#frame-max-stream-data" class="xref">Section 19.10</a>) on every stream of the corresponding type immediately after opening.  If the transport parameter is absent, streams of that type start with a flow control limit of 0.</p>
<p id="rfc.section.18.1.p.6">A client MUST NOT include an original connection ID, a stateless reset token, or a preferred address.  A server MUST treat receipt of any of these transport parameters as a connection error of type TRANSPORT_PARAMETER_ERROR.</p>
<h1 id="rfc.section.19">
<a href="#rfc.section.19">19.</a> <a href="#frame-formats" id="frame-formats">Frame Types and Formats</a>
</h1>
<p id="rfc.section.19.p.1">As described in <a href="#frames" class="xref">Section 12.4</a>, packets contain one or more frames. This section describes the format and semantics of the core QUIC frame types.</p>
<h2 id="rfc.section.19.1">
<a href="#rfc.section.19.1">19.1.</a> <a href="#frame-padding" id="frame-padding">PADDING Frame</a>
</h2>
<p id="rfc.section.19.1.p.1">The PADDING frame (type=0x00) has no semantic value.  PADDING frames can be used to increase the size of a packet.  Padding can be used to increase an initial client packet to the minimum required size, or to provide protection against traffic analysis for protected packets.</p>
<p id="rfc.section.19.1.p.2">A PADDING frame has no content.  That is, a PADDING frame consists of the single byte that identifies the frame as a PADDING frame.</p>
<h2 id="rfc.section.19.2">
<a href="#rfc.section.19.2">19.2.</a> <a href="#frame-ping" id="frame-ping">PING Frame</a>
</h2>
<p id="rfc.section.19.2.p.1">Endpoints can use PING frames (type=0x01) to verify that their peers are still alive or to check reachability to the peer. The PING frame contains no additional fields.</p>
<p id="rfc.section.19.2.p.2">The receiver of a PING frame simply needs to acknowledge the packet containing this frame.</p>
<p id="rfc.section.19.2.p.3">The PING frame can be used to keep a connection alive when an application or application protocol wishes to prevent the connection from timing out. An application protocol SHOULD provide guidance about the conditions under which generating a PING is recommended.  This guidance SHOULD indicate whether it is the client or the server that is expected to send the PING.  Having both endpoints send PING frames without coordination can produce an excessive number of packets and poor performance.</p>
<p id="rfc.section.19.2.p.4">A connection will time out if no packets are sent or received for a period longer than the time specified in the idle_timeout transport parameter (see <a href="#termination" class="xref">Section 10</a>).  However, state in middleboxes might time out earlier than that.  Though REQ-5 in <a href="#RFC4787" class="xref">[RFC4787]</a> recommends a 2 minute timeout interval, experience shows that sending packets every 15 to 30 seconds is necessary to prevent the majority of middleboxes from losing state for UDP flows.</p>
<h2 id="rfc.section.19.3">
<a href="#rfc.section.19.3">19.3.</a> <a href="#frame-ack" id="frame-ack">ACK Frames</a>
</h2>
<p id="rfc.section.19.3.p.1">Receivers send ACK frames (types 0x02 and 0x03) to inform senders of packets they have received and processed. The ACK frame contains one or more ACK Ranges.  ACK Ranges identify acknowledged packets. If the frame type is 0x03, ACK frames also contain the sum of QUIC packets with associated ECN marks received on the connection up until this point.  QUIC implementations MUST properly handle both types and, if they have enabled ECN for packets they send, they SHOULD use the information in the ECN section to manage their congestion state.</p>
<p id="rfc.section.19.3.p.2">QUIC acknowledgements are irrevocable.  Once acknowledged, a packet remains acknowledged, even if it does not appear in a future ACK frame.  This is unlike TCP SACKs (<a href="#RFC2018" class="xref">[RFC2018]</a>).</p>
<p id="rfc.section.19.3.p.3">It is expected that a sender will reuse the same packet number across different packet number spaces.  ACK frames only acknowledge the packet numbers that were transmitted by the sender in the same packet number space of the packet that the ACK was received in.</p>
<p id="rfc.section.19.3.p.4">Version Negotiation and Retry packets cannot be acknowledged because they do not contain a packet number.  Rather than relying on ACK frames, these packets are implicitly acknowledged by the next Initial packet sent by the client.</p>
<p id="rfc.section.19.3.p.5">An ACK frame is as follows:</p>
<div id="rfc.figure.17"></div>
<div id="ack-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Largest Acknowledged (i)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          ACK Delay (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       ACK Range Count (i)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       First ACK Range (i)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          ACK Ranges (*)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          [ECN Counts]                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 17: ACK Frame Format</p>
<p id="rfc.section.19.3.p.6">ACK frames contain the following fields:</p>
<p></p>

<dl>
<dt>Largest Acknowledged:</dt>
<dd style="margin-left: 8">A variable-length integer representing the largest packet number the peer is acknowledging; this is usually the largest packet number that the peer has received prior to generating the ACK frame.  Unlike the packet number in the QUIC long or short header, the value in an ACK frame is not truncated.</dd>
<dt>ACK Delay:</dt>
<dd style="margin-left: 8">A variable-length integer representing the time delta in microseconds between when this ACK was sent and when the largest acknowledged packet, as indicated in the Largest Acknowledged field, was received by this peer.  The value of the ACK Delay field is scaled by multiplying the encoded value by 2 to the power of the value of the <samp>ack_delay_exponent</samp> transport parameter set by the sender of the ACK frame.  The <samp>ack_delay_exponent</samp> defaults to 3, or a multiplier of 8 (see <a href="#transport-parameter-definitions" class="xref">Section 18.1</a>).  Scaling in this fashion allows for a larger range of values with a shorter encoding at the cost of lower resolution.</dd>
<dt>ACK Range Count:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the number of Gap and ACK Range fields in the frame.</dd>
<dt>First ACK Range:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of contiguous packets preceding the Largest Acknowledged that are being acknowledged.  The First ACK Range is encoded as an ACK Range (see <a href="#ack-ranges" class="xref">Section 19.3.1</a>) starting from the Largest Acknowledged.  That is, the smallest packet acknowledged in the range is determined by subtracting the First ACK Range value from the Largest Acknowledged.</dd>
<dt>ACK Ranges:</dt>
<dd style="margin-left: 8">Contains additional ranges of packets which are alternately not acknowledged (Gap) and acknowledged (ACK Range), see <a href="#ack-ranges" class="xref">Section 19.3.1</a>.</dd>
<dt>ECN Counts:</dt>
<dd style="margin-left: 8">The three ECN Counts, see <a href="#ack-ecn-counts" class="xref">Section 19.3.2</a>.</dd>
</dl>
<h3 id="rfc.section.19.3.1">
<a href="#rfc.section.19.3.1">19.3.1.</a> <a href="#ack-ranges" id="ack-ranges">ACK Ranges</a>
</h3>
<p id="rfc.section.19.3.1.p.1">The ACK Ranges field consists of alternating Gap and ACK Range values in descending packet number order.  The number of Gap and ACK Range values is determined by the ACK Range Count field; one of each value is present for each value in the ACK Range Count field.</p>
<p id="rfc.section.19.3.1.p.2">ACK Ranges are structured as follows:</p>
<div id="rfc.figure.18"></div>
<div id="ack-range-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           [Gap (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          [ACK Range (i)]                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           [Gap (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          [ACK Range (i)]                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           [Gap (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          [ACK Range (i)]                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 18: ACK Ranges</p>
<p id="rfc.section.19.3.1.p.3">The fields that form the ACK Ranges are:</p>
<p></p>

<dl>
<dt>Gap (repeated):</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of contiguous unacknowledged packets preceding the packet number one lower than the smallest in the preceding ACK Range.</dd>
<dt>ACK Range (repeated):</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of contiguous acknowledged packets preceding the largest packet number, as determined by the preceding Gap.</dd>
</dl>
<p id="rfc.section.19.3.1.p.5">Gap and ACK Range value use a relative integer encoding for efficiency.  Though each encoded value is positive, the values are subtracted, so that each ACK Range describes progressively lower-numbered packets.</p>
<p id="rfc.section.19.3.1.p.6">Each ACK Range acknowledges a contiguous range of packets by indicating the number of acknowledged packets that precede the largest packet number in that range.  A value of zero indicates that only the largest packet number is acknowledged.  Larger ACK Range values indicate a larger range, with corresponding lower values for the smallest packet number in the range.  Thus, given a largest packet number for the range, the smallest value is determined by the formula:</p>
<pre>
   smallest = largest - ack_range
</pre>
<p id="rfc.section.19.3.1.p.7">An ACK Range acknowledges all packets between the smallest packet number and the largest, inclusive.</p>
<p id="rfc.section.19.3.1.p.8">The largest value for an ACK Range is determined by cumulatively subtracting the size of all preceding ACK Ranges and Gaps.</p>
<p id="rfc.section.19.3.1.p.9">Each Gap indicates a range of packets that are not being acknowledged.  The number of packets in the gap is one higher than the encoded value of the Gap field.</p>
<p id="rfc.section.19.3.1.p.10">The value of the Gap field establishes the largest packet number value for the subsequent ACK Range using the following formula:</p>
<pre>
   largest = previous_smallest - gap - 2
</pre>
<p id="rfc.section.19.3.1.p.11">If any computed packet number is negative, an endpoint MUST generate a connection error of type FRAME_ENCODING_ERROR indicating an error in an ACK frame.</p>
<h3 id="rfc.section.19.3.2">
<a href="#rfc.section.19.3.2">19.3.2.</a> <a href="#ack-ecn-counts" id="ack-ecn-counts">ECN Counts</a>
</h3>
<p id="rfc.section.19.3.2.p.1">The ACK frame uses the least significant bit (that is, type 0x03) to indicate ECN feedback and report receipt of QUIC packets with associated ECN codepoints of ECT(0), ECT(1), or CE in the packet&#8217;s IP header.  ECN Counts are only present when the ACK frame type is 0x03.</p>
<p id="rfc.section.19.3.2.p.2">ECN Counts are only parsed when the ACK frame type is 0x03.  There are 3 ECN counts, as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        ECT(0) Count (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        ECT(1) Count (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        ECN-CE Count (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.3.2.p.3">The three ECN Counts are:</p>
<p></p>

<dl>
<dt>ECT(0) Count:</dt>
<dd style="margin-left: 8">A variable-length integer representing the total number of packets received with the ECT(0) codepoint.</dd>
<dt>ECT(1) Count:</dt>
<dd style="margin-left: 8">A variable-length integer representing the total number of packets received with the ECT(1) codepoint.</dd>
<dt>CE Count:</dt>
<dd style="margin-left: 8">A variable-length integer representing the total number of packets received with the CE codepoint.</dd>
</dl>
<p id="rfc.section.19.3.2.p.5">ECN counts are maintained separately for each packet number space.</p>
<h2 id="rfc.section.19.4">
<a href="#rfc.section.19.4">19.4.</a> <a href="#frame-reset-stream" id="frame-reset-stream">RESET_STREAM Frame</a>
</h2>
<p id="rfc.section.19.4.p.1">An endpoint uses a RESET_STREAM frame (type=0x04) to abruptly terminate the sending part of a stream.</p>
<p id="rfc.section.19.4.p.2">After sending a RESET_STREAM, an endpoint ceases transmission and retransmission of STREAM frames on the identified stream.  A receiver of RESET_STREAM can discard any data that it already received on that stream.</p>
<p id="rfc.section.19.4.p.3">An endpoint that receives a RESET_STREAM frame for a send-only stream MUST terminate the connection with error STREAM_STATE_ERROR.</p>
<p id="rfc.section.19.4.p.4">The RESET_STREAM frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Application Error Code (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Final Size (i)                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.4.p.5">RESET_STREAM frames contain the following fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer encoding of the Stream ID of the stream being terminated.</dd>
<dt>Application Protocol Error Code:</dt>
<dd style="margin-left: 8">A 16-bit application protocol error code (see <a href="#app-error-codes" class="xref">Section 20.1</a>) which indicates why the stream is being closed.</dd>
<dt>Final Size:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the final size of the stream by the RESET_STREAM sender, in unit of bytes.</dd>
</dl>
<h2 id="rfc.section.19.5">
<a href="#rfc.section.19.5">19.5.</a> <a href="#frame-stop-sending" id="frame-stop-sending">STOP_SENDING Frame</a>
</h2>
<p id="rfc.section.19.5.p.1">An endpoint uses a STOP_SENDING frame (type=0x05) to communicate that incoming data is being discarded on receipt at application request.  STOP_SENDING requests that a peer cease transmission on a stream.</p>
<p id="rfc.section.19.5.p.2">A STOP_SENDING frame can be sent for streams in the Recv or Size Known states (see <a href="#stream-send-states" class="xref">Section 3.1</a>). Receiving a STOP_SENDING frame for a locally-initiated stream that has not yet been created MUST be treated as a connection error of type STREAM_STATE_ERROR.  An endpoint that receives a STOP_SENDING frame for a receive-only stream MUST terminate the connection with error STREAM_STATE_ERROR.</p>
<p id="rfc.section.19.5.p.3">The STOP_SENDING frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Application Error Code (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.5.p.4">STOP_SENDING frames contain the following fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer carrying the Stream ID of the stream being ignored.</dd>
<dt>Application Error Code:</dt>
<dd style="margin-left: 8">A 16-bit, application-specified reason the sender is ignoring the stream (see <a href="#app-error-codes" class="xref">Section 20.1</a>).</dd>
</dl>
<h2 id="rfc.section.19.6">
<a href="#rfc.section.19.6">19.6.</a> <a href="#frame-crypto" id="frame-crypto">CRYPTO Frame</a>
</h2>
<p id="rfc.section.19.6.p.1">The CRYPTO frame (type=0x06) is used to transmit cryptographic handshake messages. It can be sent in all packet types. The CRYPTO frame offers the cryptographic protocol an in-order stream of bytes.  CRYPTO frames are functionally identical to STREAM frames, except that they do not bear a stream identifier; they are not flow controlled; and they do not carry markers for optional offset, optional length, and the end of the stream.</p>
<p id="rfc.section.19.6.p.2">The CRYPTO frame is as follows:</p>
<div id="rfc.figure.19"></div>
<div id="crypto-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Offset (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Length (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Crypto Data (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 19: CRYPTO Frame Format</p>
<p id="rfc.section.19.6.p.3">CRYPTO frames contain the following fields:</p>
<p></p>

<dl>
<dt>Offset:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the byte offset in the stream for the data in this CRYPTO frame.</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the Crypto Data field in this CRYPTO frame.</dd>
<dt>Crypto Data:</dt>
<dd style="margin-left: 8">The cryptographic message data.</dd>
</dl>
<p id="rfc.section.19.6.p.5">There is a separate flow of cryptographic handshake data in each encryption level, each of which starts at an offset of 0. This implies that each encryption level is treated as a separate CRYPTO stream of data.</p>
<p id="rfc.section.19.6.p.6">Unlike STREAM frames, which include a Stream ID indicating to which stream the data belongs, the CRYPTO frame carries data for a single stream per encryption level. The stream does not have an explicit end, so CRYPTO frames do not have a FIN bit.</p>
<h2 id="rfc.section.19.7">
<a href="#rfc.section.19.7">19.7.</a> <a href="#frame-new-token" id="frame-new-token">NEW_TOKEN Frame</a>
</h2>
<p id="rfc.section.19.7.p.1">A server sends a NEW_TOKEN frame (type=0x07) to provide the client with a token to send in the header of an Initial packet for a future connection.</p>
<p id="rfc.section.19.7.p.2">The NEW_TOKEN frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Token Length (i)  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Token (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.7.p.3">NEW_TOKEN frames contain the following fields:</p>
<p></p>

<dl>
<dt>Token Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the token in bytes.</dd>
<dt>Token:</dt>
<dd style="margin-left: 8">An opaque blob that the client may use with a future Initial packet.</dd>
</dl>
<h2 id="rfc.section.19.8">
<a href="#rfc.section.19.8">19.8.</a> <a href="#frame-stream" id="frame-stream">STREAM Frames</a>
</h2>
<p id="rfc.section.19.8.p.1">STREAM frames implicitly create a stream and carry stream data.  The STREAM frame takes the form 0b00001XXX (or the set of values from 0x08 to 0x0f).  The value of the three low-order bits of the frame type determine the fields that are present in the frame.</p>
<p></p>

<ul>
<li>The OFF bit (0x04) in the frame type is set to indicate that there is an Offset field present.  When set to 1, the Offset field is present.  When set to 0, the Offset field is absent and the Stream Data starts at an offset of 0 (that is, the frame contains the first bytes of the stream, or the end of a stream that includes no data).</li>
<li>The LEN bit (0x02) in the frame type is set to indicate that there is a Length field present.  If this bit is set to 0, the Length field is absent and the Stream Data field extends to the end of the packet.  If this bit is set to 1, the Length field is present.</li>
<li>The FIN bit (0x01) of the frame type is set only on frames that contain the final size of the stream.  Setting this bit indicates that the frame marks the end of the stream.</li>
</ul>
<p id="rfc.section.19.8.p.3">An endpoint that receives a STREAM frame for a send-only stream MUST terminate the connection with error STREAM_STATE_ERROR.</p>
<p id="rfc.section.19.8.p.4">The STREAM frames are as follows:</p>
<div id="rfc.figure.20"></div>
<div id="stream-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Stream ID (i)                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         [Offset (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         [Length (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream Data (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 20: STREAM Frame Format</p>
<p id="rfc.section.19.8.p.5">STREAM frames contain the following fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the stream ID of the stream (see <a href="#stream-id" class="xref">Section 2.1</a>).</dd>
<dt>Offset:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the byte offset in the stream for the data in this STREAM frame.  This field is present when the OFF bit is set to 1.  When the Offset field is absent, the offset is 0.</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the Stream Data field in this STREAM frame.  This field is present when the LEN bit is set to 1.  When the LEN bit is set to 0, the Stream Data field consumes all the remaining bytes in the packet.</dd>
<dt>Stream Data:</dt>
<dd style="margin-left: 8">The bytes from the designated stream to be delivered.</dd>
</dl>
<p id="rfc.section.19.8.p.7">When a Stream Data field has a length of 0, the offset in the STREAM frame is the offset of the next byte that would be sent.</p>
<p id="rfc.section.19.8.p.8">The first byte in the stream has an offset of 0.  The largest offset delivered on a stream - the sum of the offset and data length - cannot exceed 2^62-1, as it is not possible to provide flow control credit for that data.  Receipt of a frame that exceeds this limit will be treated as a connection error of type FLOW_CONTROL_ERROR.</p>
<h2 id="rfc.section.19.9">
<a href="#rfc.section.19.9">19.9.</a> <a href="#frame-max-data" id="frame-max-data">MAX_DATA Frame</a>
</h2>
<p id="rfc.section.19.9.p.1">The MAX_DATA frame (type=0x10) is used in flow control to inform the peer of the maximum amount of data that can be sent on the connection as a whole.</p>
<p id="rfc.section.19.9.p.2">The MAX_DATA frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Maximum Data (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.9.p.3">MAX_DATA frames contain the following fields:</p>
<p></p>

<dl>
<dt>Maximum Data:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the maximum amount of data that can be sent on the entire connection, in units of bytes.</dd>
</dl>
<p id="rfc.section.19.9.p.5">All data sent in STREAM frames counts toward this limit.  The sum of the largest received offsets on all streams - including streams in terminal states - MUST NOT exceed the value advertised by a receiver.  An endpoint MUST terminate a connection with a FLOW_CONTROL_ERROR error if it receives more data than the maximum data value that it has sent, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters" class="xref">Section 7.3.1</a>).</p>
<h2 id="rfc.section.19.10">
<a href="#rfc.section.19.10">19.10.</a> <a href="#frame-max-stream-data" id="frame-max-stream-data">MAX_STREAM_DATA Frame</a>
</h2>
<p id="rfc.section.19.10.p.1">The MAX_STREAM_DATA frame (type=0x11) is used in flow control to inform a peer of the maximum amount of data that can be sent on a stream.</p>
<p id="rfc.section.19.10.p.2">A MAX_STREAM_DATA frame can be sent for streams in the Recv state (see <a href="#stream-send-states" class="xref">Section 3.1</a>). Receiving a MAX_STREAM_DATA frame for a locally-initiated stream that has not yet been created MUST be treated as a connection error of type STREAM_STATE_ERROR.  An endpoint that receives a MAX_STREAM_DATA frame for a receive-only stream MUST terminate the connection with error STREAM_STATE_ERROR.</p>
<p id="rfc.section.19.10.p.3">The MAX_STREAM_DATA frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Maximum Stream Data (i)                  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.10.p.4">MAX_STREAM_DATA frames contain the following fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">The stream ID of the stream that is affected encoded as a variable-length integer.</dd>
<dt>Maximum Stream Data:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the maximum amount of data that can be sent on the identified stream, in units of bytes.</dd>
</dl>
<p id="rfc.section.19.10.p.6">When counting data toward this limit, an endpoint accounts for the largest received offset of data that is sent or received on the stream.  Loss or reordering can mean that the largest received offset on a stream can be greater than the total size of data received on that stream.  Receiving STREAM frames might not increase the largest received offset.</p>
<p id="rfc.section.19.10.p.7">The data sent on a stream MUST NOT exceed the largest maximum stream data value advertised by the receiver.  An endpoint MUST terminate a connection with a FLOW_CONTROL_ERROR error if it receives more data than the largest maximum stream data that it has sent for the affected stream, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters" class="xref">Section 7.3.1</a>).</p>
<h2 id="rfc.section.19.11">
<a href="#rfc.section.19.11">19.11.</a> <a href="#frame-max-streams" id="frame-max-streams">MAX_STREAMS Frames</a>
</h2>
<p id="rfc.section.19.11.p.1">The MAX_STREAMS frames (type=0x12 and 0x13) inform the peer of the cumulative number of streams of a given type it is permitted to open.  A MAX_STREAMS frame with a type of 0x12 applies to bidirectional streams, and a MAX_STREAMS frame with a type of 0x13 applies to unidirectional streams.</p>
<p id="rfc.section.19.11.p.2">The MAX_STREAMS frames are as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Maximum Streams (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.11.p.3">MAX_STREAMS frames contain the following fields:</p>
<p></p>

<dl>
<dt>Maximum Streams:</dt>
<dd style="margin-left: 8">A count of the cumulative number of streams of the corresponding type that can be opened over the lifetime of the connection.</dd>
</dl>
<p id="rfc.section.19.11.p.5">Loss or reordering can cause a MAX_STREAMS frame to be received which states a lower stream limit than an endpoint has previously received.  MAX_STREAMS frames which do not increase the stream limit MUST be ignored.</p>
<p id="rfc.section.19.11.p.6">An endpoint MUST NOT open more streams than permitted by the current stream limit set by its peer.  For instance, a server that receives a unidirectional stream limit of 3 is permitted to open stream 3, 7, and 11, but not stream 15.  An endpoint MUST terminate a connection with a STREAM_LIMIT_ERROR error if a peer opens more streams than was permitted.</p>
<p id="rfc.section.19.11.p.7">Note that these frames (and the corresponding transport parameters) do not describe the number of streams that can be opened concurrently.  The limit includes streams that have been closed as well as those that are open.</p>
<h2 id="rfc.section.19.12">
<a href="#rfc.section.19.12">19.12.</a> <a href="#frame-data-blocked" id="frame-data-blocked">DATA_BLOCKED Frame</a>
</h2>
<p id="rfc.section.19.12.p.1">A sender SHOULD send a DATA_BLOCKED frame (type=0x14) when it wishes to send data, but is unable to due to connection-level flow control (see <a href="#flow-control" class="xref">Section 4</a>).  DATA_BLOCKED frames can be used as input to tuning of flow control algorithms (see <a href="#fc-credit" class="xref">Section 4.2</a>).</p>
<p id="rfc.section.19.12.p.2">The DATA_BLOCKED frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Data Limit (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.12.p.3">DATA_BLOCKED frames contain the following fields:</p>
<p></p>

<dl>
<dt>Data Limit:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the connection-level limit at which blocking occurred.</dd>
</dl>
<h2 id="rfc.section.19.13">
<a href="#rfc.section.19.13">19.13.</a> <a href="#frame-stream-data-blocked" id="frame-stream-data-blocked">STREAM_DATA_BLOCKED Frame</a>
</h2>
<p id="rfc.section.19.13.p.1">A sender SHOULD send a STREAM_DATA_BLOCKED frame (type=0x15) when it wishes to send data, but is unable to due to stream-level flow control.  This frame is analogous to DATA_BLOCKED (<a href="#frame-data-blocked" class="xref">Section 19.12</a>).</p>
<p id="rfc.section.19.13.p.2">An endpoint that receives a STREAM_DATA_BLOCKED frame for a send-only stream MUST terminate the connection with error STREAM_STATE_ERROR.</p>
<p id="rfc.section.19.13.p.3">The STREAM_DATA_BLOCKED frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Stream Data Limit (i)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.13.p.4">STREAM_DATA_BLOCKED frames contain the following fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the stream which is flow control blocked.</dd>
<dt>Stream Data Limit:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the offset of the stream at which the blocking occurred.</dd>
</dl>
<h2 id="rfc.section.19.14">
<a href="#rfc.section.19.14">19.14.</a> <a href="#frame-streams-blocked" id="frame-streams-blocked">STREAMS_BLOCKED Frames</a>
</h2>
<p id="rfc.section.19.14.p.1">A sender SHOULD send a STREAMS_BLOCKED frame (type=0x16 or 0x17) when it wishes to open a stream, but is unable to due to the maximum stream limit set by its peer (see <a href="#frame-max-streams" class="xref">Section 19.11</a>).  A STREAMS_BLOCKED frame of type 0x16 is used to indicate reaching the bidirectional stream limit, and a STREAMS_BLOCKED frame of type 0x17 indicates reaching the unidirectional stream limit.</p>
<p id="rfc.section.19.14.p.2">A STREAMS_BLOCKED frame does not open the stream, but informs the peer that a new stream was needed and the stream limit prevented the creation of the stream.</p>
<p id="rfc.section.19.14.p.3">The STREAMS_BLOCKED frames are as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream Limit (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.14.p.4">STREAMS_BLOCKED frames contain the following fields:</p>
<p></p>

<dl>
<dt>Stream Limit:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the stream limit at the time the frame was sent.</dd>
</dl>
<h2 id="rfc.section.19.15">
<a href="#rfc.section.19.15">19.15.</a> <a href="#frame-new-connection-id" id="frame-new-connection-id">NEW_CONNECTION_ID Frame</a>
</h2>
<p id="rfc.section.19.15.p.1">An endpoint sends a NEW_CONNECTION_ID frame (type=0x18) to provide its peer with alternative connection IDs that can be used to break linkability when migrating connections (see <a href="#migration-linkability" class="xref">Section 9.5</a>).</p>
<p id="rfc.section.19.15.p.2">The NEW_CONNECTION_ID frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Sequence Number (i)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Length (8)  |                                               |
+-+-+-+-+-+-+-+-+       Connection ID (32..144)                 +
|                                                             ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                   Stateless Reset Token (128)                 +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.15.p.3">NEW_CONNECTION_ID frames contain the following fields:</p>
<p></p>

<dl>
<dt>Sequence Number:</dt>
<dd style="margin-left: 8">The sequence number assigned to the connection ID by the sender.  See <a href="#issue-cid" class="xref">Section 5.1.1</a>.</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">An 8-bit unsigned integer containing the length of the connection ID.  Values less than 4 and greater than 18 are invalid and MUST be treated as a connection error of type PROTOCOL_VIOLATION.</dd>
<dt>Connection ID:</dt>
<dd style="margin-left: 8">A connection ID of the specified length.</dd>
<dt>Stateless Reset Token:</dt>
<dd style="margin-left: 8">A 128-bit value that will be used for a stateless reset when the associated connection ID is used (see <a href="#stateless-reset" class="xref">Section 10.4</a>).</dd>
</dl>
<p id="rfc.section.19.15.p.5">An endpoint MUST NOT send this frame if it currently requires that its peer send packets with a zero-length Destination Connection ID.  Changing the length of a connection ID to or from zero-length makes it difficult to identify when the value of the connection ID changed.  An endpoint that is sending packets with a zero-length Destination Connection ID MUST treat receipt of a NEW_CONNECTION_ID frame as a connection error of type PROTOCOL_VIOLATION.</p>
<p id="rfc.section.19.15.p.6">Transmission errors, timeouts and retransmissions might cause the same NEW_CONNECTION_ID frame to be received multiple times.  Receipt of the same frame multiple times MUST NOT be treated as a connection error.  A receiver can use the sequence number supplied in the NEW_CONNECTION_ID frame to identify new connection IDs from old ones.</p>
<p id="rfc.section.19.15.p.7">If an endpoint receives a NEW_CONNECTION_ID frame that repeats a previously issued connection ID with a different Stateless Reset Token or a different sequence number, or if a sequence number is used for different connection IDs, the endpoint MAY treat that receipt as a connection error of type PROTOCOL_VIOLATION.</p>
<h2 id="rfc.section.19.16">
<a href="#rfc.section.19.16">19.16.</a> <a href="#frame-retire-connection-id" id="frame-retire-connection-id">RETIRE_CONNECTION_ID Frame</a>
</h2>
<p id="rfc.section.19.16.p.1">An endpoint sends a RETIRE_CONNECTION_ID frame (type=0x19) to indicate that it will no longer use a connection ID that was issued by its peer. This may include the connection ID provided during the handshake.  Sending a RETIRE_CONNECTION_ID frame also serves as a request to the peer to send additional connection IDs for future use (see <a href="#connection-id" class="xref">Section 5.1</a>).  New connection IDs can be delivered to a peer using the NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).</p>
<p id="rfc.section.19.16.p.2">Retiring a connection ID invalidates the stateless reset token associated with that connection ID.</p>
<p id="rfc.section.19.16.p.3">The RETIRE_CONNECTION_ID frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Sequence Number (i)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.16.p.4">RETIRE_CONNECTION_ID frames contain the following fields:</p>
<p></p>

<dl>
<dt>Sequence Number:</dt>
<dd style="margin-left: 8">The sequence number of the connection ID being retired.  See <a href="#retiring-cids" class="xref">Section 5.1.2</a>.</dd>
</dl>
<p id="rfc.section.19.16.p.6">Receipt of a RETIRE_CONNECTION_ID frame containing a sequence number greater than any previously sent to the peer MAY be treated as a connection error of type PROTOCOL_VIOLATION.</p>
<p id="rfc.section.19.16.p.7">The sequence number specified in a RETIRE_CONNECTION_ID frame MUST NOT refer to the Destination Connection ID field of the packet in which the frame is contained.  The peer MAY treat this as a connection error of type PROTOCOL_VIOLATION.</p>
<p id="rfc.section.19.16.p.8">An endpoint cannot send this frame if it was provided with a zero-length connection ID by its peer.  An endpoint that provides a zero-length connection ID MUST treat receipt of a RETIRE_CONNECTION_ID frame as a connection error of type PROTOCOL_VIOLATION.</p>
<h2 id="rfc.section.19.17">
<a href="#rfc.section.19.17">19.17.</a> <a href="#frame-path-challenge" id="frame-path-challenge">PATH_CHALLENGE Frame</a>
</h2>
<p id="rfc.section.19.17.p.1">Endpoints can use PATH_CHALLENGE frames (type=0x1a) to check reachability to the peer and for path validation during connection migration.</p>
<p id="rfc.section.19.17.p.2">The PATH_CHALLENGE frames are as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                           Data (64)                           +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.17.p.3">PATH_CHALLENGE frames contain the following fields:</p>
<p></p>

<dl>
<dt>Data:</dt>
<dd style="margin-left: 8">This 8-byte field contains arbitrary data.</dd>
</dl>
<p id="rfc.section.19.17.p.5">A PATH_CHALLENGE frame containing 8 bytes that are hard to guess is sufficient to ensure that it is easier to receive the packet than it is to guess the value correctly.</p>
<p id="rfc.section.19.17.p.6">The recipient of this frame MUST generate a PATH_RESPONSE frame (<a href="#frame-path-response" class="xref">Section 19.18</a>) containing the same Data.</p>
<h2 id="rfc.section.19.18">
<a href="#rfc.section.19.18">19.18.</a> <a href="#frame-path-response" id="frame-path-response">PATH_RESPONSE Frame</a>
</h2>
<p id="rfc.section.19.18.p.1">The PATH_RESPONSE frame (type=0x1b) is sent in response to a PATH_CHALLENGE frame.  Its format is identical to the PATH_CHALLENGE frame (<a href="#frame-path-challenge" class="xref">Section 19.17</a>).</p>
<p id="rfc.section.19.18.p.2">If the content of a PATH_RESPONSE frame does not match the content of a PATH_CHALLENGE frame previously sent by the endpoint, the endpoint MAY generate a connection error of type PROTOCOL_VIOLATION.</p>
<h2 id="rfc.section.19.19">
<a href="#rfc.section.19.19">19.19.</a> <a href="#frame-connection-close" id="frame-connection-close">CONNECTION_CLOSE Frames</a>
</h2>
<p id="rfc.section.19.19.p.1">An endpoint sends a CONNECTION_CLOSE frame (type=0x1c or 0x1d) to notify its peer that the connection is being closed.  The CONNECTION_CLOSE with a frame type of 0x1c is used to signal errors at only the QUIC layer, or the absence of errors (with the NO_ERROR code).  The CONNECTION_CLOSE frame with a type of 0x1d is used to signal an error with the application that uses QUIC.</p>
<p id="rfc.section.19.19.p.2">If there are open streams that haven&#8217;t been explicitly closed, they are implicitly closed when the connection is closed.</p>
<p id="rfc.section.19.19.p.3">The CONNECTION_CLOSE frames are as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Error Code (16)     |      [ Frame Type (i) ]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Reason Phrase Length (i)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Reason Phrase (*)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.19.19.p.4">CONNECTION_CLOSE frames contain the following fields:</p>
<p></p>

<dl>
<dt>Error Code:</dt>
<dd style="margin-left: 8">A 16-bit error code which indicates the reason for closing this connection.  A CONNECTION_CLOSE frame of type 0x1c uses codes from the space defined in <a href="#error-codes" class="xref">Section 20</a>.  A CONNECTION_CLOSE frame of type 0x1d uses codes from the application protocol error code space, see <a href="#app-error-codes" class="xref">Section 20.1</a>
</dd>
<dt>Frame Type:</dt>
<dd style="margin-left: 8">A variable-length integer encoding the type of frame that triggered the error.  A value of 0 (equivalent to the mention of the PADDING frame) is used when the frame type is unknown.  The application-specific variant of CONNECTION_CLOSE (type 0x1d) does not include this field.</dd>
<dt>Reason Phrase Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the reason phrase in bytes.  Because a CONNECTION_CLOSE frame cannot be split between packets, any limits on packet size will also limit the space available for a reason phrase.</dd>
<dt>Reason Phrase:</dt>
<dd style="margin-left: 8">A human-readable explanation for why the connection was closed.  This can be zero length if the sender chooses to not give details beyond the Error Code.  This SHOULD be a UTF-8 encoded string <a href="#RFC3629" class="xref">[RFC3629]</a>.</dd>
</dl>
<h2 id="rfc.section.19.20">
<a href="#rfc.section.19.20">19.20.</a> <a href="#extension-frames" id="extension-frames">Extension Frames</a>
</h2>
<p id="rfc.section.19.20.p.1">QUIC frames do not use a self-describing encoding.  An endpoint therefore needs to understand the syntax of all frames before it can successfully process a packet.  This allows for efficient encoding of frames, but it means that an endpoint cannot send a frame of a type that is unknown to its peer.</p>
<p id="rfc.section.19.20.p.2">An extension to QUIC that wishes to use a new type of frame MUST first ensure that a peer is able to understand the frame.  An endpoint can use a transport parameter to signal its willingness to receive one or more extension frame types with the one transport parameter.</p>
<p id="rfc.section.19.20.p.3">Extension frames MUST be congestion controlled and MUST cause an ACK frame to be sent.  The exception is extension frames that replace or supplement the ACK frame.  Extension frames are not included in flow control unless specified in the extension.</p>
<p id="rfc.section.19.20.p.4">An IANA registry is used to manage the assignment of frame types, see <a href="#iana-frames" class="xref">Section 22.2</a>.</p>
<h1 id="rfc.section.20">
<a href="#rfc.section.20">20.</a> <a href="#error-codes" id="error-codes">Transport Error Codes</a>
</h1>
<p id="rfc.section.20.p.1">QUIC error codes are 16-bit unsigned integers.</p>
<p id="rfc.section.20.p.2">This section lists the defined QUIC transport error codes that may be used in a CONNECTION_CLOSE frame.  These errors apply to the entire connection.</p>
<p></p>

<dl>
<dt>NO_ERROR (0x0):</dt>
<dd style="margin-left: 8">An endpoint uses this with CONNECTION_CLOSE to signal that the connection is being closed abruptly in the absence of any error.</dd>
<dt>INTERNAL_ERROR (0x1):</dt>
<dd style="margin-left: 8">The endpoint encountered an internal error and cannot continue with the connection.</dd>
<dt>SERVER_BUSY (0x2):</dt>
<dd style="margin-left: 8">The server is currently busy and does not accept any new connections.</dd>
<dt>FLOW_CONTROL_ERROR (0x3):</dt>
<dd style="margin-left: 8">An endpoint received more data than it permitted in its advertised data limits (see <a href="#flow-control" class="xref">Section 4</a>).</dd>
<dt>STREAM_LIMIT_ERROR (0x4):</dt>
<dd style="margin-left: 8">An endpoint received a frame for a stream identifier that exceeded its advertised stream limit for the corresponding stream type.</dd>
<dt>STREAM_STATE_ERROR (0x5):</dt>
<dd style="margin-left: 8">An endpoint received a frame for a stream that was not in a state that permitted that frame (see <a href="#stream-states" class="xref">Section 3</a>).</dd>
<dt>FINAL_SIZE_ERROR (0x6):</dt>
<dd style="margin-left: 8">An endpoint received a STREAM frame containing data that exceeded the previously established final size.  Or an endpoint received a STREAM frame or a RESET_STREAM frame containing a final size that was lower than the size of stream data that was already received.  Or an endpoint received a STREAM frame or a RESET_STREAM frame containing a different final size to the one already established.</dd>
<dt>FRAME_ENCODING_ERROR (0x7):</dt>
<dd style="margin-left: 8">An endpoint received a frame that was badly formatted.  For instance, a frame of an unknown type, or an ACK frame that has more acknowledgment ranges than the remainder of the packet could carry.</dd>
<dt>TRANSPORT_PARAMETER_ERROR (0x8):</dt>
<dd style="margin-left: 8">An endpoint received transport parameters that were badly formatted, included an invalid value, was absent even though it is mandatory, was present though it is forbidden, or is otherwise in error.</dd>
<dt>PROTOCOL_VIOLATION (0xA):</dt>
<dd style="margin-left: 8">An endpoint detected an error with protocol compliance that was not covered by more specific error codes.</dd>
<dt>INVALID_MIGRATION (0xC):</dt>
<dd style="margin-left: 8">A peer has migrated to a different network when the endpoint had disabled migration.</dd>
<dt>CRYPTO_BUFFER_EXCEEDED (0xD):</dt>
<dd style="margin-left: 8">An endpoint has received more data in CRYPTO frames than it can buffer.</dd>
<dt>CRYPTO_ERROR (0x1XX):</dt>
<dd style="margin-left: 8">The cryptographic handshake failed.  A range of 256 values is reserved for carrying error codes specific to the cryptographic handshake that is used.  Codes for errors occurring when TLS is used for the crypto handshake are described in Section 4.8 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</dd>
</dl>
<p id="rfc.section.20.p.4">See <a href="#iana-error-codes" class="xref">Section 22.3</a> for details of registering new error codes.</p>
<h2 id="rfc.section.20.1">
<a href="#rfc.section.20.1">20.1.</a> <a href="#app-error-codes" id="app-error-codes">Application Protocol Error Codes</a>
</h2>
<p id="rfc.section.20.1.p.1">Application protocol error codes are 16-bit unsigned integers, but the management of application error codes are left to application protocols.  Application protocol error codes are used for the RESET_STREAM frame (<a href="#frame-reset-stream" class="xref">Section 19.4</a>), the STOP_SENDING frame (<a href="#frame-stop-sending" class="xref">Section 19.5</a>), and the CONNECTION_CLOSE frame with a type of 0x1d (<a href="#frame-connection-close" class="xref">Section 19.19</a>).</p>
<h1 id="rfc.section.21">
<a href="#rfc.section.21">21.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h2 id="rfc.section.21.1">
<a href="#rfc.section.21.1">21.1.</a> <a href="#handshake-denial-of-service" id="handshake-denial-of-service">Handshake Denial of Service</a>
</h2>
<p id="rfc.section.21.1.p.1">As an encrypted and authenticated transport QUIC provides a range of protections against denial of service.  Once the cryptographic handshake is complete, QUIC endpoints discard most packets that are not authenticated, greatly limiting the ability of an attacker to interfere with existing connections.</p>
<p id="rfc.section.21.1.p.2">Once a connection is established QUIC endpoints might accept some unauthenticated ICMP packets (see <a href="#icmp-pmtud" class="xref">Section 14.2</a>), but the use of these packets is extremely limited.  The only other type of packet that an endpoint might accept is a stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) which relies on the token being kept secret until it is used.</p>
<p id="rfc.section.21.1.p.3">During the creation of a connection, QUIC only provides protection against attack from off the network path.  All QUIC packets contain proof that the recipient saw a preceding packet from its peer.</p>
<p id="rfc.section.21.1.p.4">The first mechanism used is the source and destination connection IDs, which are required to match those set by a peer.  Except for an Initial and stateless reset packets, an endpoint only accepts packets that include a destination connection that matches a connection ID the endpoint previously chose.  This is the only protection offered for Version Negotiation packets.</p>
<p id="rfc.section.21.1.p.5">The destination connection ID in an Initial packet is selected by a client to be unpredictable, which serves an additional purpose.  The packets that carry the cryptographic handshake are protected with a key that is derived from this connection ID and salt specific to the QUIC version.  This allows endpoints to use the same process for authenticating packets that they receive as they use after the cryptographic handshake completes.  Packets that cannot be authenticated are discarded.  Protecting packets in this fashion provides a strong assurance that the sender of the packet saw the Initial packet and understood it.</p>
<p id="rfc.section.21.1.p.6">These protections are not intended to be effective against an attacker that is able to receive QUIC packets prior to the connection being established.  Such an attacker can potentially send packets that will be accepted by QUIC endpoints.  This version of QUIC attempts to detect this sort of attack, but it expects that endpoints will fail to establish a connection rather than recovering.  For the most part, the cryptographic handshake protocol <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> is responsible for detecting tampering during the handshake.</p>
<p id="rfc.section.21.1.p.7">Endpoints are permitted to use other methods to detect and attempt to recover from interference with the handshake.  Invalid packets may be identified and discarded using other methods, but no specific method is mandated in this document.</p>
<h2 id="rfc.section.21.2">
<a href="#rfc.section.21.2">21.2.</a> <a href="#amplification-attack" id="amplification-attack">Amplification Attack</a>
</h2>
<p id="rfc.section.21.2.p.1">An attacker might be able to receive an address validation token (<a href="#address-validation" class="xref">Section 8</a>) from a server and then release the IP address it used to acquire that token.  At a later time, the attacker may initiate a 0-RTT connection with a server by spoofing this same address, which might now address a different (victim) endpoint.  The attacker can thus potentially cause the server to send an initial congestion window&#8217;s worth of data towards the victim.</p>
<p id="rfc.section.21.2.p.2">Servers SHOULD provide mitigations for this attack by limiting the usage and lifetime of address validation tokens (see <a href="#validate-future" class="xref">Section 8.1.2</a>).</p>
<h2 id="rfc.section.21.3">
<a href="#rfc.section.21.3">21.3.</a> <a href="#optimistic-ack-attack" id="optimistic-ack-attack">Optimistic ACK Attack</a>
</h2>
<p id="rfc.section.21.3.p.1">An endpoint that acknowledges packets it has not received might cause a congestion controller to permit sending at rates beyond what the network supports.  An endpoint MAY skip packet numbers when sending packets to detect this behavior.  An endpoint can then immediately close the connection with a connection error of type PROTOCOL_VIOLATION (see <a href="#immediate-close" class="xref">Section 10.3</a>).</p>
<h2 id="rfc.section.21.4">
<a href="#rfc.section.21.4">21.4.</a> <a href="#slowloris-attacks" id="slowloris-attacks">Slowloris Attacks</a>
</h2>
<p id="rfc.section.21.4.p.1">The attacks commonly known as Slowloris <a href="#SLOWLORIS" class="xref">[SLOWLORIS]</a> try to keep many connections to the target endpoint open and hold them open as long as possible.  These attacks can be executed against a QUIC endpoint by generating the minimum amount of activity necessary to avoid being closed for inactivity.  This might involve sending small amounts of data, gradually opening flow control windows in order to control the sender rate, or manufacturing ACK frames that simulate a high loss rate.</p>
<p id="rfc.section.21.4.p.2">QUIC deployments SHOULD provide mitigations for the Slowloris attacks, such as increasing the maximum number of clients the server will allow, limiting the number of connections a single IP address is allowed to make, imposing restrictions on the minimum transfer speed a connection is allowed to have, and restricting the length of time an endpoint is allowed to stay connected.</p>
<h2 id="rfc.section.21.5">
<a href="#rfc.section.21.5">21.5.</a> <a href="#stream-fragmentation-and-reassembly-attacks" id="stream-fragmentation-and-reassembly-attacks">Stream Fragmentation and Reassembly Attacks</a>
</h2>
<p id="rfc.section.21.5.p.1">An adversarial sender might intentionally send fragments of stream data in order to cause disproportionate receive buffer memory commitment and/or creation of a large and inefficient data structure.</p>
<p id="rfc.section.21.5.p.2">An adversarial receiver might intentionally not acknowledge packets containing stream data in order to force the sender to store the unacknowledged stream data for retransmission.</p>
<p id="rfc.section.21.5.p.3">The attack on receivers is mitigated if flow control windows correspond to available memory.  However, some receivers will over-commit memory and advertise flow control offsets in the aggregate that exceed actual available memory.  The over-commitment strategy can lead to better performance when endpoints are well behaved, but renders endpoints vulnerable to the stream fragmentation attack.</p>
<p id="rfc.section.21.5.p.4">QUIC deployments SHOULD provide mitigations against stream fragmentation attacks.  Mitigations could consist of avoiding over-committing memory, limiting the size of tracking data structures, delaying reassembly of STREAM frames, implementing heuristics based on the age and duration of reassembly holes, or some combination.</p>
<h2 id="rfc.section.21.6">
<a href="#rfc.section.21.6">21.6.</a> <a href="#stream-commitment-attack" id="stream-commitment-attack">Stream Commitment Attack</a>
</h2>
<p id="rfc.section.21.6.p.1">An adversarial endpoint can open lots of streams, exhausting state on an endpoint.  The adversarial endpoint could repeat the process on a large number of connections, in a manner similar to SYN flooding attacks in TCP.</p>
<p id="rfc.section.21.6.p.2">Normally, clients will open streams sequentially, as explained in <a href="#stream-id" class="xref">Section 2.1</a>.  However, when several streams are initiated at short intervals, transmission error may cause STREAM DATA frames opening streams to be received out of sequence.  A receiver is obligated to open intervening streams if a higher-numbered stream ID is received.  Thus, on a new connection, opening stream 2000001 opens 1 million streams, as required by the specification.</p>
<p id="rfc.section.21.6.p.3">The number of active streams is limited by the initial_max_streams_bidi and initial_max_streams_uni transport parameters, as explained in <a href="#controlling-concurrency" class="xref">Section 4.5</a>.  If chosen judiciously, these limits mitigate the effect of the stream commitment attack.  However, setting the limit too low could affect performance when applications expect to open large number of streams.</p>
<h2 id="rfc.section.21.7">
<a href="#rfc.section.21.7">21.7.</a> <a href="#security-ecn" id="security-ecn">Explicit Congestion Notification Attacks</a>
</h2>
<p id="rfc.section.21.7.p.1">An on-path attacker could manipulate the value of ECN codepoints in the IP header to influence the sender&#8217;s rate. <a href="#RFC3168" class="xref">[RFC3168]</a> discusses manipulations and their effects in more detail.</p>
<p id="rfc.section.21.7.p.2">An on-the-side attacker can duplicate and send packets with modified ECN codepoints to affect the sender&#8217;s rate.  If duplicate packets are discarded by a receiver, an off-path attacker will need to race the duplicate packet against the original to be successful in this attack.  Therefore, QUIC receivers ignore ECN codepoints set in duplicate packets (see <a href="#ecn" class="xref">Section 13.3</a>).</p>
<h2 id="rfc.section.21.8">
<a href="#rfc.section.21.8">21.8.</a> <a href="#reset-oracle" id="reset-oracle">Stateless Reset Oracle</a>
</h2>
<p id="rfc.section.21.8.p.1">Stateless resets create a possible denial of service attack analogous to a TCP reset injection. This attack is possible if an attacker is able to cause a stateless reset token to be generated for a connection with a selected connection ID. An attacker that can cause this token to be generated can reset an active connection with the same connection ID.</p>
<p id="rfc.section.21.8.p.2">If a packet can be routed to different instances that share a static key, for example by changing an IP address or port, then an attacker can cause the server to send a stateless reset.  To defend against this style of denial service, endpoints that share a static key for stateless reset (see <a href="#reset-token" class="xref">Section 10.4.2</a>) MUST be arranged so that packets with a given connection ID always arrive at an instance that has connection state, unless that connection is no longer active.</p>
<p id="rfc.section.21.8.p.3">In the case of a cluster that uses dynamic load balancing, it&#8217;s possible that a change in load balancer configuration could happen while an active instance retains connection state; even if an instance retains connection state, the change in routing and resulting stateless reset will result in the connection being terminated.  If there is no chance in the packet being routed to the correct instance, it is better to send a stateless reset than wait for connections to time out.  However, this is acceptable only if the routing cannot be influenced by an attacker.</p>
<h2 id="rfc.section.21.9">
<a href="#rfc.section.21.9">21.9.</a> <a href="#version-downgrade" id="version-downgrade">Version Downgrade</a>
</h2>
<p id="rfc.section.21.9.p.1">This document defines QUIC Version Negotiation packets <a href="#version-negotiation" class="xref">Section 6</a>, which can be used to negotiate the QUIC version used between two endpoints.  However, this document does not specify how this negotiation will be performed between this version and subsequent future versions.  In particular, Version Negotiation packets do not contain any mechanism to prevent version downgrade attacks.  Future versions of QUIC that use Version Negotiation packets MUST define a mechanism that is robust against version downgrade attacks.</p>
<h1 id="rfc.section.22">
<a href="#rfc.section.22">22.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h2 id="rfc.section.22.1">
<a href="#rfc.section.22.1">22.1.</a> <a href="#iana-transport-parameters" id="iana-transport-parameters">QUIC Transport Parameter Registry</a>
</h2>
<p id="rfc.section.22.1.p.1">IANA [SHALL add/has added] a registry for &#8220;QUIC Transport Parameters&#8221; under a &#8220;QUIC Protocol&#8221; heading.</p>
<p id="rfc.section.22.1.p.2">The &#8220;QUIC Transport Parameters&#8221; registry governs a 16-bit space.  This space is split into two spaces that are governed by different policies.  Values with the first byte in the range 0x00 to 0xfe (in hexadecimal) are assigned via the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>.  Values with the first byte 0xff are reserved for Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.22.1.p.3">Registrations MUST include the following fields:</p>
<p></p>

<dl>
<dt>Value:</dt>
<dd style="margin-left: 8">The numeric value of the assignment (registrations will be between 0x0000 and 0xfeff).</dd>
<dt>Parameter Name:</dt>
<dd style="margin-left: 8">A short mnemonic for the parameter.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a publicly available specification for the value.</dd>
</dl>
<p id="rfc.section.22.1.p.5">The nominated expert(s) verify that a specification exists and is readily accessible.  Expert(s) are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing, or architecturally dubious).</p>
<p id="rfc.section.22.1.p.6">The initial contents of this registry are shown in <a href="#iana-tp-table" class="xref">Table 6</a>.</p>
<div id="rfc.table.6"></div>
<div id="iana-tp-table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Initial QUIC Transport Parameters Entries</caption>
<thead><tr>
<th class="left">Value</th>
<th class="left">Parameter Name</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x0000</td>
<td class="left">original_connection_id</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0001</td>
<td class="left">idle_timeout</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0002</td>
<td class="left">stateless_reset_token</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0003</td>
<td class="left">max_packet_size</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0004</td>
<td class="left">initial_max_data</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0005</td>
<td class="left">initial_max_stream_data_bidi_local</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0006</td>
<td class="left">initial_max_stream_data_bidi_remote</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0007</td>
<td class="left">initial_max_stream_data_uni</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0008</td>
<td class="left">initial_max_streams_bidi</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x0009</td>
<td class="left">initial_max_streams_uni</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x000a</td>
<td class="left">ack_delay_exponent</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x000b</td>
<td class="left">max_ack_delay</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x000c</td>
<td class="left">disable_migration</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
<tr>
<td class="left">0x000d</td>
<td class="left">preferred_address</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 18.1</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.22.2">
<a href="#rfc.section.22.2">22.2.</a> <a href="#iana-frames" id="iana-frames">QUIC Frame Type Registry</a>
</h2>
<p id="rfc.section.22.2.p.1">IANA [SHALL add/has added] a registry for &#8220;QUIC Frame Types&#8221; under a &#8220;QUIC Protocol&#8221; heading.</p>
<p id="rfc.section.22.2.p.2">The &#8220;QUIC Frame Types&#8221; registry governs a 62-bit space.  This space is split into three spaces that are governed by different policies.  Values between 0x00 and 0x3f (in hexadecimal) are assigned via the Standards Action or IESG Review policies <a href="#RFC8126" class="xref">[RFC8126]</a>.  Values from 0x40 to 0x3fff operate on the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>.  All other values are assigned to Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.22.2.p.3">Registrations MUST include the following fields:</p>
<p></p>

<dl>
<dt>Value:</dt>
<dd style="margin-left: 8">The numeric value of the assignment (registrations will be between 0x00 and 0x3fff).  A range of values MAY be assigned.</dd>
<dt>Frame Name:</dt>
<dd style="margin-left: 8">A short mnemonic for the frame type.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a publicly available specification for the value.</dd>
</dl>
<p id="rfc.section.22.2.p.5">The nominated expert(s) verify that a specification exists and is readily accessible.  Specifications for new registrations need to describe the means by which an endpoint might determine that it can send the identified type of frame.  An accompanying transport parameter registration (see <a href="#iana-transport-parameters" class="xref">Section 22.1</a>) is expected for most registrations.  The specification needs to describe the format and assigned semantics of any fields in the frame.</p>
<p id="rfc.section.22.2.p.6">Expert(s) are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing, or architecturally dubious).</p>
<p id="rfc.section.22.2.p.7">The initial contents of this registry are tabulated in <a href="#frame-types" class="xref">Table 3</a>.</p>
<h2 id="rfc.section.22.3">
<a href="#rfc.section.22.3">22.3.</a> <a href="#iana-error-codes" id="iana-error-codes">QUIC Transport Error Codes Registry</a>
</h2>
<p id="rfc.section.22.3.p.1">IANA [SHALL add/has added] a registry for &#8220;QUIC Transport Error Codes&#8221; under a &#8220;QUIC Protocol&#8221; heading.</p>
<p id="rfc.section.22.3.p.2">The &#8220;QUIC Transport Error Codes&#8221; registry governs a 16-bit space.  This space is split into two spaces that are governed by different policies.  Values with the first byte in the range 0x00 to 0xfe (in hexadecimal) are assigned via the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>.  Values with the first byte 0xff are reserved for Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.22.3.p.3">Registrations MUST include the following fields:</p>
<p></p>

<dl>
<dt>Value:</dt>
<dd style="margin-left: 8">The numeric value of the assignment (registrations will be between 0x0000 and 0xfeff).</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">A short mnemonic for the parameter.</dd>
<dt>Description:</dt>
<dd style="margin-left: 8">A brief description of the error code semantics, which MAY be a summary if a specification reference is provided.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a publicly available specification for the value.</dd>
</dl>
<p id="rfc.section.22.3.p.5">The initial contents of this registry are shown in <a href="#iana-error-table" class="xref">Table 7</a>.  Values from 0xFF00 to 0xFFFF are reserved for Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<div id="rfc.table.7"></div>
<div id="iana-error-table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Initial QUIC Transport Error Codes Entries</caption>
<thead><tr>
<th class="left">Value</th>
<th class="left">Error</th>
<th class="left">Description</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x0</td>
<td class="left">NO_ERROR</td>
<td class="left">No error</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x1</td>
<td class="left">INTERNAL_ERROR</td>
<td class="left">Implementation error</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x2</td>
<td class="left">SERVER_BUSY</td>
<td class="left">Server currently busy</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x3</td>
<td class="left">FLOW_CONTROL_ERROR</td>
<td class="left">Flow control error</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x4</td>
<td class="left">STREAM_LIMIT_ERROR</td>
<td class="left">Too many streams opened</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x5</td>
<td class="left">STREAM_STATE_ERROR</td>
<td class="left">Frame received in invalid stream state</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x6</td>
<td class="left">FINAL_SIZE_ERROR</td>
<td class="left">Change to final size</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x7</td>
<td class="left">FRAME_ENCODING_ERROR</td>
<td class="left">Frame encoding error</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0x8</td>
<td class="left">TRANSPORT_PARAMETER_ERROR</td>
<td class="left">Error in transport parameters</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0xA</td>
<td class="left">PROTOCOL_VIOLATION</td>
<td class="left">Generic protocol violation</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
<tr>
<td class="left">0xC</td>
<td class="left">INVALID_MIGRATION</td>
<td class="left">Violated disabled migration</td>
<td class="left"><a href="#error-codes" class="xref">Section 20</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.references">
<a href="#rfc.references">23.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">23.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="DPLPMTUD">[DPLPMTUD]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Jones, T.</a>, <a>Tuexen, M.</a>, <a>Ruengeler, I.</a> and <a>T. Voelker</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-datagram-plpmtud-07">Packetization Layer Path MTU Discovery for Datagram Transports</a>", Internet-Draft draft-ietf-tsvwg-datagram-plpmtud-07, February 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-RECOVERY">[QUIC-RECOVERY]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Google">I. Swett</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-20">QUIC Loss Detection and Congestion Control</a>", Internet-Draft draft-ietf-quic-recovery-20, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TLS">[QUIC-TLS]</b></td>
<td class="top">
<a title="Mozilla">Thomson, M.</a> and <a title="sn3rd">S. Turner</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-20">Using Transport Layer Security (TLS) to Secure QUIC</a>", Internet-Draft draft-ietf-quic-tls-20, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1191">[RFC1191]</b></td>
<td class="top">
<a>Mogul, J.</a> and <a>S. Deering</a>, "<a href="https://tools.ietf.org/html/rfc1191">Path MTU discovery</a>", RFC 1191, DOI 10.17487/RFC1191, November 1990.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3168">[RFC3168]</b></td>
<td class="top">
<a>Ramakrishnan, K.</a>, <a>Floyd, S.</a> and <a>D. Black</a>, "<a href="https://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>", RFC 3168, DOI 10.17487/RFC3168, September 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="https://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5116">[RFC5116]</b></td>
<td class="top">
<a>McGrew, D.</a>, "<a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6437">[RFC6437]</b></td>
<td class="top">
<a>Amante, S.</a>, <a>Carpenter, B.</a>, <a>Jiang, S.</a> and <a>J. Rajahalme</a>, "<a href="https://tools.ietf.org/html/rfc6437">IPv6 Flow Label Specification</a>", RFC 6437, DOI 10.17487/RFC6437, November 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8085">[RFC8085]</b></td>
<td class="top">
<a>Eggert, L.</a>, <a>Fairhurst, G.</a> and <a>G. Shepherd</a>, "<a href="https://tools.ietf.org/html/rfc8085">UDP Usage Guidelines</a>", BCP 145, RFC 8085, DOI 10.17487/RFC8085, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8126">[RFC8126]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Leiba, B.</a> and <a>T. Narten</a>, "<a href="https://tools.ietf.org/html/rfc8126">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8201">[RFC8201]</b></td>
<td class="top">
<a>McCann, J.</a>, <a>Deering, S.</a>, <a>Mogul, J.</a> and <a>R. Hinden</a>, "<a href="https://tools.ietf.org/html/rfc8201">Path MTU Discovery for IP version 6</a>", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8311">[RFC8311]</b></td>
<td class="top">
<a>Black, D.</a>, "<a href="https://tools.ietf.org/html/rfc8311">Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation</a>", RFC 8311, DOI 10.17487/RFC8311, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="TLS13">[TLS13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">23.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="EARLY-DESIGN">[EARLY-DESIGN]</b></td>
<td class="top">
<a>Roskind, J.</a>, "<a href="https://goo.gl/dMVtFi">QUIC: Multiplexed Transport Over UDP</a>", December 2013.</td>
</tr>
<tr>
<td class="reference"><b id="HTTP2">[HTTP2]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-INVARIANTS">[QUIC-INVARIANTS]</b></td>
<td class="top">
<a title="Mozilla">Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-invariants-04">Version-Independent Properties of QUIC</a>", Internet-Draft draft-ietf-quic-invariants-04, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-MANAGEABILITY">[QUIC-MANAGEABILITY]</b></td>
<td class="top">
<a>Kuehlewind, M.</a> and <a>B. Trammell</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-manageability-03">Manageability of the QUIC Transport Protocol</a>", Internet-Draft draft-ietf-quic-manageability-03, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1812">[RFC1812]</b></td>
<td class="top">
<a>Baker, F.</a>, "<a href="https://tools.ietf.org/html/rfc1812">Requirements for IP Version 4 Routers</a>", RFC 1812, DOI 10.17487/RFC1812, June 1995.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2018">[RFC2018]</b></td>
<td class="top">
<a>Mathis, M.</a>, <a>Mahdavi, J.</a>, <a>Floyd, S.</a> and <a>A. Romanow</a>, "<a href="https://tools.ietf.org/html/rfc2018">TCP Selective Acknowledgment Options</a>", RFC 2018, DOI 10.17487/RFC2018, October 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2104">[RFC2104]</b></td>
<td class="top">
<a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, "<a href="https://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2360">[RFC2360]</b></td>
<td class="top">
<a>Scott, G.</a>, "<a href="https://tools.ietf.org/html/rfc2360">Guide for Internet Standards Writers</a>", BCP 22, RFC 2360, DOI 10.17487/RFC2360, June 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4303">[RFC4303]</b></td>
<td class="top">
<a>Kent, S.</a>, "<a href="https://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, DOI 10.17487/RFC4303, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4443">[RFC4443]</b></td>
<td class="top">
<a>Conta, A.</a>, <a>Deering, S.</a> and <a>M. Gupta</a>, "<a href="https://tools.ietf.org/html/rfc4443">Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</a>", STD 89, RFC 4443, DOI 10.17487/RFC4443, March 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4787">[RFC4787]</b></td>
<td class="top">
<a>Audet, F.</a> and <a>C. Jennings</a>, "<a href="https://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7301">[RFC7301]</b></td>
<td class="top">
<a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8200">[RFC8200]</b></td>
<td class="top">
<a>Deering, S.</a> and <a>R. Hinden</a>, "<a href="https://tools.ietf.org/html/rfc8200">Internet Protocol, Version 6 (IPv6) Specification</a>", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SLOWLORIS">[SLOWLORIS]</b></td>
<td class="top">
<a>RSnake Hansen, R.</a>, "<a href="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">Welcome to Slowloris...</a>", June 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#sample-packet-number-decoding" id="sample-packet-number-decoding">Sample Packet Number Decoding Algorithm</a>
</h1>
<p id="rfc.section.A.p.1">The following pseudo-code shows how an implementation can decode packet numbers after header protection has been removed.</p>
<pre>
DecodePacketNumber(largest_pn, truncated_pn, pn_nbits):
   expected_pn  = largest_pn + 1
   pn_win       = 1 &lt;&lt; pn_nbits
   pn_hwin      = pn_win / 2
   pn_mask      = pn_win - 1
   // The incoming packet number should be greater than
   // expected_pn - pn_hwin and less than or equal to
   // expected_pn + pn_hwin
   //
   // This means we can't just strip the trailing bits from
   // expected_pn and add the truncated_pn because that might
   // yield a value outside the window.
   //
   // The following code calculates a candidate value and
   // makes sure it's within the packet number window.
   candidate_pn = (expected_pn &amp; ~pn_mask) | truncated_pn
   if candidate_pn &lt;= expected_pn - pn_hwin:
      return candidate_pn + pn_win
   // Note the extra check for underflow when candidate_pn
   // is near zero.
   if candidate_pn &gt; expected_pn + pn_hwin and
      candidate_pn &gt; pn_win:
      return candidate_pn - pn_win
   return candidate_pn
</pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong> Please remove this section prior to publication of a final version of this document.</li></ul>
<p id="rfc.section.B.p.2">Issue and pull request numbers are listed with a leading octothorp.</p>
<h2 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#since-draft-ietf-quic-transport-19" id="since-draft-ietf-quic-transport-19">Since draft-ietf-quic-transport-19</a>
</h2>
<p></p>

<ul>
<li>Refine discussion of 0-RTT transport parameters (#2467, #2464)</li>
<li>Fewer transport parameters need to be remembered for 0-RTT (#2624, #2467)</li>
<li>Spin bit text incorporated (#2564)</li>
<li>Close the connection when maximum stream ID in MAX_STREAMS exceeds 2^62 - 1 (#2499, #2487)</li>
<li>New connection ID required for intentional migration (#2414, #2413)</li>
<li>Connection ID issuance can be rate-limited (#2436, #2428)</li>
<li>The &#8220;QUIC bit&#8221; is ignored in Version Negotiation (#2400, #2561)</li>
<li>Initial packets from clients need to be padded to 1200 unless a Handshake packet is sent as well (#2522, #2523)</li>
<li>CRYPTO frames can be discarded if too much data is buffered (#1834, #2524)</li>
<li>Stateless reset uses a short header packet (#2599, #2600)</li>
</ul>
<h2 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#since-draft-ietf-quic-transport-18" id="since-draft-ietf-quic-transport-18">Since draft-ietf-quic-transport-18</a>
</h2>
<p></p>

<ul>
<li>Removed version negotation; version negotiation, including authentication of the result, will be addressed in the next version of QUIC (#1773, #2313)</li>
<li>Added discussion of the use of IPv6 flow labels (#2348, #2399)</li>
<li>A connection ID can&#8217;t be retired in a packet that uses that connection ID (#2101, #2420)</li>
<li>Idle timeout transport parameter is in milliseconds (from seconds) (#2453, #2454)</li>
<li>Endpoints are required to use new connnection IDs when they use new network paths (#2413, #2414)</li>
<li>Increased the set of permissible frames in 0-RTT (#2344, #2355)</li>
</ul>
<h2 id="rfc.appendix.B.3">
<a href="#rfc.appendix.B.3">B.3.</a> <a href="#since-draft-ietf-quic-transport-17" id="since-draft-ietf-quic-transport-17">Since draft-ietf-quic-transport-17</a>
</h2>
<p></p>

<ul>
<li>Stream-related errors now use STREAM_STATE_ERROR (#2305)</li>
<li>Endpoints discard initial keys as soon as handshake keys are available (#1951, #2045)</li>
<li>Expanded conditions for ignoring ICMP packet too big messages (#2108, #2161)</li>
<li>Remove rate control from PATH_CHALLENGE/PATH_RESPONSE (#2129, #2241)</li>
<li>Endpoints are permitted to discard malformed initial packets (#2141)</li>
<li>Clarified ECN implementation and usage requirements (#2156, #2201)</li>
<li>Disable ECN count verification for packets that arrive out of order (#2198, #2215)</li>
<li>Use Probe Timeout (PTO) instead of RTO (#2206, #2238)</li>
<li>Loosen constraints on retransmission of ACK ranges (#2199, #2245)</li>
<li>Limit Retry and Version Negotiation to once per datagram (#2259, #2303)</li>
<li>Set a maximum value for max_ack_delay transport parameter (#2282, #2301)</li>
<li>Allow server preferred address for both IPv4 and IPv6 (#2122, #2296)</li>
<li>Corrected requirements for migration to a preferred address (#2146, #2349)</li>
<li>ACK of non-existent packet is illegal (#2298, #2302)</li>
</ul>
<h2 id="rfc.appendix.B.4">
<a href="#rfc.appendix.B.4">B.4.</a> <a href="#since-draft-ietf-quic-transport-16" id="since-draft-ietf-quic-transport-16">Since draft-ietf-quic-transport-16</a>
</h2>
<p></p>

<ul>
<li>Stream limits are defined as counts, not maximums (#1850, #1906)</li>
<li>Require amplification attack defense after closing (#1905, #1911)</li>
<li>Remove reservation of application error code 0 for STOPPING (#1804, #1922)</li>
<li>Renumbered frames (#1945)</li>
<li>Renumbered transport parameters (#1946)</li>
<li>Numeric transport parameters are expressed as varints (#1608, #1947, #1955)</li>
<li>Reorder the NEW_CONNECTION_ID frame (#1952, #1963)</li>
<li>Rework the first byte (#2006) <ul>
<li>Fix the 0x40 bit</li>
<li>Change type values for long header</li>
<li>Add spin bit to short header (#631, #1988)</li>
<li>Encrypt the remainder of the first byte (#1322)</li>
<li>Move packet number length to first byte</li>
<li>Move ODCIL to first byte of retry packets</li>
<li>Simplify packet number protection (#1575)</li>
</ul>
</li>
<li>Allow STOP_SENDING to open a remote bidirectional stream (#1797, #2013)</li>
<li>Added mitigation for off-path migration attacks (#1278, #1749, #2033)</li>
<li>Don&#8217;t let the PMTU to drop below 1280 (#2063, #2069)</li>
<li>Require peers to replace retired connection IDs (#2085)</li>
<li>Servers are required to ignore Version Negotiation packets (#2088)</li>
<li>Tokens are repeated in all Initial packets (#2089)</li>
<li>Clarified how PING frames are sent after loss (#2094)</li>
<li>Initial keys are discarded once Handshake are available (#1951, #2045)</li>
<li>ICMP PTB validation clarifications (#2161, #2109, #2108)</li>
</ul>
<h2 id="rfc.appendix.B.5">
<a href="#rfc.appendix.B.5">B.5.</a> <a href="#since-draft-ietf-quic-transport-15" id="since-draft-ietf-quic-transport-15">Since draft-ietf-quic-transport-15</a>
</h2>
<p id="rfc.section.B.5.p.1">Substantial editorial reorganization; no technical changes.</p>
<h2 id="rfc.appendix.B.6">
<a href="#rfc.appendix.B.6">B.6.</a> <a href="#since-draft-ietf-quic-transport-14" id="since-draft-ietf-quic-transport-14">Since draft-ietf-quic-transport-14</a>
</h2>
<p></p>

<ul>
<li>Merge ACK and ACK_ECN (#1778, #1801)</li>
<li>Explicitly communicate max_ack_delay (#981, #1781)</li>
<li>Validate original connection ID after Retry packets (#1710, #1486, #1793)</li>
<li>Idle timeout is optional and has no specified maximum (#1765)</li>
<li>Update connection ID handling; add RETIRE_CONNECTION_ID type (#1464, #1468, #1483, #1484, #1486, #1495, #1729, #1742, #1799, #1821)</li>
<li>Include a Token in all Initial packets (#1649, #1794)</li>
<li>Prevent handshake deadlock (#1764, #1824)</li>
</ul>
<h2 id="rfc.appendix.B.7">
<a href="#rfc.appendix.B.7">B.7.</a> <a href="#since-draft-ietf-quic-transport-13" id="since-draft-ietf-quic-transport-13">Since draft-ietf-quic-transport-13</a>
</h2>
<p></p>

<ul>
<li>Streams open when higher-numbered streams of the same type open (#1342, #1549)</li>
<li>Split initial stream flow control limit into 3 transport parameters (#1016, #1542)</li>
<li>All flow control transport parameters are optional (#1610)</li>
<li>Removed UNSOLICITED_PATH_RESPONSE error code (#1265, #1539)</li>
<li>Permit stateless reset in response to any packet (#1348, #1553)</li>
<li>Recommended defense against stateless reset spoofing (#1386, #1554)</li>
<li>Prevent infinite stateless reset exchanges (#1443, #1627)</li>
<li>Forbid processing of the same packet number twice (#1405, #1624)</li>
<li>Added a packet number decoding example (#1493)</li>
<li>More precisely define idle timeout (#1429, #1614, #1652)</li>
<li>Corrected format of Retry packet and prevented looping (#1492, #1451, #1448, #1498)</li>
<li>Permit 0-RTT after receiving Version Negotiation or Retry (#1507, #1514, #1621)</li>
<li>Permit Retry in response to 0-RTT (#1547, #1552)</li>
<li>Looser verification of ECN counters to account for ACK loss (#1555, #1481, #1565)</li>
<li>Remove frame type field from APPLICATION_CLOSE (#1508, #1528)</li>
</ul>
<h2 id="rfc.appendix.B.8">
<a href="#rfc.appendix.B.8">B.8.</a> <a href="#since-draft-ietf-quic-transport-12" id="since-draft-ietf-quic-transport-12">Since draft-ietf-quic-transport-12</a>
</h2>
<p></p>

<ul>
<li>Changes to integration of the TLS handshake (#829, #1018, #1094, #1165, #1190, #1233, #1242, #1252, #1450, #1458) <ul>
<li>The cryptographic handshake uses CRYPTO frames, not stream 0</li>
<li>QUIC packet protection is used in place of TLS record protection</li>
<li>Separate QUIC packet number spaces are used for the handshake</li>
<li>Changed Retry to be independent of the cryptographic handshake</li>
<li>Added NEW_TOKEN frame and Token fields to Initial packet</li>
<li>Limit the use of HelloRetryRequest to address TLS needs (like key shares)</li>
</ul>
</li>
<li>Enable server to transition connections to a preferred address (#560, #1251, #1373)</li>
<li>Added ECN feedback mechanisms and handling; new ACK_ECN frame (#804, #805, #1372)</li>
<li>Changed rules and recommendations for use of new connection IDs (#1258, #1264, #1276, #1280, #1419, #1452, #1453, #1465)</li>
<li>Added a transport parameter to disable intentional connection migration (#1271, #1447)</li>
<li>Packets from different connection ID can&#8217;t be coalesced (#1287, #1423)</li>
<li>Fixed sampling method for packet number encryption; the length field in long headers includes the packet number field in addition to the packet payload (#1387, #1389)</li>
<li>Stateless Reset is now symmetric and subject to size constraints (#466, #1346)</li>
<li>Added frame type extension mechanism (#58, #1473)</li>
</ul>
<h2 id="rfc.appendix.B.9">
<a href="#rfc.appendix.B.9">B.9.</a> <a href="#since-draft-ietf-quic-transport-11" id="since-draft-ietf-quic-transport-11">Since draft-ietf-quic-transport-11</a>
</h2>
<p></p>

<ul>
<li>Enable server to transition connections to a preferred address (#560, #1251)</li>
<li>Packet numbers are encrypted (#1174, #1043, #1048, #1034, #850, #990, #734, #1317, #1267, #1079)</li>
<li>Packet numbers use a variable-length encoding (#989, #1334)</li>
<li>STREAM frames can now be empty (#1350)</li>
</ul>
<h2 id="rfc.appendix.B.10">
<a href="#rfc.appendix.B.10">B.10.</a> <a href="#since-draft-ietf-quic-transport-10" id="since-draft-ietf-quic-transport-10">Since draft-ietf-quic-transport-10</a>
</h2>
<p></p>

<ul>
<li>Swap payload length and packed number fields in long header (#1294)</li>
<li>Clarified that CONNECTION_CLOSE is allowed in Handshake packet (#1274)</li>
<li>Spin bit reserved (#1283)</li>
<li>Coalescing multiple QUIC packets in a UDP datagram (#1262, #1285)</li>
<li>A more complete connection migration (#1249)</li>
<li>Refine opportunistic ACK defense text (#305, #1030, #1185)</li>
<li>A Stateless Reset Token isn&#8217;t mandatory (#818, #1191)</li>
<li>Removed implicit stream opening (#896, #1193)</li>
<li>An empty STREAM frame can be used to open a stream without sending data (#901, #1194)</li>
<li>Define stream counts in transport parameters rather than a maximum stream ID (#1023, #1065)</li>
<li>STOP_SENDING is now prohibited before streams are used (#1050)</li>
<li>Recommend including ACK in Retry packets and allow PADDING (#1067, #882)</li>
<li>Endpoints now become closing after an idle timeout (#1178, #1179)</li>
<li>Remove implication that Version Negotiation is sent when a packet of the wrong version is received (#1197)</li>
</ul>
<h2 id="rfc.appendix.B.11">
<a href="#rfc.appendix.B.11">B.11.</a> <a href="#since-draft-ietf-quic-transport-09" id="since-draft-ietf-quic-transport-09">Since draft-ietf-quic-transport-09</a>
</h2>
<p></p>

<ul>
<li>Added PATH_CHALLENGE and PATH_RESPONSE frames to replace PING with Data and PONG frame. Changed ACK frame type from 0x0e to 0x0d. (#1091, #725, #1086)</li>
<li>A server can now only send 3 packets without validating the client address (#38, #1090)</li>
<li>Delivery order of stream data is no longer strongly specified (#252, #1070)</li>
<li>Rework of packet handling and version negotiation (#1038)</li>
<li>Stream 0 is now exempt from flow control until the handshake completes (#1074, #725, #825, #1082)</li>
<li>Improved retransmission rules for all frame types: information is retransmitted, not packets or frames (#463, #765, #1095, #1053)</li>
<li>Added an error code for server busy signals (#1137)</li>
<li>Endpoints now set the connection ID that their peer uses.  Connection IDs are variable length.  Removed the omit_connection_id transport parameter and the corresponding short header flag. (#1089, #1052, #1146, #821, #745, #821, #1166, #1151)</li>
</ul>
<h2 id="rfc.appendix.B.12">
<a href="#rfc.appendix.B.12">B.12.</a> <a href="#since-draft-ietf-quic-transport-08" id="since-draft-ietf-quic-transport-08">Since draft-ietf-quic-transport-08</a>
</h2>
<p></p>

<ul>
<li>Clarified requirements for BLOCKED usage (#65,  #924)</li>
<li>BLOCKED frame now includes reason for blocking (#452, #924, #927, #928)</li>
<li>GAP limitation in ACK Frame (#613)</li>
<li>Improved PMTUD description (#614, #1036)</li>
<li>Clarified stream state machine (#634, #662, #743, #894)</li>
<li>Reserved versions don&#8217;t need to be generated deterministically (#831, #931)</li>
<li>You don&#8217;t always need the draining period (#871)</li>
<li>Stateless reset clarified as version-specific (#930, #986)</li>
<li>initial_max_stream_id_x transport parameters are optional (#970, #971)</li>
<li>Ack Delay assumes a default value during the handshake (#1007, #1009)</li>
<li>Removed transport parameters from NewSessionTicket (#1015)</li>
</ul>
<h2 id="rfc.appendix.B.13">
<a href="#rfc.appendix.B.13">B.13.</a> <a href="#since-draft-ietf-quic-transport-07" id="since-draft-ietf-quic-transport-07">Since draft-ietf-quic-transport-07</a>
</h2>
<p></p>

<ul>
<li>The long header now has version before packet number (#926, #939)</li>
<li>Rename and consolidate packet types (#846, #822, #847)</li>
<li>Packet types are assigned new codepoints and the Connection ID Flag is inverted (#426, #956)</li>
<li>Removed type for Version Negotiation and use Version 0 (#963, #968)</li>
<li>Streams are split into unidirectional and bidirectional (#643, #656, #720, #872, #175, #885) <ul>
<li>Stream limits now have separate uni- and bi-directional transport parameters (#909, #958)</li>
<li>Stream limit transport parameters are now optional and default to 0 (#970, #971)</li>
</ul>
</li>
<li>The stream state machine has been split into read and write (#634, #894)</li>
<li>Employ variable-length integer encodings throughout (#595)</li>
<li>Improvements to connection close <ul>
<li>Added distinct closing and draining states (#899, #871)</li>
<li>Draining period can terminate early (#869, #870)</li>
<li>Clarifications about stateless reset (#889, #890)</li>
</ul>
</li>
<li>Address validation for connection migration (#161, #732, #878)</li>
<li>Clearly defined retransmission rules for BLOCKED (#452, #65, #924)</li>
<li>negotiated_version is sent in server transport parameters (#710, #959)</li>
<li>Increased the range over which packet numbers are randomized (#864, #850, #964)</li>
</ul>
<h2 id="rfc.appendix.B.14">
<a href="#rfc.appendix.B.14">B.14.</a> <a href="#since-draft-ietf-quic-transport-06" id="since-draft-ietf-quic-transport-06">Since draft-ietf-quic-transport-06</a>
</h2>
<p></p>

<ul>
<li>Replaced FNV-1a with AES-GCM for all &#8220;Cleartext&#8221; packets (#554)</li>
<li>Split error code space between application and transport (#485)</li>
<li>Stateless reset token moved to end (#820)</li>
<li>1-RTT-protected long header types removed (#848)</li>
<li>No acknowledgments during draining period (#852)</li>
<li>Remove &#8220;application close&#8221; as a separate close type (#854)</li>
<li>Remove timestamps from the ACK frame (#841)</li>
<li>Require transport parameters to only appear once (#792)</li>
</ul>
<h2 id="rfc.appendix.B.15">
<a href="#rfc.appendix.B.15">B.15.</a> <a href="#since-draft-ietf-quic-transport-05" id="since-draft-ietf-quic-transport-05">Since draft-ietf-quic-transport-05</a>
</h2>
<p></p>

<ul>
<li>Stateless token is server-only (#726)</li>
<li>Refactor section on connection termination (#733, #748, #328, #177)</li>
<li>Limit size of Version Negotiation packet (#585)</li>
<li>Clarify when and what to ack (#736)</li>
<li>Renamed STREAM_ID_NEEDED to STREAM_ID_BLOCKED</li>
<li>Clarify Keep-alive requirements (#729)</li>
</ul>
<h2 id="rfc.appendix.B.16">
<a href="#rfc.appendix.B.16">B.16.</a> <a href="#since-draft-ietf-quic-transport-04" id="since-draft-ietf-quic-transport-04">Since draft-ietf-quic-transport-04</a>
</h2>
<p></p>

<ul>
<li>Introduce STOP_SENDING frame, RESET_STREAM only resets in one direction (#165)</li>
<li>Removed GOAWAY; application protocols are responsible for graceful shutdown (#696)</li>
<li>Reduced the number of error codes (#96, #177, #184, #211)</li>
<li>Version validation fields can&#8217;t move or change (#121)</li>
<li>Removed versions from the transport parameters in a NewSessionTicket message (#547)</li>
<li>Clarify the meaning of &#8220;bytes in flight&#8221; (#550)</li>
<li>Public reset is now stateless reset and not visible to the path (#215)</li>
<li>Reordered bits and fields in STREAM frame (#620)</li>
<li>Clarifications to the stream state machine (#572, #571)</li>
<li>Increased the maximum length of the Largest Acknowledged field in ACK frames to 64 bits (#629)</li>
<li>truncate_connection_id is renamed to omit_connection_id (#659)</li>
<li>CONNECTION_CLOSE terminates the connection like TCP RST (#330, #328)</li>
<li>Update labels used in HKDF-Expand-Label to match TLS 1.3 (#642)</li>
</ul>
<h2 id="rfc.appendix.B.17">
<a href="#rfc.appendix.B.17">B.17.</a> <a href="#since-draft-ietf-quic-transport-03" id="since-draft-ietf-quic-transport-03">Since draft-ietf-quic-transport-03</a>
</h2>
<p></p>

<ul>
<li>Change STREAM and RESET_STREAM layout</li>
<li>Add MAX_STREAM_ID settings</li>
</ul>
<h2 id="rfc.appendix.B.18">
<a href="#rfc.appendix.B.18">B.18.</a> <a href="#since-draft-ietf-quic-transport-02" id="since-draft-ietf-quic-transport-02">Since draft-ietf-quic-transport-02</a>
</h2>
<p></p>

<ul>
<li>The size of the initial packet payload has a fixed minimum (#267, #472)</li>
<li>Define when Version Negotiation packets are ignored (#284, #294, #241, #143, #474)</li>
<li>The 64-bit FNV-1a algorithm is used for integrity protection of unprotected packets (#167, #480, #481, #517)</li>
<li>Rework initial packet types to change how the connection ID is chosen (#482, #442, #493)</li>
<li>No timestamps are forbidden in unprotected packets (#542, #429)</li>
<li>Cryptographic handshake is now on stream 0 (#456)</li>
<li>Remove congestion control exemption for cryptographic handshake (#248, #476)</li>
<li>Version 1 of QUIC uses TLS; a new version is needed to use a different handshake protocol (#516)</li>
<li>STREAM frames have a reduced number of offset lengths (#543, #430)</li>
<li>Split some frames into separate connection- and stream- level frames (#443) <ul>
<li>WINDOW_UPDATE split into MAX_DATA and MAX_STREAM_DATA (#450)</li>
<li>BLOCKED split to match WINDOW_UPDATE split (#454)</li>
<li>Define STREAM_ID_NEEDED frame (#455)</li>
</ul>
</li>
<li>A NEW_CONNECTION_ID frame supports connection migration without linkability (#232, #491, #496)</li>
<li>Transport parameters for 0-RTT are retained from a previous connection (#405, #513, #512) <ul><li>A client in 0-RTT no longer required to reset excess streams (#425, #479)</li></ul>
</li>
<li>Expanded security considerations (#440, #444, #445, #448)</li>
</ul>
<h2 id="rfc.appendix.B.19">
<a href="#rfc.appendix.B.19">B.19.</a> <a href="#since-draft-ietf-quic-transport-01" id="since-draft-ietf-quic-transport-01">Since draft-ietf-quic-transport-01</a>
</h2>
<p></p>

<ul>
<li>Defined short and long packet headers (#40, #148, #361)</li>
<li>Defined a versioning scheme and stable fields (#51, #361)</li>
<li>Define reserved version values for &#8220;greasing&#8221; negotiation (#112, #278)</li>
<li>The initial packet number is randomized (#35, #283)</li>
<li>Narrow the packet number encoding range requirement (#67, #286, #299, #323, #356)</li>
<li>Defined client address validation (#52, #118, #120, #275)</li>
<li>Define transport parameters as a TLS extension (#49, #122)</li>
<li>SCUP and COPT parameters are no longer valid (#116, #117)</li>
<li>Transport parameters for 0-RTT are either remembered from before, or assume default values (#126)</li>
<li>The server chooses connection IDs in its final flight (#119, #349, #361)</li>
<li>The server echoes the Connection ID and packet number fields when sending a Version Negotiation packet (#133, #295, #244)</li>
<li>Defined a minimum packet size for the initial handshake packet from the client (#69, #136, #139, #164)</li>
<li>Path MTU Discovery (#64, #106)</li>
<li>The initial handshake packet from the client needs to fit in a single packet (#338)</li>
<li>Forbid acknowledgment of packets containing only ACK and PADDING (#291)</li>
<li>Require that frames are processed when packets are acknowledged (#381, #341)</li>
<li>Removed the STOP_WAITING frame (#66)</li>
<li>Don&#8217;t require retransmission of old timestamps for lost ACK frames (#308)</li>
<li>Clarified that frames are not retransmitted, but the information in them can be (#157, #298)</li>
<li>Error handling definitions (#335)</li>
<li>Split error codes into four sections (#74)</li>
<li>Forbid the use of Public Reset where CONNECTION_CLOSE is possible (#289)</li>
<li>Define packet protection rules (#336)</li>
<li>Require that stream be entirely delivered or reset, including acknowledgment of all STREAM frames or the RESET_STREAM, before it closes (#381)</li>
<li>Remove stream reservation from state machine (#174, #280)</li>
<li>Only stream 1 does not contribute to connection-level flow control (#204)</li>
<li>Stream 1 counts towards the maximum concurrent stream limit (#201, #282)</li>
<li>Remove connection-level flow control exclusion for some streams (except 1) (#246)</li>
<li>RESET_STREAM affects connection-level flow control (#162, #163)</li>
<li>Flow control accounting uses the maximum data offset on each stream, rather than bytes received (#378)</li>
<li>Moved length-determining fields to the start of STREAM and ACK (#168, #277)</li>
<li>Added the ability to pad between frames (#158, #276)</li>
<li>Remove error code and reason phrase from GOAWAY (#352, #355)</li>
<li>GOAWAY includes a final stream number for both directions (#347)</li>
<li>Error codes for RESET_STREAM and CONNECTION_CLOSE are now at a consistent offset (#249)</li>
<li>Defined priority as the responsibility of the application protocol (#104, #303)</li>
</ul>
<h2 id="rfc.appendix.B.20">
<a href="#rfc.appendix.B.20">B.20.</a> <a href="#since-draft-ietf-quic-transport-00" id="since-draft-ietf-quic-transport-00">Since draft-ietf-quic-transport-00</a>
</h2>
<p></p>

<ul>
<li>Replaced DIVERSIFICATION_NONCE flag with KEY_PHASE flag</li>
<li>Defined versioning</li>
<li>Reworked description of packet and frame layout</li>
<li>Error code space is divided into regions for each component</li>
<li>Use big endian for all numeric values</li>
</ul>
<h2 id="rfc.appendix.B.21">
<a href="#rfc.appendix.B.21">B.21.</a> <a href="#since-draft-hamilton-quic-transport-protocol-01" id="since-draft-hamilton-quic-transport-protocol-01">Since draft-hamilton-quic-transport-protocol-01</a>
</h2>
<p></p>

<ul>
<li>Adopted as base for draft-ietf-quic-tls</li>
<li>Updated authors/editors list</li>
<li>Added IANA Considerations section</li>
<li>Moved Contributors and Acknowledgments to appendices</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.C.p.1">Special thanks are due to the following for helping shape pre-IETF QUIC and its deployment: Chris Bentzel, Misha Efimov, Roberto Peon, Alistair Riddoch, Siddharth Vijayakrishnan, and Assar Westerlund.</p>
<p id="rfc.section.C.p.2">This document has benefited immensely from various private discussions and public ones on the quic@ietf.org and proto-quic@chromium.org mailing lists. Our thanks to all.</p>
<h1 id="rfc.contributors"><a href="#rfc.contributors">Contributors</a></h1>
<p id="rfc.section.D.p.1">The original authors of this specification were Ryan Hamilton, Jana Iyengar, Ian Swett, and Alyssa Wilk.</p>
<p id="rfc.section.D.p.2">The original design and rationale behind this protocol draw significantly from work by Jim Roskind <a href="#EARLY-DESIGN" class="xref">[EARLY-DESIGN]</a>. In alphabetical order, the contributors to the pre-IETF QUIC project at Google are: Britt Cyr, Jeremy Dorfman, Ryan Hamilton, Jana Iyengar, Fedor Kouranov, Charles Krasic, Jo Kulik, Adam Langley, Jim Roskind, Robbie Shade, Satyam Shekhar, Cherie Shi, Ian Swett, Raman Tenneti, Victor Vasiliev, Antonio Vicente, Patrik Westin, Alyssa Wilk, Dale Worley, Fan Yang, Dan Zhang, Daniel Ziegler.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Fastly</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri.ietf@gmail.com">jri.ietf@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mt@lowentropy.net">mt@lowentropy.net</a></span>

  </address>
</div>

</body>
</html>
